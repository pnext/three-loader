{"version":3,"file":"potree.js","mappings":"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","sources":["webpack://potree/webpack/universalModuleDefinition","webpack://potree/./src/workers/binary-decoder.worker.js","webpack://potree/./src/loading2/gltf-splats-compressed-decoder.worker.js","webpack://potree/./src/materials/shaders/pointcloud.frag","webpack://potree/./src/loading2/gltf-decoder.worker.js","webpack://potree/./src/materials/shaders/pointcloud.vert","webpack://potree/./src/loading2/decoder.worker.js","webpack://potree/./src/materials/shaders/blur.frag","webpack://potree/./src/materials/shaders/splats.frag","webpack://potree/./node_modules/worker-loader/dist/runtime/inline.js","webpack://potree/./src/materials/shaders/blur.vert","webpack://potree/external umd \"three\"","webpack://potree/./src/loading2/gltf-splats-decoder.worker.js","webpack://potree/./src/materials/shaders/splats.vert","webpack://potree/webpack/bootstrap","webpack://potree/webpack/runtime/compat get default export","webpack://potree/webpack/runtime/define property getters","webpack://potree/webpack/runtime/hasOwnProperty shorthand","webpack://potree/webpack/runtime/make namespace object","webpack://potree/./src/materials/clipping.ts","webpack://potree/./src/materials/enums.ts","webpack://potree/./src/materials/blur-material.ts","webpack://potree/./src/constants.ts","webpack://potree/./src/utils/utils.ts","webpack://potree/./src/materials/classification.ts","webpack://potree/./src/materials/gradients/grayscale.ts","webpack://potree/./src/materials/gradients/inferno.ts","webpack://potree/./src/materials/gradients/plasma.ts","webpack://potree/./src/materials/gradients/rainbow.ts","webpack://potree/./src/materials/gradients/spectral.ts","webpack://potree/./src/materials/gradients/vidris.ts","webpack://potree/./src/materials/gradients/yellow-green.ts","webpack://potree/./src/materials/texture-generation.ts","webpack://potree/./src/materials/point-cloud-material.ts","webpack://potree/./src/point-attributes.ts","webpack://potree/./src/utils/bounds.ts","webpack://potree/./src/point-cloud-octree-geometry-node.ts","webpack://potree/./src/point-cloud-octree-geometry.ts","webpack://potree/./src/point-cloud-octree-node.ts","webpack://potree/./src/utils/math.ts","webpack://potree/./src/point-cloud-octree-picker.ts","webpack://potree/./src/loading2/octree-geometry.ts","webpack://potree/./src/point-cloud-tree.ts","webpack://potree/./src/workers/SortWorker.ts","webpack://potree/./src/splats-mesh.ts","webpack://potree/./src/point-cloud-octree.ts","webpack://potree/./src/features.ts","webpack://potree/./src/utils/async-blocking-queue.ts","webpack://potree/./src/utils/worker-pool.ts","webpack://potree/./src/version.ts","webpack://potree/./src/loading/binary-loader.ts","webpack://potree/./src/loading/load-poc.ts","webpack://potree/./src/loading2/worker-pool.ts","webpack://potree/./src/loading2/decoder.ts","webpack://potree/./src/loading2/utils.ts","webpack://potree/./src/loading2/gltf-decoder.ts","webpack://potree/./src/loading2/gltf-splats-decoder.ts","webpack://potree/./src/loading2/octree-geometry-node.ts","webpack://potree/./src/loading2/point-attributes.ts","webpack://potree/./src/loading2/octree-loader.ts","webpack://potree/./src/loading2/load-octree.ts","webpack://potree/./src/type-predicates.ts","webpack://potree/./src/utils/binary-heap.js","webpack://potree/./src/utils/box3-helper.ts","webpack://potree/./src/utils/lru.ts","webpack://potree/./src/potree.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"potree\", [\"three\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"potree\"] = factory(require(\"three\"));\n\telse\n\t\troot[\"potree\"] = factory(root[\"three\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__604__) => {\nreturn ","\nimport worker from \"!!../../node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";var t;!function(t){t[t.POSITION_CARTESIAN=0]=\\\"POSITION_CARTESIAN\\\",t[t.COLOR_PACKED=1]=\\\"COLOR_PACKED\\\",t[t.COLOR_FLOATS_1=2]=\\\"COLOR_FLOATS_1\\\",t[t.COLOR_FLOATS_255=3]=\\\"COLOR_FLOATS_255\\\",t[t.NORMAL_FLOATS=4]=\\\"NORMAL_FLOATS\\\",t[t.FILLER=5]=\\\"FILLER\\\",t[t.INTENSITY=6]=\\\"INTENSITY\\\",t[t.CLASSIFICATION=7]=\\\"CLASSIFICATION\\\",t[t.NORMAL_SPHEREMAPPED=8]=\\\"NORMAL_SPHEREMAPPED\\\",t[t.NORMAL_OCT16=9]=\\\"NORMAL_OCT16\\\",t[t.NORMAL=10]=\\\"NORMAL\\\"}(t||(t={}));const e={ordinal:1,size:4},n={ordinal:2,size:1},r={ordinal:3,size:1};function i(t,e,n){return{name:t,type:e,numElements:n,byteSize:n*e.size}}const s=i(t.COLOR_PACKED,n,4),a={POSITION_CARTESIAN:i(t.POSITION_CARTESIAN,e,3),RGBA_PACKED:s,COLOR_PACKED:s,RGB_PACKED:i(t.COLOR_PACKED,n,3),NORMAL_FLOATS:i(t.NORMAL_FLOATS,e,3),FILLER_1B:i(t.FILLER,r,1),INTENSITY:i(t.INTENSITY,{ordinal:5,size:2},1),CLASSIFICATION:i(t.CLASSIFICATION,r,1),NORMAL_SPHEREMAPPED:i(t.NORMAL_SPHEREMAPPED,r,2),NORMAL_OCT16:i(t.NORMAL_OCT16,r,2),NORMAL:i(t.NORMAL,e,3)};class o{constructor(t){this.versionMinor=0,this.version=t;const e=-1===t.indexOf(\\\".\\\")?t.length:t.indexOf(\\\".\\\");this.versionMajor=parseInt(t.substr(0,e),10),this.versionMinor=parseInt(t.substr(e+1),10),isNaN(this.versionMinor)&&(this.versionMinor=0)}newerThan(t){const e=new o(t);return this.versionMajor>e.versionMajor||this.versionMajor===e.versionMajor&&this.versionMinor>e.versionMinor}equalOrHigher(t){const e=new o(t);return this.versionMajor>e.versionMajor||this.versionMajor===e.versionMajor&&this.versionMinor>=e.versionMinor}upTo(t){return!this.newerThan(t)}}class u{constructor(t){this.tmp=new ArrayBuffer(4),this.tmpf=new Float32Array(this.tmp),this.tmpu8=new Uint8Array(this.tmp),this.u8=new Uint8Array(t)}getUint32(t){return this.u8[t+3]<<24|this.u8[t+2]<<16|this.u8[t+1]<<8|this.u8[t]}getUint16(t){return this.u8[t+1]<<8|this.u8[t]}getFloat32(t){const e=this.tmpu8,n=this.u8,r=this.tmpf;return e[0]=n[t+0],e[1]=n[t+1],e[2]=n[t+2],e[3]=n[t+3],r[0]}getUint8(t){return this.u8[t]}}const f=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1};function A(e,n){const r=function(e,n){switch(e.name){case t.POSITION_CARTESIAN:return function(t,e){const n=new ArrayBuffer(4*e.numPoints*3),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++){let n,i,s;e.version.newerThan(\\\"1.3\\\")?(n=e.data.getUint32(e.currentOffset+t*e.pointAttributes.byteSize+0)*e.scale,i=e.data.getUint32(e.currentOffset+t*e.pointAttributes.byteSize+4)*e.scale,s=e.data.getUint32(e.currentOffset+t*e.pointAttributes.byteSize+8)*e.scale):(n=e.data.getFloat32(t*e.pointAttributes.byteSize+0)+e.nodeOffset[0],i=e.data.getFloat32(t*e.pointAttributes.byteSize+4)+e.nodeOffset[1],s=e.data.getFloat32(t*e.pointAttributes.byteSize+8)+e.nodeOffset[2]),r[3*t+0]=n,r[3*t+1]=i,r[3*t+2]=s,e.mean[0]+=n/e.numPoints,e.mean[1]+=i/e.numPoints,e.mean[2]+=s/e.numPoints,e.tightBoxMin[0]=Math.min(e.tightBoxMin[0],n),e.tightBoxMin[1]=Math.min(e.tightBoxMin[1],i),e.tightBoxMin[2]=Math.min(e.tightBoxMin[2],s),e.tightBoxMax[0]=Math.max(e.tightBoxMax[0],n),e.tightBoxMax[1]=Math.max(e.tightBoxMax[1],i),e.tightBoxMax[2]=Math.max(e.tightBoxMax[2],s)}return{buffer:n,attribute:t}}(e,n);case t.COLOR_PACKED:return function(t,e){const n=new ArrayBuffer(3*e.numPoints),r=new Uint8Array(n);for(let t=0;t<e.numPoints;t++)r[3*t+0]=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+0),r[3*t+1]=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+1),r[3*t+2]=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+2);return{buffer:n,attribute:t}}(e,n);case t.INTENSITY:return function(t,e){const n=new ArrayBuffer(4*e.numPoints),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++)r[t]=e.data.getUint16(e.currentOffset+t*e.pointAttributes.byteSize);return{buffer:n,attribute:t}}(e,n);case t.CLASSIFICATION:return function(t,e){const n=new ArrayBuffer(e.numPoints),r=new Uint8Array(n);for(let t=0;t<e.numPoints;t++)r[t]=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize);return{buffer:n,attribute:t}}(e,n);case t.NORMAL_SPHEREMAPPED:return function(t,e){const n=new ArrayBuffer(4*e.numPoints*3),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++){let n=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+0)/255*2-1,i=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+1)/255*2-1,s=1;const a=n*-n+i*-i+1*s;s=a,n*=Math.sqrt(a),i*=Math.sqrt(a),n*=2,i*=2,s=2*s-1,r[3*t+0]=n,r[3*t+1]=i,r[3*t+2]=s}return{buffer:n,attribute:t}}(e,n);case t.NORMAL_OCT16:return function(t,e){const n=new ArrayBuffer(4*e.numPoints*3),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++){const n=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+0)/255*2-1,i=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+1)/255*2-1;let s=1-Math.abs(n)-Math.abs(i),a=0,o=0;s>=0?(a=n,o=i):(a=-(i/f(i)-1)/f(n),o=-(n/f(n)-1)/f(i));const u=Math.sqrt(a*a+o*o+s*s);a/=u,o/=u,s/=u,r[3*t+0]=a,r[3*t+1]=o,r[3*t+2]=s}return{buffer:n,attribute:t}}(e,n);case t.NORMAL:return function(t,e){const n=new ArrayBuffer(4*e.numPoints*3),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++){const n=e.data.getFloat32(e.currentOffset+t*e.pointAttributes.byteSize+0),i=e.data.getFloat32(e.currentOffset+t*e.pointAttributes.byteSize+4),s=e.data.getFloat32(e.currentOffset+t*e.pointAttributes.byteSize+8);r[3*t+0]=n,r[3*t+1]=i,r[3*t+2]=s}return{buffer:n,attribute:t}}(e,n);default:return}}(e,n);void 0!==r&&(n.attributeBuffers[r.attribute.name]=r,n.transferables.push(r.buffer))}onmessage=function(e){const n=e.data.buffer,r=e.data.pointAttributes,i={attributeBuffers:{},currentOffset:0,data:new u(n),mean:[0,0,0],nodeOffset:e.data.offset,numPoints:e.data.buffer.byteLength/r.byteSize,pointAttributes:r,scale:e.data.scale,tightBoxMax:[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY],tightBoxMin:[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],transferables:[],version:new o(e.data.version)};for(const t of i.pointAttributes.attributes)A(t,i),i.currentOffset+=t.byteSize;const s=new ArrayBuffer(4*i.numPoints),f=new Uint32Array(s);for(let t=0;t<i.numPoints;t++)f[t]=t;i.attributeBuffers[t.CLASSIFICATION]||function(e){const n=new ArrayBuffer(4*e.numPoints),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++)r[t]=0;e.attributeBuffers[t.CLASSIFICATION]={buffer:n,attribute:a.CLASSIFICATION}}(i);const O={buffer:n,mean:i.mean,attributeBuffers:i.attributeBuffers,tightBoundingBox:{min:i.tightBoxMin,max:i.tightBoxMax},indices:s};postMessage(O,i.transferables)}})();\\n\", \"Worker\", undefined, undefined);\n}\n","\nimport worker from \"!!../../node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";const r={DATA_TYPE_DOUBLE:{ordinal:0,name:\\\"double\\\",size:8},DATA_TYPE_FLOAT:{ordinal:1,name:\\\"float\\\",size:4},DATA_TYPE_INT8:{ordinal:2,name:\\\"int8\\\",size:1},DATA_TYPE_UINT8:{ordinal:3,name:\\\"uint8\\\",size:1},DATA_TYPE_INT16:{ordinal:4,name:\\\"int16\\\",size:2},DATA_TYPE_UINT16:{ordinal:5,name:\\\"uint16\\\",size:2},DATA_TYPE_INT32:{ordinal:6,name:\\\"int32\\\",size:4},DATA_TYPE_UINT32:{ordinal:7,name:\\\"uint32\\\",size:4},DATA_TYPE_INT64:{ordinal:8,name:\\\"int64\\\",size:8},DATA_TYPE_UINT64:{ordinal:9,name:\\\"uint64\\\",size:8}};let t=0;for(const e in r)r[t]=r[e],t++;class e{constructor(r,t,e,n=[1/0,-1/0],a=void 0){this.name=r,this.type=t,this.numElements=e,this.range=n,this.uri=a,this.byteSize=this.numElements*this.type.size,this.description=\\\"\\\"}}function n(r){throw new TypeError('\\\"'+r+'\\\" is read-only')}function a(r,t){var e=\\\"undefined\\\"!=typeof Symbol&&r[Symbol.iterator]||r[\\\"@@iterator\\\"];if(!e){if(Array.isArray(r)||(e=function(r,t){if(r){if(\\\"string\\\"==typeof r)return i(r,t);var e={}.toString.call(r).slice(8,-1);return\\\"Object\\\"===e&&r.constructor&&(e=r.constructor.name),\\\"Map\\\"===e||\\\"Set\\\"===e?Array.from(r):\\\"Arguments\\\"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?i(r,t):void 0}}(r))||t&&r&&\\\"number\\\"==typeof r.length){e&&(r=e);var n=0,a=function(){};return{s:a,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:a}}throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\")}var o,f=!0,A=!1;return{s:function(){e=e.call(r)},n:function(){var r=e.next();return f=r.done,r},e:function(r){A=!0,o=r},f:function(){try{f||null==e.return||e.return()}finally{if(A)throw o}}}}function i(r,t){(null==t||t>r.length)&&(t=r.length);for(var e=0,n=Array(t);e<t;e++)n[e]=r[e];return n}new e(\\\"POSITION_CARTESIAN\\\",r.DATA_TYPE_FLOAT,3),new e(\\\"COLOR_PACKED\\\",r.DATA_TYPE_INT8,4),new e(\\\"COLOR_PACKED\\\",r.DATA_TYPE_INT8,4),new e(\\\"COLOR_PACKED\\\",r.DATA_TYPE_INT8,3),new e(\\\"NORMAL_FLOATS\\\",r.DATA_TYPE_FLOAT,3),new e(\\\"INTENSITY\\\",r.DATA_TYPE_UINT16,1),new e(\\\"CLASSIFICATION\\\",r.DATA_TYPE_UINT8,1),new e(\\\"NORMAL_SPHEREMAPPED\\\",r.DATA_TYPE_UINT8,2),new e(\\\"NORMAL_OCT16\\\",r.DATA_TYPE_UINT8,2),new e(\\\"NORMAL\\\",r.DATA_TYPE_FLOAT,3),new e(\\\"RETURN_NUMBER\\\",r.DATA_TYPE_UINT8,1),new e(\\\"NUMBER_OF_RETURNS\\\",r.DATA_TYPE_UINT8,1),new e(\\\"SOURCE_ID\\\",r.DATA_TYPE_UINT16,1),new e(\\\"INDICES\\\",r.DATA_TYPE_UINT32,1),new e(\\\"SPACING\\\",r.DATA_TYPE_FLOAT,1),new e(\\\"GPS_TIME\\\",r.DATA_TYPE_DOUBLE,1),Int8Array,Int16Array,Int32Array,Float64Array,Uint8Array,Uint16Array,Uint32Array,Float64Array,Float32Array,Float64Array,onmessage=function(t){var i,o,f,A=t.data,_=A.buffer,u=A.pointAttributes,s=(A.scale,A.name,A.min),l=(A.max,A.size),T=A.offset,I=A.numPoints,y=A.harmonicsEnabled,b=new DataView(_),h={},w=32,N=new Uint32Array(Math.pow(w,3)),E=function(r,t,e){var n=w*r/l.x,a=w*t/l.y,i=w*e/l.z,o=Math.min(parseInt(n),31),f=Math.min(parseInt(a),31),A=Math.min(parseInt(i),31);return o+f*w+A*w*w},m=function(r,t,e){return Math.max(Math.min(r,e),t)},c=0,d=[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],v=[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY],O=new ArrayBuffer(4*I*4),p=new Float32Array(O),P=new ArrayBuffer(4*I*4),M=new Float32Array(P),D=new ArrayBuffer(4*I*3),U=new Float32Array(D),F=new ArrayBuffer(4*I*4),S=new Float32Array(F),Y=new ArrayBuffer(4*I*4),C=new Float32Array(Y),x=new ArrayBuffer(45*I*4),R=new Float32Array(x),z=(i=new Float32Array(1),o=new Int32Array(i.buffer),function(r){return i[0]=r,o[0]}),g=[\\\"sh_band_1_triplet_0\\\",\\\"sh_band_1_triplet_1\\\",\\\"sh_band_1_triplet_2\\\",\\\"sh_band_2_triplet_0\\\",\\\"sh_band_2_triplet_1\\\",\\\"sh_band_2_triplet_2\\\",\\\"sh_band_2_triplet_3\\\",\\\"sh_band_2_triplet_4\\\",\\\"sh_band_3_triplet_0\\\",\\\"sh_band_3_triplet_1\\\",\\\"sh_band_3_triplet_2\\\",\\\"sh_band_3_triplet_3\\\",\\\"sh_band_3_triplet_4\\\",\\\"sh_band_3_triplet_5\\\",\\\"sh_band_3_triplet_6\\\"],B=a(u.attributes);try{for(B.s();!(f=B.n()).done;){var L=f.value;if([\\\"POSITION_CARTESIAN\\\",\\\"position\\\"].includes(L.name)){for(var V=T[0]-s.x,H=T[1]-s.y,G=T[2]-s.z,k=0;k<I;k++){var K=12*k,j=b.getFloat32(K+0,!0),q=b.getFloat32(K+4,!0),Q=b.getFloat32(K+8,!0),$=j+V,J=q+H,W=Q+G;d[0]=Math.min(d[0],$),d[1]=Math.min(d[1],J),d[2]=Math.min(d[2],W),v[0]=Math.max(v[0],$),v[1]=Math.max(v[1],J),v[2]=Math.max(v[2],W),0===N[E($,J,W)]++&&c++,p[4*k+0]=$,p[4*k+1]=J,p[4*k+2]=W,M[4*k+0]=j,M[4*k+1]=q,M[4*k+2]=Q}h.raw_position={buffer:P,attribute:\\\"raw_position\\\"},h.position={buffer:O,attribute:\\\"position\\\"}}else if([\\\"sh_band_0\\\"].includes(L.name))for(var X=.28209479177387814,Z=12*I,rr=15*I,tr=0;tr<I;tr++){var er=4*tr+0,nr=4*tr+1,ar=4*tr+2,ir=4*tr+3,or=3*tr+Z,fr=1*tr+rr,Ar=(b.getUint8(or+0,!0)/255-.5)/.15,_r=(b.getUint8(or+1,!0)/255-.5)/.15,ur=(b.getUint8(or+2,!0)/255-.5)/.15;C[er]=255*(.5+X*Ar),C[nr]=255*(.5+X*_r),C[ar]=255*(.5+X*ur),C[er]=m(Math.floor(C[er]),0,255),C[nr]=m(Math.floor(C[nr]),0,255),C[ar]=m(Math.floor(C[ar]),0,255);var sr=b.getUint8(fr,!0)/255;sr=1/(1+Math.exp(-sr))*255,sr=m(Math.floor(sr),0,255),C[ir]=sr}else if([\\\"scale\\\"].includes(L.name)){for(var lr=16*I,Tr=0;Tr<I;Tr++){var Ir=8*Tr+lr,yr=b.getFloat32(Ir+0,!0),br=b.getFloat32(Ir+4,!0);U[3*Tr+0]=Math.exp(yr),U[3*Tr+1]=Math.exp(br),U[3*Tr+2]=0}h.scale={buffer:D,attribute:\\\"scale\\\"}}else if([\\\"rotation\\\"].includes(L.name)){for(var hr=24*I,wr=function(){var r=4*Nr+hr,t=b.getUint32(r,!0),e=function(r){return(1-2*(t>>r+9&1))*(t>>r&511)/(511*Math.SQRT2)},n=t>>30&3,a=e(20),i=e(10),o=e(0),f=Math.sqrt(1-a*a-i*i-o*o),A=0,_=0,u=0,s=1;switch(n){case 0:A=f,_=a,u=i,s=o;break;case 1:A=a,_=f,u=i,s=o;break;case 2:A=a,_=i,u=f,s=o;break;case 3:A=a,_=i,u=o,s=f}S[4*Nr+0]=A,S[4*Nr+1]=_,S[4*Nr+2]=u,S[4*Nr+3]=s},Nr=0;Nr<I;Nr++)wr();h.orientation={buffer:F,attribute:\\\"orientation\\\"}}else if(L.name.indexOf(\\\"triplet\\\")>-1&&y)for(var Er=g.indexOf(L.name),mr=I*(28+3*Er),cr=0;cr<I;cr++){var dr=3*cr+mr,vr=(b.getUint8(dr+0,!0)-128)/128,Or=(b.getUint8(dr+1,!0)-128)/128,pr=(b.getUint8(dr+2,!0)-128)/128;R[45*cr+3*Er+0]=vr,R[45*cr+3*Er+1]=Or,R[45*cr+3*Er+2]=pr}}}catch(r){B.e(r)}finally{B.f()}for(var Pr=function(r,t,e){var n=function(r,t){var e=new Array(16),n=r.x,a=r.y,i=r.z,o=r.w,f=n+n,A=a+a,_=i+i,u=n*f,s=n*A,l=n*_,T=a*A,I=a*_,y=i*_,b=o*f,h=o*A,w=o*_,N=t.x,E=t.y;e[0]=(1-(T+y))*N,e[1]=(s+w)*N,e[2]=(l-h)*N,e[3]=(s-w)*E,e[4]=(1-(u+y))*E,e[5]=(I+b)*E,e[6]=0,e[7]=0,e[8]=0;var m,c,d,v,O,p,P,M,D,U,F,S,Y,C,x,R,z,g,B,L,V,H,G=e.map(function(r){return r}),k=G;return m=k[1],k[1]=k[3],k[3]=m,m=k[2],k[2]=k[6],k[6]=m,m=k[5],k[5]=k[7],k[7]=m,c=e,d=G,v=new Array(9),O=c[0],p=c[3],P=c[6],M=c[1],D=c[4],U=c[7],F=c[2],S=c[5],Y=c[8],C=d[0],x=d[3],R=d[6],z=d[1],g=d[4],B=d[7],L=d[2],V=d[5],H=d[8],v[0]=O*C+p*z+P*L,v[3]=O*x+p*g+P*V,v[6]=O*R+p*B+P*H,v[1]=M*C+D*z+U*L,v[4]=M*x+D*g+U*V,v[7]=M*R+D*B+U*H,v[2]=F*C+S*z+Y*L,v[5]=F*x+S*g+Y*V,v[8]=F*R+S*B+Y*H,v}(t,r);Dr[4*e+0]=n[0],Dr[4*e+1]=n[3],Dr[4*e+2]=n[6],Dr[4*e+3]=n[4],Fr[2*e+0]=n[7],Fr[2*e+1]=n[8]},Mr=new ArrayBuffer(4*I*4),Dr=new Float32Array(Mr),Ur=new ArrayBuffer(4*I*2),Fr=new Float32Array(Ur),Sr=0;Sr<I;Sr++){var Yr={x:0,y:0,z:0,w:0},Cr={x:0,y:0,z:0};Yr.w=S[4*Sr+0],Yr.x=S[4*Sr+1],Yr.y=S[4*Sr+2],Yr.z=S[4*Sr+3],Cr.x=U[3*Sr+0],Cr.y=U[3*Sr+1],Cr.z=U[3*Sr+2],Pr(Cr,Yr,Sr)}h.COVARIANCE0={buffer:Mr,attribute:e.COVARIANCE0},h.COVARIANCE1={buffer:Ur,attribute:e.COVARIANCE1};for(var xr=function(r){return r[0]+(r[1]<<8)+(r[2]<<16)+(r[3]<<24)},Rr=new ArrayBuffer(4*I*4),zr=new Int32Array(Rr),gr=0;gr<I;gr++){var Br={x:0,y:0,z:0,w:0},Lr={x:0,y:0,z:0};Br.x=C[4*gr+0],Br.y=C[4*gr+1],Br.z=C[4*gr+2],Br.w=C[4*gr+3],Lr.x=M[4*gr+0],Lr.y=M[4*gr+1],Lr.z=M[4*gr+2];var Vr=xr([Br.x,Br.y,Br.z,Br.w]);Lr.x=z(Lr.x),Lr.y=z(Lr.y),Lr.z=z(Lr.z),zr[4*gr+0]=Vr,zr[4*gr+1]=Lr.x,zr[4*gr+2]=Lr.y,zr[4*gr+3]=Lr.z}h.POS_COLOR={buffer:Rr,attribute:e.POS_COLOR};var Hr=new ArrayBuffer(4*I*3),Gr=new Uint32Array(Hr),kr=new ArrayBuffer(4*I*5),Kr=new Uint32Array(kr),jr=new ArrayBuffer(4*I*7),qr=new Uint32Array(jr);R=R.map(function(r,t){r=.5*(r=Math.min(Math.max(r,-1),1))+.5;var e=t%3==1?1023:2047;return Math.min(Math.max(Math.floor(r*e),0),e)});for(var Qr=0;Qr<I;Qr++)for(var $r=0;$r<15;$r++){var Jr=R[45*Qr+3*$r+0],Wr=R[45*Qr+3*$r+1],Xr=R[45*Qr+3*$r+2];$r<3&&(Gr[3*Qr+$r-0]=Jr<<21|Wr<<11|Xr),$r>=3&&$r<8&&(Kr[5*Qr+$r-3]=Jr<<21|Wr<<11|Xr),$r>=8&&(qr[7*Qr+$r-8]=Jr<<21|Wr<<11|Xr)}h.HARMONICS1={buffer:Hr,attribute:\\\"HARMONICS1\\\"},h.HARMONICS2={buffer:kr,attribute:\\\"HARMONICS2\\\"},h.HARMONICS3={buffer:jr,attribute:\\\"HARMONICS3\\\"};for(var Zr=parseInt(I/c),rt=new ArrayBuffer(4*I),tt=new Uint32Array(rt),et=0;et<I;et++)tt[et]=et;h.INDICES={buffer:rt,attribute:e.INDICES};var nt,at=a(u.vectors);try{for(at.s();!(nt=at.n()).done;){var it,ot=nt.value,ft=ot.name,At=ot.attributes,_t=At.length,ut=new ArrayBuffer(_t*I*4),st=new Float32Array(ut),lt=a(At);try{for(lt.s();!(it=lt.n()).done;){for(var Tt=h[it.value],It=Tt.offset,yt=Tt.scale,bt=new DataView(Tt.buffer),ht=bt.getFloat32.bind(bt),wt=0;wt<I;wt++){var Nt=ht(4*wt,!0);st[wt*_t+0]=Nt/yt+It}n(\\\"iElement\\\")}}catch(r){lt.e(r)}finally{lt.f()}var Et=new e(ft,r.DATA_TYPE_FLOAT,3);h[ft]={buffer:ut,attribute:Et}}}catch(r){at.e(r)}finally{at.f()}var mt={buffer:_,attributeBuffers:h,density:Zr,tightBoundingBox:{min:d,max:v}},ct=[];for(var dt in mt.attributeBuffers)ct.push(mt.attributeBuffers[dt].buffer);ct.push(_),postMessage(mt,ct)}})();\\n\", \"Worker\", undefined, undefined);\n}\n","export default \"precision highp float;\\nprecision highp int;\\n\\nuniform mat4 viewMatrix;\\nuniform vec3 cameraPosition;\\n\\nuniform mat4 projectionMatrix;\\nuniform float opacity;\\n\\nuniform float blendHardness;\\nuniform float blendDepthSupplement;\\nuniform float fov;\\nuniform float spacing;\\nuniform float pcIndex;\\nuniform float screenWidth;\\nuniform float screenHeight;\\n\\nuniform sampler2D depthMap;\\n\\n#if defined (clip_horizontally) || defined (clip_vertically)\\n\\tuniform vec4 clipExtent;\\n#endif\\n\\n#ifdef use_texture_blending\\n\\tuniform sampler2D backgroundMap;\\n#endif\\n\\n\\n#ifdef use_point_cloud_mixing\\n\\tuniform int pointCloudMixingMode;\\n\\tuniform float pointCloudID;\\n\\tuniform float pointCloudMixAngle;\\n\\tuniform float stripeDistanceX;\\n\\tuniform float stripeDistanceY;\\n\\n\\tuniform float stripeDivisorX;\\n\\tuniform float stripeDivisorY;\\n#endif\\n\\n#ifdef highlight_point\\n\\tuniform vec4 highlightedPointColor;\\n#endif\\n\\nin vec3 vColor;\\n\\n#if !defined(color_type_point_index)\\n\\tin float vOpacity;\\n#endif\\n\\n#if defined(weighted_splats)\\n\\tin float vLinearDepth;\\n#endif\\n\\n#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\tin float vLogDepth;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\tin vec3 vViewPosition;\\n#endif\\n\\n#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\tin float vRadius;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\tin vec3 vNormal;\\n#endif\\n\\n#ifdef highlight_point\\n\\tin float vHighlight;\\n#endif\\n\\nout vec4 outFragColor;\\n\\nfloat specularStrength = 1.0;\\n\\nvoid main() {\\n\\tvec3 color = vColor;\\n\\tfloat depth = gl_FragCoord.z;\\n\\n\\t#if defined (clip_horizontally) || defined (clip_vertically)\\n\\tvec2 ndc = vec2((gl_FragCoord.x / screenWidth), 1.0 - (gl_FragCoord.y / screenHeight));\\n\\n\\tif(step(clipExtent.x, ndc.x) * step(ndc.x, clipExtent.z) < 1.0)\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\n\\tif(step(clipExtent.y, ndc.y) * step(ndc.y, clipExtent.w) < 1.0)\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\t#endif  \\n\\n\\t#if defined(circle_point_shape) || defined(paraboloid_point_shape) || defined (weighted_splats)\\n\\t\\tfloat u = 2.0 * gl_PointCoord.x - 1.0;\\n\\t\\tfloat v = 2.0 * gl_PointCoord.y - 1.0;\\n\\t#endif\\n\\n\\t#if defined(circle_point_shape) || defined (weighted_splats)\\n\\t\\tfloat cc = u*u + v*v;\\n\\t\\tif(cc > 1.0){\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t\\tvec2 uv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);\\n\\t\\tfloat sDepth = texture(depthMap, uv).r;\\n\\t\\tif(vLinearDepth > sDepth + vRadius + blendDepthSupplement){\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#if defined color_type_point_index\\n\\t\\toutFragColor = vec4(color, pcIndex / 255.0);\\n\\t#else\\n\\t\\toutFragColor = vec4(color, vOpacity);\\n\\t#endif\\n\\n\\t#ifdef use_point_cloud_mixing\\n\\t\\tbool discardFragment = false;\\n\\n\\t\\tif (pointCloudMixingMode == 1) {  // Checkboard\\n\\t\\t\\tfloat vPointCloudID = pointCloudID > 10. ? pointCloudID/10.: pointCloudID;\\n\\t\\t\\tdiscardFragment = mod(gl_FragCoord.x, vPointCloudID) > 0.5 && mod(gl_FragCoord.y, vPointCloudID) > 0.5;\\n\\t\\t}\\n\\t\\telse if (pointCloudMixingMode == 2) {  // Stripes\\n\\t\\t\\tfloat angle = pointCloudMixAngle * pointCloudID / 180.;\\n\\t\\t\\tfloat u = cos(angle) * gl_FragCoord.x + sin(angle) * gl_FragCoord.y;\\n\\t\\t\\tfloat v = -sin(angle) * gl_FragCoord.x + cos(angle) * gl_FragCoord.y;\\n\\n\\t\\t\\tdiscardFragment = mod(u, stripeDistanceX) >= stripeDistanceX/stripeDivisorX && mod(v, stripeDistanceY) >= stripeDistanceY/stripeDivisorY;\\n\\t\\t}\\n\\t\\tif (discardFragment) {\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#ifdef use_texture_blending\\n\\t\\tvec2 vUv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);\\n\\n\\t\\tvec4 tColor = texture(backgroundMap, vUv);\\n\\t\\toutFragColor = vec4(vOpacity * color, 1.) + vec4((1. - vOpacity) * tColor.rgb, 0.);\\n\\t#endif\\n\\n\\t#if defined(color_type_phong)\\n\\t\\t#if MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0\\n\\t\\t\\tvec3 normal = normalize( vNormal );\\n\\t\\t\\tnormal.z = abs(normal.z);\\n\\n\\t\\t\\tvec3 viewPosition = normalize( vViewPosition );\\n\\t\\t#endif\\n\\n\\t\\t// code taken from three.js phong light fragment shader\\n\\n\\t\\t#if MAX_POINT_LIGHTS > 0\\n\\n\\t\\t\\tvec3 pointDiffuse = vec3( 0.0 );\\n\\t\\t\\tvec3 pointSpecular = vec3( 0.0 );\\n\\n\\t\\t\\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\t\\t\\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\\t\\t\\t\\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\\t\\t\\t\\tfloat lDistance = 1.0;\\n\\t\\t\\t\\tif ( pointLightDistance[ i ] > 0.0 )\\n\\t\\t\\t\\t\\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\n\\n\\t\\t\\t\\tlVector = normalize( lVector );\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\tfloat dotProduct = dot( normal, lVector );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t\\t#else\\n\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\tpointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\n\\t\\t\\t\\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n\\t\\t\\t\\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\t\\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\\n\\t\\t\\t\\tpointSpecular = vec3(0.0, 0.0, 0.0);\\n\\t\\t\\t}\\n\\n\\t\\t#endif\\n\\n\\t\\t#if MAX_DIR_LIGHTS > 0\\n\\n\\t\\t\\tvec3 dirDiffuse = vec3( 0.0 );\\n\\t\\t\\tvec3 dirSpecular = vec3( 0.0 );\\n\\n\\t\\t\\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\t\\t\\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\n\\t\\t\\t\\tvec3 dirVector = normalize( lDirection.xyz );\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\tfloat dotProduct = dot( normal, dirVector );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t\\t#else\\n\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\tdirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\n\\t\\t\\t\\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n\\t\\t\\t\\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\t\\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\t\\t\\t}\\n\\n\\t\\t#endif\\n\\n\\t\\tvec3 totalDiffuse = vec3( 0.0 );\\n\\t\\tvec3 totalSpecular = vec3( 0.0 );\\n\\n\\t\\t#if MAX_POINT_LIGHTS > 0\\n\\n\\t\\t\\ttotalDiffuse += pointDiffuse;\\n\\t\\t\\ttotalSpecular += pointSpecular;\\n\\n\\t\\t#endif\\n\\n\\t\\t#if MAX_DIR_LIGHTS > 0\\n\\n\\t\\t\\ttotalDiffuse += dirDiffuse;\\n\\t\\t\\ttotalSpecular += dirSpecular;\\n\\n\\t\\t#endif\\n\\n\\t\\toutFragColor.xyz = outFragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t    //float w = pow(1.0 - (u*u + v*v), blendHardness);\\n\\n\\t\\tfloat wx = 2.0 * length(2.0 * gl_PointCoord - 1.0);\\n\\t\\tfloat w = exp(-wx * wx * 0.5);\\n\\n\\t\\t//float distance = length(2.0 * gl_PointCoord - 1.0);\\n\\t\\t//float w = exp( -(distance * distance) / blendHardness);\\n\\n\\t\\toutFragColor.rgb = outFragColor.rgb * w;\\n\\t\\toutFragColor.a = w;\\n\\t#endif\\n\\n\\t#if defined paraboloid_point_shape\\n\\t\\tfloat wi = 0.0 - ( u*u + v*v);\\n\\t\\tvec4 pos = vec4(vViewPosition, 1.0);\\n\\t\\tpos.z += wi * vRadius;\\n\\t\\tfloat linearDepth = -pos.z;\\n\\t\\tpos = projectionMatrix * pos;\\n\\t\\tpos = pos / pos.w;\\n\\t\\tfloat expDepth = pos.z;\\n\\t\\tdepth = (pos.z + 1.0) / 2.0;\\n\\t\\tgl_FragDepth = depth;\\n\\n\\t\\t#if defined(color_type_depth)\\n\\t\\t\\toutFragColor.r = linearDepth;\\n\\t\\t\\toutFragColor.g = expDepth;\\n\\t\\t#endif\\n\\n\\t\\t#if defined(use_edl)\\n\\t\\t\\toutFragColor.a = log2(linearDepth);\\n\\t\\t#endif\\n\\n\\t#else\\n\\t\\t#if defined(use_edl)\\n\\t\\t\\toutFragColor.a = vLogDepth;\\n\\t\\t#endif\\n\\t#endif\\n\\n\\t#ifdef highlight_point\\n\\t\\tif (vHighlight > 0.0) {\\n\\t\\t\\toutFragColor = highlightedPointColor;\\n\\t\\t}\\n\\t#endif\\n}\\n\";","\nimport worker from \"!!../../node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";const e={DATA_TYPE_DOUBLE:{ordinal:0,name:\\\"double\\\",size:8},DATA_TYPE_FLOAT:{ordinal:1,name:\\\"float\\\",size:4},DATA_TYPE_INT8:{ordinal:2,name:\\\"int8\\\",size:1},DATA_TYPE_UINT8:{ordinal:3,name:\\\"uint8\\\",size:1},DATA_TYPE_INT16:{ordinal:4,name:\\\"int16\\\",size:2},DATA_TYPE_UINT16:{ordinal:5,name:\\\"uint16\\\",size:2},DATA_TYPE_INT32:{ordinal:6,name:\\\"int32\\\",size:4},DATA_TYPE_UINT32:{ordinal:7,name:\\\"uint32\\\",size:4},DATA_TYPE_INT64:{ordinal:8,name:\\\"int64\\\",size:8},DATA_TYPE_UINT64:{ordinal:9,name:\\\"uint64\\\",size:8}};let t=0;for(const n in e)e[t]=e[n],t++;class n{constructor(e,t,n,r=[1/0,-1/0],a=void 0){this.name=e,this.type=t,this.numElements=n,this.range=r,this.uri=a,this.byteSize=this.numElements*this.type.size,this.description=\\\"\\\"}}function r(e,t){var n=\\\"undefined\\\"!=typeof Symbol&&e[Symbol.iterator]||e[\\\"@@iterator\\\"];if(!n){if(Array.isArray(e)||(n=function(e,t){if(e){if(\\\"string\\\"==typeof e)return a(e,t);var n={}.toString.call(e).slice(8,-1);return\\\"Object\\\"===n&&e.constructor&&(n=e.constructor.name),\\\"Map\\\"===n||\\\"Set\\\"===n?Array.from(e):\\\"Arguments\\\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?a(e,t):void 0}}(e))||t&&e&&\\\"number\\\"==typeof e.length){n&&(e=n);var r=0,i=function(){};return{s:i,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:i}}throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\")}var A,T=!0,o=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return T=e.done,e},e:function(e){o=!0,A=e},f:function(){try{T||null==n.return||n.return()}finally{if(o)throw A}}}}function a(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=Array(t);n<t;n++)r[n]=e[n];return r}new n(\\\"POSITION_CARTESIAN\\\",e.DATA_TYPE_FLOAT,3),new n(\\\"COLOR_PACKED\\\",e.DATA_TYPE_INT8,4),new n(\\\"COLOR_PACKED\\\",e.DATA_TYPE_INT8,4),new n(\\\"COLOR_PACKED\\\",e.DATA_TYPE_INT8,3),new n(\\\"NORMAL_FLOATS\\\",e.DATA_TYPE_FLOAT,3),new n(\\\"INTENSITY\\\",e.DATA_TYPE_UINT16,1),new n(\\\"CLASSIFICATION\\\",e.DATA_TYPE_UINT8,1),new n(\\\"NORMAL_SPHEREMAPPED\\\",e.DATA_TYPE_UINT8,2),new n(\\\"NORMAL_OCT16\\\",e.DATA_TYPE_UINT8,2),new n(\\\"NORMAL\\\",e.DATA_TYPE_FLOAT,3),new n(\\\"RETURN_NUMBER\\\",e.DATA_TYPE_UINT8,1),new n(\\\"NUMBER_OF_RETURNS\\\",e.DATA_TYPE_UINT8,1),new n(\\\"SOURCE_ID\\\",e.DATA_TYPE_UINT16,1),new n(\\\"INDICES\\\",e.DATA_TYPE_UINT32,1),new n(\\\"SPACING\\\",e.DATA_TYPE_FLOAT,1),new n(\\\"GPS_TIME\\\",e.DATA_TYPE_DOUBLE,1),Int8Array,Int16Array,Int32Array,Float64Array,Uint8Array,Uint16Array,Uint32Array,Float64Array,Float32Array,Float64Array,onmessage=function(t){var a,i=t.data,A=i.buffer,T=i.pointAttributes,o=(i.scale,i.name,i.min),u=(i.max,i.size),I=i.offset,s=i.numPoints,f=new DataView(A),_={},l=32,E=new Uint32Array(Math.pow(l,3)),N=function(e,t,n){var r=l*e/u.x,a=l*t/u.y,i=l*n/u.z,A=Math.min(parseInt(r),31),T=Math.min(parseInt(a),31),o=Math.min(parseInt(i),31);return A+T*l+o*l*l},m=0,y=[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],c=[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY],P=r(T.attributes);try{for(P.s();!(a=P.n()).done;){var D=a.value;if([\\\"POSITION_CARTESIAN\\\",\\\"position\\\"].includes(D.name)){for(var b=new ArrayBuffer(4*s*3),h=new Float32Array(b),Y=0;Y<s;Y++){var w=12*Y,d=f.getFloat32(w+0,!0)+I[0]-o.x,O=f.getFloat32(w+4,!0)+I[1]-o.y,v=f.getFloat32(w+8,!0)+I[2]-o.z;y[0]=Math.min(y[0],d),y[1]=Math.min(y[1],O),y[2]=Math.min(y[2],v),c[0]=Math.max(c[0],d),c[1]=Math.max(c[1],O),c[2]=Math.max(c[2],v),0===E[N(d,O,v)]++&&m++,h[3*Y+0]=d,h[3*Y+1]=O,h[3*Y+2]=v}_[D.name]={buffer:b,attribute:D}}else[\\\"RGBA\\\",\\\"rgba\\\"].includes(D.name)&&(_[D.name]={buffer:A.slice(12*s),attribute:D})}}catch(e){P.e(e)}finally{P.f()}for(var F=parseInt(s/m),S=new ArrayBuffer(4*s),U=new Uint32Array(S),p=0;p<s;p++)U[p]=p;_.INDICES={buffer:S,attribute:n.INDICES};var M,g=r(T.vectors);try{for(g.s();!(M=g.n()).done;){var R,C=M.value,L=C.name,z=C.attributes,B=z.length,x=new ArrayBuffer(B*s*4),V=new Float32Array(x),G=0,K=r(z);try{for(K.s();!(R=K.n()).done;){for(var j=_[R.value],H=j.offset,$=j.scale,k=new DataView(j.buffer),q=k.getFloat32.bind(k),J=0;J<s;J++){var Q=q(4*J,!0);V[J*B+G]=Q/$+H}G++}}catch(e){K.e(e)}finally{K.f()}var W=new n(L,e.DATA_TYPE_FLOAT,3);_[L]={buffer:x,attribute:W}}}catch(e){g.e(e)}finally{g.f()}var X={buffer:A,attributeBuffers:_,density:F,tightBoundingBox:{min:y,max:c}},Z=[];for(var ee in X.attributeBuffers)Z.push(X.attributeBuffers[ee].buffer);Z.push(A),postMessage(X,Z)}})();\\n\", \"Worker\", undefined, undefined);\n}\n","export default \"precision highp float;\\nprecision highp int;\\n\\n#define max_clip_boxes 30\\n\\nin vec3 position;\\nin vec3 color;\\n\\n#ifdef color_rgba\\n\\tin vec4 rgba;\\n#endif\\n\\nin vec3 normal;\\nin float intensity;\\nin float classification;\\nin float returnNumber;\\nin float numberOfReturns;\\nin float pointSourceID;\\nin vec4 indices;\\nin vec2 uv;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\n\\nuniform float pcIndex;\\n\\nuniform float screenWidth;\\nuniform float screenHeight;\\nuniform float fov;\\nuniform float spacing;\\n\\n#if defined use_clip_box\\n\\tuniform mat4 clipBoxes[max_clip_boxes];\\n#endif\\n\\nuniform float heightMin;\\nuniform float heightMax;\\nuniform float size; // pixel size factor\\nuniform float minSize; // minimum pixel size\\nuniform float maxSize; // maximum pixel size\\nuniform float octreeSize;\\nuniform vec3 bbSize;\\nuniform vec3 uColor;\\nuniform float opacity;\\nuniform float clipBoxCount;\\nuniform float level;\\nuniform float vnStart;\\nuniform bool isLeafNode;\\n\\nuniform float filterByNormalThreshold;\\nuniform vec2 intensityRange;\\nuniform float opacityAttenuation;\\nuniform float intensityGamma;\\nuniform float intensityContrast;\\nuniform float intensityBrightness;\\nuniform float rgbGamma;\\nuniform float rgbContrast;\\nuniform float rgbBrightness;\\nuniform float transition;\\nuniform float wRGB;\\nuniform float wIntensity;\\nuniform float wElevation;\\nuniform float wClassification;\\nuniform float wReturnNumber;\\nuniform float wSourceID;\\n\\nuniform bool renderDepth;\\n\\nuniform sampler2D visibleNodes;\\nuniform sampler2D gradient;\\nuniform sampler2D classificationLUT;\\nuniform sampler2D depthMap;\\n\\n#ifdef use_texture_blending\\n\\tuniform sampler2D backgroundMap;\\n#endif\\n\\n#ifdef use_point_cloud_mixing\\n\\tuniform int pointCloudMixingMode;\\n\\tuniform float pointCloudID;\\n\\n\\tuniform float pointCloudMixAngle;\\n\\tuniform float stripeDistanceX;\\n\\tuniform float stripeDistanceY;\\n\\n\\tuniform float stripeDivisorX;\\n\\tuniform float stripeDivisorY;\\n#endif\\n\\n#ifdef highlight_point\\n\\tuniform vec3 highlightedPointCoordinate;\\n\\tuniform bool enablePointHighlighting;\\n\\tuniform float highlightedPointScale;\\n#endif\\n\\n#ifdef use_filter_by_normal\\n\\tuniform int normalFilteringMode;\\n#endif\\n\\nout vec3 vColor;\\n\\n#if !defined(color_type_point_index)\\n\\tout float vOpacity;\\n#endif\\n\\n#if defined(weighted_splats)\\n\\tout float vLinearDepth;\\n#endif\\n\\n#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\tout float vLogDepth;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\tout vec3 vViewPosition;\\n#endif\\n\\n#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\tout float vRadius;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\tout vec3 vNormal;\\n#endif\\n\\n#ifdef highlight_point\\n\\tout float vHighlight;\\n#endif\\n\\n// ---------------------\\n// OCTREE\\n// ---------------------\\n\\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_octree)\\n\\n/**\\n * Rounds the specified number to the closest integer.\\n */\\nfloat safeRound(float number){\\n\\treturn floor(number + 0.5);\\n}\\n\\n/**\\n * Gets the number of 1-bits up to inclusive index position.\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nint numberOfOnes(int number, int index) {\\n\\tint numOnes = 0;\\n\\tint tmp = 128;\\n\\tfor (int i = 7; i >= 0; i--) {\\n\\n\\t\\tif (number >= tmp) {\\n\\t\\t\\tnumber = number - tmp;\\n\\n\\t\\t\\tif (i <= index) {\\n\\t\\t\\t\\tnumOnes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ttmp = tmp / 2;\\n\\t}\\n\\n\\treturn numOnes;\\n}\\n\\n/**\\n * Checks whether the bit at index is 1.0\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nbool isBitSet(int number, int index){\\n\\n\\t// weird multi else if due to lack of proper array, int and bitwise support in WebGL 1.0\\n\\tint powi = 1;\\n\\tif (index == 0) {\\n\\t\\tpowi = 1;\\n\\t} else if (index == 1) {\\n\\t\\tpowi = 2;\\n\\t} else if (index == 2) {\\n\\t\\tpowi = 4;\\n\\t} else if (index == 3) {\\n\\t\\tpowi = 8;\\n\\t} else if (index == 4) {\\n\\t\\tpowi = 16;\\n\\t} else if (index == 5) {\\n\\t\\tpowi = 32;\\n\\t} else if (index == 6) {\\n\\t\\tpowi = 64;\\n\\t} else if (index == 7) {\\n\\t\\tpowi = 128;\\n\\t}\\n\\n\\tint ndp = number / powi;\\n\\n\\treturn mod(float(ndp), 2.0) != 0.0;\\n}\\n\\n/**\\n * Gets the the LOD at the point position.\\n */\\nfloat getLOD() {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tint iOffset = int(vnStart);\\n\\tfloat depth = level;\\n\\n\\tfor (float i = 0.0; i <= 30.0; i++) {\\n\\t\\tfloat nodeSizeAtLevel = octreeSize  / pow(2.0, i + level + 0.0);\\n\\n\\t\\tvec3 index3d = (position-offset) / nodeSizeAtLevel;\\n\\t\\tindex3d = floor(index3d + 0.5);\\n\\t\\tint index = int(safeRound(4.0 * index3d.x + 2.0 * index3d.y + index3d.z));\\n\\n\\t\\tvec4 value = texture(visibleNodes, vec2(float(iOffset) / 2048.0, 0.0));\\n\\t\\tint mask = int(safeRound(value.r * 255.0));\\n\\n\\t\\tif (isBitSet(mask, index)) {\\n\\t\\t\\t// there are more visible child nodes at this position\\n\\t\\t\\tint advanceG = int(safeRound(value.g * 255.0)) * 256;\\n\\t\\t\\tint advanceB = int(safeRound(value.b * 255.0));\\n\\t\\t\\tint advanceChild = numberOfOnes(mask, index - 1);\\n\\t\\t\\tint advance = advanceG + advanceB + advanceChild;\\n\\n\\t\\t\\tiOffset = iOffset + advance;\\n\\n\\t\\t\\tdepth++;\\n\\t\\t} else {\\n\\t\\t\\treturn value.a * 255.0; // no more visible child nodes at this position\\n\\t\\t}\\n\\n\\t\\toffset = offset + (vec3(1.0, 1.0, 1.0) * nodeSizeAtLevel * 0.5) * index3d;\\n\\t}\\n\\n\\treturn depth;\\n}\\n\\nfloat getPointSizeAttenuation() {\\n\\treturn 0.5 * pow(2.0, getLOD());\\n}\\n\\n#endif\\n\\n// ---------------------\\n// KD-TREE\\n// ---------------------\\n\\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_kdtree)\\n\\nfloat getLOD() {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tfloat intOffset = 0.0;\\n\\tfloat depth = 0.0;\\n\\n\\tvec3 size = bbSize;\\n\\tvec3 pos = position;\\n\\n\\tfor (float i = 0.0; i <= 1000.0; i++) {\\n\\n\\t\\tvec4 value = texture(visibleNodes, vec2(intOffset / 2048.0, 0.0));\\n\\n\\t\\tint children = int(value.r * 255.0);\\n\\t\\tfloat next = value.g * 255.0;\\n\\t\\tint split = int(value.b * 255.0);\\n\\n\\t\\tif (next == 0.0) {\\n\\t\\t \\treturn depth;\\n\\t\\t}\\n\\n\\t\\tvec3 splitv = vec3(0.0, 0.0, 0.0);\\n\\t\\tif (split == 1) {\\n\\t\\t\\tsplitv.x = 1.0;\\n\\t\\t} else if (split == 2) {\\n\\t\\t \\tsplitv.y = 1.0;\\n\\t\\t} else if (split == 4) {\\n\\t\\t \\tsplitv.z = 1.0;\\n\\t\\t}\\n\\n\\t\\tintOffset = intOffset + next;\\n\\n\\t\\tfloat factor = length(pos * splitv / size);\\n\\t\\tif (factor < 0.5) {\\n\\t\\t \\t// left\\n\\t\\t\\tif (children == 0 || children == 2) {\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// right\\n\\t\\t\\tpos = pos - size * splitv * 0.5;\\n\\t\\t\\tif (children == 0 || children == 1) {\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\t}\\n\\t\\t\\tif (children == 3) {\\n\\t\\t\\t\\tintOffset = intOffset + 1.0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsize = size * ((1.0 - (splitv + 1.0) / 2.0) + 0.5);\\n\\n\\t\\tdepth++;\\n\\t}\\n\\n\\n\\treturn depth;\\n}\\n\\nfloat getPointSizeAttenuation() {\\n\\treturn 0.5 * pow(1.3, getLOD());\\n}\\n\\n#endif\\n\\n// formula adapted from: http://www.dfstudios.co.uk/articles/programming/image-programming-algorithms/image-processing-algorithms-part-5-contrast-adjustment/\\nfloat getContrastFactor(float contrast) {\\n\\treturn (1.0158730158730156 * (contrast + 1.0)) / (1.0158730158730156 - contrast);\\n}\\n\\nvec3 getRGB() {\\n\\t\\n\\t#ifdef color_rgba\\n\\t\\tvec3 rgb = rgba.rgb;\\n\\t#else\\t\\n\\t\\tvec3 rgb = color;\\n\\t#endif\\t\\t\\n\\n\\t#if defined(use_rgb_gamma_contrast_brightness)\\n\\t\\trgb = pow(rgb, vec3(rgbGamma));\\n\\t\\trgb = rgb + rgbBrightness;\\n\\t\\trgb = (rgb - 0.5) * getContrastFactor(rgbContrast) + 0.5;\\n\\t\\trgb = clamp(rgb, 0.0, 1.0);\\n\\t\\treturn rgb;\\n\\t#else\\n\\t\\treturn rgb;\\n\\t#endif\\n}\\n\\nfloat getIntensity() {\\n\\tfloat w = (intensity - intensityRange.x) / (intensityRange.y - intensityRange.x);\\n\\tw = pow(w, intensityGamma);\\n\\tw = w + intensityBrightness;\\n\\tw = (w - 0.5) * getContrastFactor(intensityContrast) + 0.5;\\n\\tw = clamp(w, 0.0, 1.0);\\n\\n\\treturn w;\\n}\\n\\nvec3 getElevation() {\\n\\tvec4 world = modelMatrix * vec4( position, 1.0 );\\n\\tfloat w = (world.z - heightMin) / (heightMax-heightMin);\\n\\tvec3 cElevation = texture(gradient, vec2(w,1.0-w)).rgb;\\n\\n\\treturn cElevation;\\n}\\n\\nvec4 getClassification() {\\n\\tvec2 uv = vec2(classification / 255.0, 0.5);\\n\\tvec4 classColor = texture(classificationLUT, uv);\\n\\n\\treturn classColor;\\n}\\n\\nvec3 getReturnNumber() {\\n\\tif (numberOfReturns == 1.0) {\\n\\t\\treturn vec3(1.0, 1.0, 0.0);\\n\\t} else {\\n\\t\\tif (returnNumber == 1.0) {\\n\\t\\t\\treturn vec3(1.0, 0.0, 0.0);\\n\\t\\t} else if (returnNumber == numberOfReturns) {\\n\\t\\t\\treturn vec3(0.0, 0.0, 1.0);\\n\\t\\t} else {\\n\\t\\t\\treturn vec3(0.0, 1.0, 0.0);\\n\\t\\t}\\n\\t}\\n}\\n\\nvec3 getSourceID() {\\n\\tfloat w = mod(pointSourceID, 10.0) / 10.0;\\n\\treturn texture(gradient, vec2(w, 1.0 - w)).rgb;\\n}\\n\\nvec3 getCompositeColor() {\\n\\tvec3 c;\\n\\tfloat w;\\n\\n\\tc += wRGB * getRGB();\\n\\tw += wRGB;\\n\\n\\tc += wIntensity * getIntensity() * vec3(1.0, 1.0, 1.0);\\n\\tw += wIntensity;\\n\\n\\tc += wElevation * getElevation();\\n\\tw += wElevation;\\n\\n\\tc += wReturnNumber * getReturnNumber();\\n\\tw += wReturnNumber;\\n\\n\\tc += wSourceID * getSourceID();\\n\\tw += wSourceID;\\n\\n\\tvec4 cl = wClassification * getClassification();\\n\\tc += cl.a * cl.rgb;\\n\\tw += wClassification * cl.a;\\n\\n\\tc = c / w;\\n\\n\\tif (w == 0.0) {\\n\\t\\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\\n\\t}\\n\\n\\treturn c;\\n}\\n\\nvoid main() {\\n\\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\t\\tvViewPosition = mvPosition.xyz;\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t\\tvLinearDepth = gl_Position.w;\\n\\t#endif\\n\\n\\t#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\t\\tvNormal = normalize(normalMatrix * normal);\\n\\t#endif\\n\\n\\t#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\t\\tvLogDepth = log2(-mvPosition.z);\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// POINT SIZE\\n\\t// ---------------------\\n\\n\\tfloat pointSize = 1.0;\\n\\tfloat slope = tan(fov / 2.0);\\n\\tfloat projFactor =  -0.5 * screenHeight / (slope * mvPosition.z);\\n\\n\\t#if defined fixed_point_size\\n\\t\\tpointSize = size;\\n\\t#elif defined attenuated_point_size\\n\\t\\tpointSize = size * spacing * projFactor;\\n\\t#elif defined adaptive_point_size\\n\\t\\tfloat worldSpaceSize = 2.0 * size * spacing / getPointSizeAttenuation();\\n\\t\\tpointSize = worldSpaceSize * projFactor;\\n\\t#endif\\n\\n\\tpointSize = max(minSize, pointSize);\\n\\tpointSize = min(maxSize, pointSize);\\n\\n\\t#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\t\\tvRadius = pointSize / projFactor;\\n\\t#endif\\n\\n\\tgl_PointSize = pointSize;\\n\\n\\t// ---------------------\\n\\t// HIGHLIGHTING\\n\\t// ---------------------\\n\\n\\t#ifdef highlight_point\\n\\t\\tvec4 mPosition = modelMatrix * vec4(position, 1.0);\\n\\t\\tif (enablePointHighlighting && abs(mPosition.x - highlightedPointCoordinate.x) < 0.0001 &&\\n\\t\\t\\tabs(mPosition.y - highlightedPointCoordinate.y) < 0.0001 &&\\n\\t\\t\\tabs(mPosition.z - highlightedPointCoordinate.z) < 0.0001) {\\n\\t\\t\\tvHighlight = 1.0;\\n\\t\\t\\tgl_PointSize = pointSize * highlightedPointScale;\\n\\t\\t} else {\\n\\t\\t\\tvHighlight = 0.0;\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// OPACITY\\n\\t// ---------------------\\n\\n\\t#ifndef color_type_point_index\\n\\t\\t#ifdef attenuated_opacity\\n\\t\\t\\tvOpacity = opacity * exp(-length(-mvPosition.xyz) / opacityAttenuation);\\n\\t\\t#else\\n\\t\\t\\tvOpacity = opacity;\\n\\t\\t#endif\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// FILTERING\\n\\t// ---------------------\\n\\n\\t#ifdef use_filter_by_normal\\n\\t\\tbool discardPoint = false;\\n\\t\\t// Absolute normal filtering\\n\\t\\tif (normalFilteringMode == 1) {\\n\\t\\t\\tdiscardPoint = (abs((modelViewMatrix * vec4(normal, 0.0)).z) > filterByNormalThreshold);\\n\\t\\t}\\n\\t\\t// less than equal to\\n\\t\\telse if (normalFilteringMode == 2) {\\n\\t\\t\\tdiscardPoint = (modelViewMatrix * vec4(normal, 0.0)).z <= filterByNormalThreshold;\\n\\t\\t\\t}\\n\\t\\t// greater than\\n\\t\\telse if(normalFilteringMode == 3) {\\n\\t\\t\\tdiscardPoint = (modelViewMatrix * vec4(normal, 0.0)).z > filterByNormalThreshold;\\n\\t\\t\\t}\\n\\n\\t\\tif (discardPoint)\\n\\t\\t{\\n\\t\\t\\tgl_Position = vec4(0.0, 0.0, 2.0, 1.0);\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// POINT COLOR\\n\\t// ---------------------\\n\\n\\t#ifdef color_type_rgb\\n\\t\\tvColor = getRGB();\\n\\t#elif defined color_type_height\\n\\t\\tvColor = getElevation();\\n\\t#elif defined color_type_rgb_height\\n\\t\\tvec3 cHeight = getElevation();\\n\\t\\tvColor = (1.0 - transition) * getRGB() + transition * cHeight;\\n\\t#elif defined color_type_depth\\n\\t\\tfloat linearDepth = -mvPosition.z ;\\n\\t\\tfloat expDepth = (gl_Position.z / gl_Position.w) * 0.5 + 0.5;\\n\\t\\tvColor = vec3(linearDepth, expDepth, 0.0);\\n\\t#elif defined color_type_intensity\\n\\t\\tfloat w = getIntensity();\\n\\t\\tvColor = vec3(w, w, w);\\n\\t#elif defined color_type_intensity_gradient\\n\\t\\tfloat w = getIntensity();\\n\\t\\tvColor = texture(gradient, vec2(w, 1.0 - w)).rgb;\\n\\t#elif defined color_type_color\\n\\t\\tvColor = uColor;\\n\\t#elif defined color_type_lod\\n\\tfloat w = getLOD() / 10.0;\\n\\tvColor = texture(gradient, vec2(w, 1.0 - w)).rgb;\\n\\t#elif defined color_type_point_index\\n\\t\\tvColor = indices.rgb;\\n\\t#elif defined color_type_classification\\n\\t  vec4 cl = getClassification();\\n\\t\\tvColor = cl.rgb;\\n\\t#elif defined color_type_return_number\\n\\t\\tvColor = getReturnNumber();\\n\\t#elif defined color_type_source\\n\\t\\tvColor = getSourceID();\\n\\t#elif defined color_type_normal\\n\\t\\tvColor = (modelMatrix * vec4(normal, 0.0)).xyz;\\n\\t#elif defined color_type_phong\\n\\t\\tvColor = color;\\n\\t#elif defined color_type_composite\\n\\t\\tvColor = getCompositeColor();\\n\\t#endif\\n\\n\\t#if !defined color_type_composite && defined color_type_classification\\n\\t\\tif (cl.a == 0.0) {\\n\\t\\t\\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// CLIPPING\\n\\t// ---------------------\\n\\n\\t#if defined use_clip_box\\n\\t\\tbool insideAny = false;\\n\\t\\tfor (int i = 0; i < max_clip_boxes; i++) {\\n\\t\\t\\tif (i == int(clipBoxCount)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec4 clipPosition = clipBoxes[i] * modelMatrix * vec4(position, 1.0);\\n\\t\\t\\tbool inside = -0.5 <= clipPosition.x && clipPosition.x <= 0.5;\\n\\t\\t\\tinside = inside && -0.5 <= clipPosition.y && clipPosition.y <= 0.5;\\n\\t\\t\\tinside = inside && -0.5 <= clipPosition.z && clipPosition.z <= 0.5;\\n\\t\\t\\tinsideAny = insideAny || inside;\\n\\t\\t}\\n\\n\\t\\tif (!insideAny) {\\n\\t\\t\\t#if defined clip_outside\\n\\t\\t\\t\\tgl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0);\\n\\t\\t\\t#elif defined clip_highlight_inside && !defined(color_type_depth)\\n\\t\\t\\t\\tfloat c = (vColor.r + vColor.g + vColor.b) / 6.0;\\n\\t\\t\\t#endif\\n\\t\\t} else {\\n\\t\\t\\t#if defined clip_highlight_inside\\n\\t\\t\\t\\tvColor.r += 0.5;\\n\\t\\t\\t#elif defined clip_inside\\n\\t\\t\\t\\tgl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0);\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#endif\\n\\n\\n\\t// ---------------------\\n\\t// For Depth purposes\\n\\t// ---------------------\\n\\n\\tif(renderDepth) {\\n\\t\\tvColor = vec3(1. - gl_Position.z / gl_Position.w);\\n\\t}\\n\\n}\\n\";","\nimport worker from \"!!../../node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";const t={DATA_TYPE_DOUBLE:{ordinal:0,name:\\\"double\\\",size:8},DATA_TYPE_FLOAT:{ordinal:1,name:\\\"float\\\",size:4},DATA_TYPE_INT8:{ordinal:2,name:\\\"int8\\\",size:1},DATA_TYPE_UINT8:{ordinal:3,name:\\\"uint8\\\",size:1},DATA_TYPE_INT16:{ordinal:4,name:\\\"int16\\\",size:2},DATA_TYPE_UINT16:{ordinal:5,name:\\\"uint16\\\",size:2},DATA_TYPE_INT32:{ordinal:6,name:\\\"int32\\\",size:4},DATA_TYPE_UINT32:{ordinal:7,name:\\\"uint32\\\",size:4},DATA_TYPE_INT64:{ordinal:8,name:\\\"int64\\\",size:8},DATA_TYPE_UINT64:{ordinal:9,name:\\\"uint64\\\",size:8}};let e=0;for(const n in t)t[e]=t[n],e++;class n{constructor(t,e,n,r=[1/0,-1/0],a=void 0){this.name=t,this.type=e,this.numElements=n,this.range=r,this.uri=a,this.byteSize=this.numElements*this.type.size,this.description=\\\"\\\"}}function r(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=null==t?null:\\\"undefined\\\"!=typeof Symbol&&t[Symbol.iterator]||t[\\\"@@iterator\\\"];if(null!=n){var r,a,i,o,u=[],A=!0,f=!1;try{if(i=(n=n.call(t)).next,0===e){if(Object(n)!==n)return;A=!1}else for(;!(A=(r=i.call(n)).done)&&(u.push(r.value),u.length!==e);A=!0);}catch(t){f=!0,a=t}finally{try{if(!A&&null!=n.return&&(o=n.return(),Object(o)!==o))return}finally{if(f)throw a}}return u}}(t,e)||i(t,e)||function(){throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\")}()}function a(t,e){var n=\\\"undefined\\\"!=typeof Symbol&&t[Symbol.iterator]||t[\\\"@@iterator\\\"];if(!n){if(Array.isArray(t)||(n=i(t))||e&&t&&\\\"number\\\"==typeof t.length){n&&(t=n);var r=0,a=function(){};return{s:a,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:a}}throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\")}var o,u=!0,A=!1;return{s:function(){n=n.call(t)},n:function(){var t=n.next();return u=t.done,t},e:function(t){A=!0,o=t},f:function(){try{u||null==n.return||n.return()}finally{if(A)throw o}}}}function i(t,e){if(t){if(\\\"string\\\"==typeof t)return o(t,e);var n={}.toString.call(t).slice(8,-1);return\\\"Object\\\"===n&&t.constructor&&(n=t.constructor.name),\\\"Map\\\"===n||\\\"Set\\\"===n?Array.from(t):\\\"Arguments\\\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?o(t,e):void 0}}function o(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=Array(e);n<e;n++)r[n]=t[n];return r}new n(\\\"POSITION_CARTESIAN\\\",t.DATA_TYPE_FLOAT,3),new n(\\\"COLOR_PACKED\\\",t.DATA_TYPE_INT8,4),new n(\\\"COLOR_PACKED\\\",t.DATA_TYPE_INT8,4),new n(\\\"COLOR_PACKED\\\",t.DATA_TYPE_INT8,3),new n(\\\"NORMAL_FLOATS\\\",t.DATA_TYPE_FLOAT,3),new n(\\\"INTENSITY\\\",t.DATA_TYPE_UINT16,1),new n(\\\"CLASSIFICATION\\\",t.DATA_TYPE_UINT8,1),new n(\\\"NORMAL_SPHEREMAPPED\\\",t.DATA_TYPE_UINT8,2),new n(\\\"NORMAL_OCT16\\\",t.DATA_TYPE_UINT8,2),new n(\\\"NORMAL\\\",t.DATA_TYPE_FLOAT,3),new n(\\\"RETURN_NUMBER\\\",t.DATA_TYPE_UINT8,1),new n(\\\"NUMBER_OF_RETURNS\\\",t.DATA_TYPE_UINT8,1),new n(\\\"SOURCE_ID\\\",t.DATA_TYPE_UINT16,1),new n(\\\"INDICES\\\",t.DATA_TYPE_UINT32,1),new n(\\\"SPACING\\\",t.DATA_TYPE_FLOAT,1),new n(\\\"GPS_TIME\\\",t.DATA_TYPE_DOUBLE,1);var u={int8:Int8Array,int16:Int16Array,int32:Int32Array,int64:Float64Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,uint64:Float64Array,float:Float32Array,double:Float64Array};onmessage=function(e){var i,o=e.data,A=o.buffer,f=o.pointAttributes,T=o.scale,l=(o.name,o.min),s=(o.max,o.size),I=o.offset,_=o.numPoints,y=new DataView(A),m={},E=0,N=0,c=a(f.attributes);try{for(c.s();!(i=c.n()).done;)N+=i.value.byteSize}catch(t){c.e(t)}finally{c.f()}var b,d=32,h=new Uint32Array(Math.pow(d,3)),v=function(t,e,n){var r=d*t/s.x,a=d*e/s.y,i=d*n/s.z,o=Math.min(parseInt(r),31),u=Math.min(parseInt(a),31),A=Math.min(parseInt(i),31);return o+u*d+A*d*d},w=0,P=[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],D=[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY],Y=a(f.attributes);try{for(Y.s();!(b=Y.n()).done;){var O=b.value;if([\\\"POSITION_CARTESIAN\\\",\\\"position\\\"].includes(O.name)){for(var U=new ArrayBuffer(4*_*3),g=new Float32Array(U),S=0;S<_;S++){var p=S*N,F=y.getInt32(p+E+0,!0)*T[0]+I[0]-l.x,M=y.getInt32(p+E+4,!0)*T[1]+I[1]-l.y,z=y.getInt32(p+E+8,!0)*T[2]+I[2]-l.z;P[0]=Math.min(P[0],F),P[1]=Math.min(P[1],M),P[2]=Math.min(P[2],z),D[0]=Math.max(D[0],F),D[1]=Math.max(D[1],M),D[2]=Math.max(D[2],z),0===h[v(F,M,z)]++&&w++,g[3*S+0]=F,g[3*S+1]=M,g[3*S+2]=z}m[O.name]={buffer:U,attribute:O}}else if([\\\"RGBA\\\",\\\"rgba\\\"].includes(O.name)){for(var R=new ArrayBuffer(4*_),C=new Uint8Array(R),L=0;L<_;L++){var B=L*N,x=y.getUint16(B+E+0,!0),V=y.getUint16(B+E+2,!0),G=y.getUint16(B+E+4,!0);C[4*L+0]=x>255?x/256:x,C[4*L+1]=V>255?V/256:V,C[4*L+2]=G>255?G/256:G}m[O.name]={buffer:R,attribute:O}}else{var j=new ArrayBuffer(4*_),K=new Float32Array(j),H=new(0,u[O.type.name])(_),$=0,k=1,q={int8:y.getInt8,int16:y.getInt16,int32:y.getInt32,uint8:y.getUint8,uint16:y.getUint16,uint32:y.getUint32,float:y.getFloat32,double:y.getFloat64}[O.type.name].bind(y);if(O.type.size>4){var J=r(O.range,2),Q=J[0],W=J[1];$=Q,k=1/(W-Q)}for(var X=0;X<_;X++){var Z=q(X*N+E,!0);K[X]=(Z-$)*k,H[X]=Z}m[O.name]={buffer:j,preciseBuffer:H,attribute:O,offset:$,scale:k}}E+=O.byteSize}}catch(t){Y.e(t)}finally{Y.f()}for(var tt=parseInt(_/w),et=new ArrayBuffer(4*_),nt=new Uint32Array(et),rt=0;rt<_;rt++)nt[rt]=rt;m.INDICES={buffer:et,attribute:n.INDICES};var at,it=a(f.vectors);try{for(it.s();!(at=it.n()).done;){var ot,ut=at.value,At=ut.name,ft=ut.attributes,Tt=ft.length,lt=new ArrayBuffer(Tt*_*4),st=new Float32Array(lt),It=0,_t=a(ft);try{for(_t.s();!(ot=_t.n()).done;){for(var yt=m[ot.value],mt=yt.offset,Et=yt.scale,Nt=new DataView(yt.buffer),ct=Nt.getFloat32.bind(Nt),bt=0;bt<_;bt++){var dt=ct(4*bt,!0);st[bt*Tt+It]=dt/Et+mt}It++}}catch(t){_t.e(t)}finally{_t.f()}var ht=new n(At,t.DATA_TYPE_FLOAT,3);m[At]={buffer:lt,attribute:ht}}}catch(t){it.e(t)}finally{it.f()}var vt={buffer:A,attributeBuffers:m,density:tt,tightBoundingBox:{min:P,max:D}},wt=[];for(var Pt in vt.attributeBuffers)wt.push(vt.attributeBuffers[Pt].buffer);wt.push(A),postMessage(vt,wt)}})();\\n\", \"Worker\", undefined, undefined);\n}\n","export default \"precision highp float;\\nprecision highp int;\\n\\nuniform mat4 projectionMatrix;\\n\\nuniform float screenWidth;\\nuniform float screenHeight;\\n\\nuniform sampler2D map;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n\\n\\tfloat dx = 1.0 / screenWidth;\\n\\tfloat dy = 1.0 / screenHeight;\\n\\n\\tvec3 color = vec3(0.0, 0.0, 0.0);\\n\\tcolor += texture2D(map, vUv + vec2(-dx, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(-dx,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(-dx,  dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0,  dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx,  dy)).rgb;\\n    \\n\\tcolor = color / 9.0;\\n\\t\\n\\tgl_FragColor = vec4(color, 1.0);\\n\\t\\n\\t\\n}\";","export default \"precision highp float;\\nprecision highp int;\\n\\nuniform float opacity;\\nuniform bool renderIds;\\nuniform bool debugMode;\\n\\nuniform bool useClipping;\\nuniform float screenWidth;\\nuniform float screenHeight;\\nuniform vec4 clipExtent;\\n\\nin vec3 vColor;\\nin float vOpacity;\\nin vec2 vPosition;\\nin float backfaseCulling;\\nin vec2 vID;\\nin float vRenderScale;\\n\\nout vec4 color_data;\\n\\nuvec3 murmurHash31(uint src) {\\n    const uint M = 0x5bd1e995u;\\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\\n    src *= M; src ^= src>>24u; src *= M;\\n    h *= M; h ^= src;\\n    h ^= h>>13u; h *= M; h ^= h>>15u;\\n    return h;\\n}\\n\\n// 3 outputs, 1 input\\nvec3 hash31(float src) {\\n    uvec3 h = murmurHash31(floatBitsToUint(src));\\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\\n}\\n\\nvoid main() {\\n\\n\\tif(useClipping) {\\n\\t\\tvec2 ndc = vec2((gl_FragCoord.x / screenWidth), 1.0 - (gl_FragCoord.y / screenHeight));\\n\\n\\t\\tif(step(clipExtent.x, ndc.x) * step(ndc.x, clipExtent.z) < 1.0)\\n\\t\\t{\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\n\\t\\tif(step(clipExtent.y, ndc.y) * step(ndc.y, clipExtent.w) < 1.0)\\n\\t\\t{\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t}\\n\\n\\tfloat A = dot(vPosition, vPosition);\\n\\tif (A > 8.0) discard;\\n\\t\\n\\tfloat opacity = exp(-0.5 * A) * vOpacity;\\n\\tcolor_data = vec4(vColor, opacity);\\n\\t\\n\\tif(debugMode){\\n\\t\\tif(opacity < 0.1) discard;\\n\\t\\tcolor_data = vec4( hash31(vID.x), 1.);\\t\\n\\t}\\n\\n\\tif(renderIds) {\\n\\t\\tif(opacity < 0.1) discard;\\n\\t\\tcolor_data = vec4(vID, vRenderScale, 1.);\\n\\t} \\n\\n}\\n\";","\"use strict\";\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};","export default \"precision highp float;\\nprecision highp int;\\n\\nattribute vec3 position;\\nattribute vec2 uv;\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n\\n    gl_Position =   projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\";","module.exports = __WEBPACK_EXTERNAL_MODULE__604__;","\nimport worker from \"!!../../node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";const r={DATA_TYPE_DOUBLE:{ordinal:0,name:\\\"double\\\",size:8},DATA_TYPE_FLOAT:{ordinal:1,name:\\\"float\\\",size:4},DATA_TYPE_INT8:{ordinal:2,name:\\\"int8\\\",size:1},DATA_TYPE_UINT8:{ordinal:3,name:\\\"uint8\\\",size:1},DATA_TYPE_INT16:{ordinal:4,name:\\\"int16\\\",size:2},DATA_TYPE_UINT16:{ordinal:5,name:\\\"uint16\\\",size:2},DATA_TYPE_INT32:{ordinal:6,name:\\\"int32\\\",size:4},DATA_TYPE_UINT32:{ordinal:7,name:\\\"uint32\\\",size:4},DATA_TYPE_INT64:{ordinal:8,name:\\\"int64\\\",size:8},DATA_TYPE_UINT64:{ordinal:9,name:\\\"uint64\\\",size:8}};let t=0;for(const e in r)r[t]=r[e],t++;class e{constructor(r,t,e,a=[1/0,-1/0],n=void 0){this.name=r,this.type=t,this.numElements=e,this.range=a,this.uri=n,this.byteSize=this.numElements*this.type.size,this.description=\\\"\\\"}}function a(r){throw new TypeError('\\\"'+r+'\\\" is read-only')}function n(r,t){var e=\\\"undefined\\\"!=typeof Symbol&&r[Symbol.iterator]||r[\\\"@@iterator\\\"];if(!e){if(Array.isArray(r)||(e=function(r,t){if(r){if(\\\"string\\\"==typeof r)return i(r,t);var e={}.toString.call(r).slice(8,-1);return\\\"Object\\\"===e&&r.constructor&&(e=r.constructor.name),\\\"Map\\\"===e||\\\"Set\\\"===e?Array.from(r):\\\"Arguments\\\"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?i(r,t):void 0}}(r))||t&&r&&\\\"number\\\"==typeof r.length){e&&(r=e);var a=0,n=function(){};return{s:n,n:function(){return a>=r.length?{done:!0}:{done:!1,value:r[a++]}},e:function(r){throw r},f:n}}throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\")}var o,A=!0,f=!1;return{s:function(){e=e.call(r)},n:function(){var r=e.next();return A=r.done,r},e:function(r){f=!0,o=r},f:function(){try{A||null==e.return||e.return()}finally{if(f)throw o}}}}function i(r,t){(null==t||t>r.length)&&(t=r.length);for(var e=0,a=Array(t);e<t;e++)a[e]=r[e];return a}new e(\\\"POSITION_CARTESIAN\\\",r.DATA_TYPE_FLOAT,3),new e(\\\"COLOR_PACKED\\\",r.DATA_TYPE_INT8,4),new e(\\\"COLOR_PACKED\\\",r.DATA_TYPE_INT8,4),new e(\\\"COLOR_PACKED\\\",r.DATA_TYPE_INT8,3),new e(\\\"NORMAL_FLOATS\\\",r.DATA_TYPE_FLOAT,3),new e(\\\"INTENSITY\\\",r.DATA_TYPE_UINT16,1),new e(\\\"CLASSIFICATION\\\",r.DATA_TYPE_UINT8,1),new e(\\\"NORMAL_SPHEREMAPPED\\\",r.DATA_TYPE_UINT8,2),new e(\\\"NORMAL_OCT16\\\",r.DATA_TYPE_UINT8,2),new e(\\\"NORMAL\\\",r.DATA_TYPE_FLOAT,3),new e(\\\"RETURN_NUMBER\\\",r.DATA_TYPE_UINT8,1),new e(\\\"NUMBER_OF_RETURNS\\\",r.DATA_TYPE_UINT8,1),new e(\\\"SOURCE_ID\\\",r.DATA_TYPE_UINT16,1),new e(\\\"INDICES\\\",r.DATA_TYPE_UINT32,1),new e(\\\"SPACING\\\",r.DATA_TYPE_FLOAT,1),new e(\\\"GPS_TIME\\\",r.DATA_TYPE_DOUBLE,1),Int8Array,Int16Array,Int32Array,Float64Array,Uint8Array,Uint16Array,Uint32Array,Float64Array,Float32Array,Float64Array,onmessage=function(t){var i,o,A,f=t.data,_=f.buffer,u=f.pointAttributes,l=(f.scale,f.name,f.min),s=(f.max,f.size),T=f.offset,y=f.numPoints,I=f.harmonicsEnabled,w=new DataView(_),b={},h=32,N=new Uint32Array(Math.pow(h,3)),E=function(r,t,e){var a=h*r/s.x,n=h*t/s.y,i=h*e/s.z,o=Math.min(parseInt(a),31),A=Math.min(parseInt(n),31),f=Math.min(parseInt(i),31);return o+A*h+f*h*h},m=function(r,t,e){return Math.max(Math.min(r,e),t)},c=0,d=[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],v=[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY],O=new ArrayBuffer(4*y*3),p=new Float32Array(O),F=new ArrayBuffer(4*y*4),P=new Float32Array(F),M=new ArrayBuffer(4*y*4),D=new Float32Array(M),x=new ArrayBuffer(4*y*4),Y=new Float32Array(x),z=new ArrayBuffer(4*y*4),C=new Float32Array(z),S=new ArrayBuffer(4*y*45),g=new Float32Array(S),R=[\\\"sh_band_1_triplet_0\\\",\\\"sh_band_1_triplet_1\\\",\\\"sh_band_1_triplet_2\\\",\\\"sh_band_2_triplet_0\\\",\\\"sh_band_2_triplet_1\\\",\\\"sh_band_2_triplet_2\\\",\\\"sh_band_2_triplet_3\\\",\\\"sh_band_2_triplet_4\\\",\\\"sh_band_3_triplet_0\\\",\\\"sh_band_3_triplet_1\\\",\\\"sh_band_3_triplet_2\\\",\\\"sh_band_3_triplet_3\\\",\\\"sh_band_3_triplet_4\\\",\\\"sh_band_3_triplet_5\\\",\\\"sh_band_3_triplet_6\\\"],U=n(u.attributes);try{for(U.s();!(i=U.n()).done;){var B=i.value;if([\\\"POSITION_CARTESIAN\\\",\\\"position\\\"].includes(B.name)){for(var L=T[0]-l.x,V=T[1]-l.y,H=T[2]-l.z,G=0;G<y;G++){var K=12*G,j=w.getFloat32(K+0,!0),q=w.getFloat32(K+4,!0),$=w.getFloat32(K+8,!0),k=j+L,J=q+V,Q=$+H;d[0]=Math.min(d[0],k),d[1]=Math.min(d[1],J),d[2]=Math.min(d[2],Q),v[0]=Math.max(v[0],k),v[1]=Math.max(v[1],J),v[2]=Math.max(v[2],Q),0===N[E(k,J,Q)]++&&c++,D[4*G+0]=k,D[4*G+1]=J,D[4*G+2]=Q,C[4*G+0]=j,C[4*G+1]=q,C[4*G+2]=$}b.raw_position={buffer:z,attribute:\\\"raw_position\\\"},b.position={buffer:M,attribute:\\\"position\\\"}}else if([\\\"sh_band_0\\\"].includes(B.name))for(var W=.28209479177387814,X=0;X<y;X++){var Z=4*X+0,rr=4*X+1,tr=4*X+2,er=4*X+3,ar=12*X+12*y,nr=4*X+24*y,ir=w.getFloat32(ar+0,!0),or=w.getFloat32(ar+4,!0),Ar=w.getFloat32(ar+8,!0);Y[Z]=255*(.5+W*ir),Y[rr]=255*(.5+W*or),Y[tr]=255*(.5+W*Ar),Y[Z]=m(Math.floor(Y[Z]),0,255),Y[rr]=m(Math.floor(Y[rr]),0,255),Y[tr]=m(Math.floor(Y[tr]),0,255);var fr=w.getFloat32(nr,!0);fr=1/(1+Math.exp(-fr))*255,fr=m(Math.floor(fr),0,255),Y[er]=fr}else if([\\\"scale\\\"].includes(B.name)){for(var _r=0;_r<y;_r++){var ur=12*_r+28*y,lr=w.getFloat32(ur+0,!0),sr=w.getFloat32(ur+4,!0),Tr=w.getFloat32(ur+8,!0);p[3*_r+0]=Math.exp(lr),p[3*_r+1]=Math.exp(sr),p[3*_r+2]=Math.exp(Tr)}b.scale={buffer:O,attribute:\\\"scale\\\"}}else if([\\\"rotation\\\"].includes(B.name)){for(var yr={x:0,y:0,z:0,w:0},Ir=0;Ir<y;Ir++){var wr=16*Ir+40*y,br=w.getFloat32(wr+0,!0),hr=w.getFloat32(wr+4,!0),Nr=w.getFloat32(wr+8,!0),Er=w.getFloat32(wr+12,!0);yr.x=br,yr.y=hr,yr.z=Nr,yr.w=Er;var mr=Math.sqrt(br*br+hr*hr+Nr*Nr+Er*Er);0==mr?(yr.x=0,yr.y=0,yr.z=0,yr.w=1):(yr.x=br/mr,yr.y=hr/mr,yr.z=Nr/mr,yr.w=Er/mr),P[4*Ir+0]=yr.x,P[4*Ir+1]=yr.y,P[4*Ir+2]=yr.z,P[4*Ir+3]=yr.w}b.orientation={buffer:F,attribute:\\\"orientation\\\"}}else if(B.name.indexOf(\\\"triplet\\\")>-1&&I)for(var cr=0;cr<y;cr++){var dr=R.indexOf(B.name),vr=12*cr+y*(56+12*dr),Or=w.getFloat32(vr+0,!0),pr=w.getFloat32(vr+4,!0),Fr=w.getFloat32(vr+8,!0);g[45*cr+3*dr+0]=Or,g[45*cr+3*dr+1]=pr,g[45*cr+3*dr+2]=Fr}}}catch(r){U.e(r)}finally{U.f()}for(var Pr=function(r,t,e){var a=function(r,t){var e=new Array(16),a=r.x,n=r.y,i=r.z,o=r.w,A=a+a,f=n+n,_=i+i,u=a*A,l=a*f,s=a*_,T=n*f,y=n*_,I=i*_,w=o*A,b=o*f,h=o*_,N=t.x,E=t.y;e[0]=(1-(T+I))*N,e[1]=(l+h)*N,e[2]=(s-b)*N,e[3]=(l-h)*E,e[4]=(1-(u+I))*E,e[5]=(y+w)*E,e[6]=0,e[7]=0,e[8]=0;var m,c,d,v,O,p,F,P,M,D,x,Y,z,C,S,g,R,U,B,L,V,H,G=e.map(function(r){return r}),K=G;return m=K[1],K[1]=K[3],K[3]=m,m=K[2],K[2]=K[6],K[6]=m,m=K[5],K[5]=K[7],K[7]=m,c=e,d=G,v=new Array(9),O=c[0],p=c[3],F=c[6],P=c[1],M=c[4],D=c[7],x=c[2],Y=c[5],z=c[8],C=d[0],S=d[3],g=d[6],R=d[1],U=d[4],B=d[7],L=d[2],V=d[5],H=d[8],v[0]=O*C+p*R+F*L,v[3]=O*S+p*U+F*V,v[6]=O*g+p*B+F*H,v[1]=P*C+M*R+D*L,v[4]=P*S+M*U+D*V,v[7]=P*g+M*B+D*H,v[2]=x*C+Y*R+z*L,v[5]=x*S+Y*U+z*V,v[8]=x*g+Y*B+z*H,v}(t,r);Dr[4*e+0]=a[0],Dr[4*e+1]=a[3],Dr[4*e+2]=a[6],Dr[4*e+3]=a[4],Yr[2*e+0]=a[7],Yr[2*e+1]=a[8]},Mr=new ArrayBuffer(4*y*4),Dr=new Float32Array(Mr),xr=new ArrayBuffer(4*y*2),Yr=new Float32Array(xr),zr=0;zr<y;zr++){var Cr={x:0,y:0,z:0,w:0},Sr={x:0,y:0,z:0};Cr.w=P[4*zr+0],Cr.x=P[4*zr+1],Cr.y=P[4*zr+2],Cr.z=P[4*zr+3],Sr.x=p[3*zr+0],Sr.y=p[3*zr+1],Sr.z=p[3*zr+2],Pr(Sr,Cr,zr)}b.COVARIANCE0={buffer:Mr,attribute:e.COVARIANCE0},b.COVARIANCE1={buffer:xr,attribute:e.COVARIANCE1};for(var gr=function(r){return r[0]+(r[1]<<8)+(r[2]<<16)+(r[3]<<24)},Rr=(o=new Float32Array(1),A=new Int32Array(o.buffer),function(r){return o[0]=r,A[0]}),Ur=new ArrayBuffer(4*y*4),Br=new Int32Array(Ur),Lr=0;Lr<y;Lr++){var Vr={x:0,y:0,z:0,w:0},Hr={x:0,y:0,z:0};Vr.x=Y[4*Lr+0],Vr.y=Y[4*Lr+1],Vr.z=Y[4*Lr+2],Vr.w=Y[4*Lr+3],Hr.x=C[4*Lr+0],Hr.y=C[4*Lr+1],Hr.z=C[4*Lr+2];var Gr=gr([Vr.x,Vr.y,Vr.z,Vr.w]);Hr.x=Rr(Hr.x),Hr.y=Rr(Hr.y),Hr.z=Rr(Hr.z),Br[4*Lr+0]=Gr,Br[4*Lr+1]=Hr.x,Br[4*Lr+2]=Hr.y,Br[4*Lr+3]=Hr.z}b.POS_COLOR={buffer:Ur,attribute:e.POS_COLOR};var Kr=new ArrayBuffer(4*y*3),jr=new Uint32Array(Kr),qr=new ArrayBuffer(4*y*5),$r=new Uint32Array(qr),kr=new ArrayBuffer(4*y*7),Jr=new Uint32Array(kr);g=g.map(function(r,t){r=.5*(r=Math.min(Math.max(r,-1),1))+.5;var e=t%3==1?1023:2047;return Math.min(Math.max(Math.floor(r*e),0),e)});for(var Qr=0;Qr<y;Qr++)for(var Wr=0;Wr<15;Wr++){var Xr=g[45*Qr+3*Wr+0],Zr=g[45*Qr+3*Wr+1],rt=g[45*Qr+3*Wr+2];Wr<3&&(jr[3*Qr+Wr-0]=Xr<<21|Zr<<11|rt),Wr>=3&&Wr<8&&($r[5*Qr+Wr-3]=Xr<<21|Zr<<11|rt),Wr>=8&&(Jr[7*Qr+Wr-8]=Xr<<21|Zr<<11|rt)}b.HARMONICS1={buffer:Kr,attribute:\\\"HARMONICS1\\\"},b.HARMONICS2={buffer:qr,attribute:\\\"HARMONICS2\\\"},b.HARMONICS3={buffer:kr,attribute:\\\"HARMONICS3\\\"};for(var tt=parseInt(y/c),et=new ArrayBuffer(4*y),at=new Uint32Array(et),nt=0;nt<y;nt++)at[nt]=nt;b.INDICES={buffer:et,attribute:e.INDICES};var it,ot=n(u.vectors);try{for(ot.s();!(it=ot.n()).done;){var At,ft=it.value,_t=ft.name,ut=ft.attributes,lt=ut.length,st=new ArrayBuffer(lt*y*4),Tt=new Float32Array(st),yt=n(ut);try{for(yt.s();!(At=yt.n()).done;){for(var It=b[At.value],wt=It.offset,bt=It.scale,ht=new DataView(It.buffer),Nt=ht.getFloat32.bind(ht),Et=0;Et<y;Et++){var mt=Nt(4*Et,!0);Tt[Et*lt+0]=mt/bt+wt}a(\\\"iElement\\\")}}catch(r){yt.e(r)}finally{yt.f()}var ct=new e(_t,r.DATA_TYPE_FLOAT,3);b[_t]={buffer:st,attribute:ct}}}catch(r){ot.e(r)}finally{ot.f()}var dt={buffer:_,attributeBuffers:b,density:tt,tightBoundingBox:{min:d,max:v}},vt=[];for(var Ot in dt.attributeBuffers)vt.push(dt.attributeBuffers[Ot].buffer);vt.push(_),postMessage(dt,vt)}})();\\n\", \"Worker\", undefined, undefined);\n}\n","export default \"precision highp float;\\nprecision highp int;\\n\\nuniform vec2 focal;\\nuniform float inverseFocalAdjustment;\\nuniform float splatScale;\\nuniform float initialSplatScale;\\nuniform vec2 basisViewport;\\nuniform float harmonicsDegree;\\nuniform bool renderIds;\\nuniform bool adaptiveSize;\\nuniform bool renderLoD;\\nuniform vec3 globalOffset;\\n\\nuniform sampler2D covarianceTexture0;\\nuniform sampler2D covarianceTexture1;\\nuniform sampler2D nodeTexture;\\nuniform sampler2D nodeTexture2;\\n\\n\\nuniform highp usampler2D sortedTexture;\\nuniform highp usampler2D posColorTexture;\\nuniform highp usampler2D nodeIndicesTexture;\\nuniform highp usampler2D harmonicsTexture1;\\nuniform highp usampler2D harmonicsTexture2;\\nuniform highp usampler2D harmonicsTexture3;\\n\\nuniform float fov;\\nuniform float spacing;\\nuniform float screenHeight;\\nuniform float maxSplatScale;\\n\\nuniform float maxDepth;\\n\\n\\nuniform bool renderOnlyHarmonics;\\nuniform float harmonicsScale;\\n\\n//To read the LOD for each point\\nuniform sampler2D visibleNodes;\\nuniform float octreeSize;\\n\\nout vec3 vColor;\\nout float vOpacity;\\nout vec2 vPosition;\\nout float vZ;\\nout float backfaseCulling;\\nout vec2 vID;\\nout float vRenderScale;\\n\\nconst float sqrt8 = sqrt(8.0);\\nconst float minAlpha = 1.0 / 255.0;\\n\\n\\nconst vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\\nconst uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\\nconst uvec4 shift4 = uvec4(0, 8, 16, 24);\\nvec4 uintToRGBAVec (uint u) {\\n    uvec4 urgba = mask4 & u;\\n    urgba = urgba >> shift4;\\n    vec4 rgba = vec4(urgba) * encodeNorm4;\\n    return rgba;\\n}\\nvec3 unpack111011s(uint bits) { \\n    vec3 result = vec3((uvec3(bits) >> uvec3(21u, 11u, 0u)) & uvec3(0x7ffu, 0x3ffu, 0x7ffu)) / vec3(2047.0, 1023.0, 2047.0); \\n    return result * 2. - 1.;\\n}       \\nivec2 getDataUVSplat(in int stride, in int offset, in vec2 dimensions, in int index) {\\n    ivec2 samplerUV = ivec2(0, 0);\\n    float d = float(uint(index) * uint(stride) + uint(offset));\\n    samplerUV.y = int(floor(d / dimensions.x));\\n    samplerUV.x = int(mod(d, dimensions.x));\\n    return samplerUV;\\n}\\n\\nconst float SH_C1 = 0.4886025119029199f;\\nconst float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);\\nconst float[7] SH_C3 = float[](-0.5900435899266435, \\n                                2.890611442640554, \\n                                -0.4570457994644658, \\n                                0.3731763325901154, \\n                                -0.4570457994644658, \\n                                1.445305721320277, \\n                                -0.5900435899266435);\\n\\n/**\\n * Rounds the specified number to the closest integer.\\n */\\nfloat safeRound(float number){\\n\\treturn floor(number + 0.5);\\n}\\n\\n\\n/**\\n * Gets the number of 1-bits up to inclusive index position.\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nint numberOfOnes(int number, int index) {\\n\\tint numOnes = 0;\\n\\tint tmp = 128;\\n\\tfor (int i = 7; i >= 0; i--) {\\n\\n\\t\\tif (number >= tmp) {\\n\\t\\t\\tnumber = number - tmp;\\n\\n\\t\\t\\tif (i <= index) {\\n\\t\\t\\t\\tnumOnes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ttmp = tmp / 2;\\n\\t}\\n\\n\\treturn numOnes;\\n}\\n\\n/**\\n * Checks whether the bit at index is 1.0\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nbool isBitSet(int number, int index){\\n\\n\\t// weird multi else if due to lack of proper array, int and bitwise support in WebGL 1.0\\n\\tint powi = 1;\\n\\tif (index == 0) {\\n\\t\\tpowi = 1;\\n\\t} else if (index == 1) {\\n\\t\\tpowi = 2;\\n\\t} else if (index == 2) {\\n\\t\\tpowi = 4;\\n\\t} else if (index == 3) {\\n\\t\\tpowi = 8;\\n\\t} else if (index == 4) {\\n\\t\\tpowi = 16;\\n\\t} else if (index == 5) {\\n\\t\\tpowi = 32;\\n\\t} else if (index == 6) {\\n\\t\\tpowi = 64;\\n\\t} else if (index == 7) {\\n\\t\\tpowi = 128;\\n\\t}\\n\\n\\tint ndp = number / powi;\\n\\n\\treturn mod(float(ndp), 2.0) != 0.0;\\n}\\n\\n/**\\n * Gets the the LOD at the point position.\\n */\\nfloat getLOD(vec3 pos, int vnStart, float level) {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tint iOffset = vnStart;\\n\\tfloat depth = level;\\n\\n\\tfor (float i = 0.0; i <= 30.0; i++) {\\n\\t\\tfloat nodeSizeAtLevel = octreeSize  / pow(2.0, i + level + 0.0);\\n\\n\\t\\tvec3 index3d = (pos-offset) / nodeSizeAtLevel;\\n\\t\\tindex3d = floor(index3d + 0.5);\\n\\t\\tint index = int(safeRound(4.0 * index3d.x + 2.0 * index3d.y + index3d.z));\\n\\n\\t\\tvec4 value = texture2D(visibleNodes, vec2(float(iOffset) / 2048.0, 0.0));\\n\\t\\tint mask = int(safeRound(value.r * 255.0));\\n\\n\\t\\tif (isBitSet(mask, index)) {\\n\\t\\t\\t// there are more visible child nodes at this position\\n\\t\\t\\tint advanceG = int(safeRound(value.g * 255.0)) * 256;\\n\\t\\t\\tint advanceB = int(safeRound(value.b * 255.0));\\n\\t\\t\\tint advanceChild = numberOfOnes(mask, index - 1);\\n\\t\\t\\tint advance = advanceG + advanceB + advanceChild;\\n\\n\\t\\t\\tiOffset = iOffset + advance;\\n\\n\\t\\t\\tdepth++;\\n\\t\\t} else {\\n\\t\\t\\treturn value.a * 255.0; // no more visible child nodes at this position\\n\\t\\t}\\n\\n\\t\\toffset = offset + (vec3(1.0, 1.0, 1.0) * nodeSizeAtLevel * 0.5) * index3d;\\n\\t}\\n\\n\\treturn depth;\\n}\\n\\n\\nvoid main() {\\n\\n    ivec2 samplerUV = ivec2(0, 0);\\n    vec2 dim = vec2(textureSize(covarianceTexture0, 0).xy);\\n\\n    float dd = float(gl_InstanceID);\\n    samplerUV.y = int(floor(dd / dim.x));\\n    samplerUV.x = int(mod(dd, dim.x));\\n\\n    int indexes_sorted = int(texelFetch(sortedTexture, samplerUV, 0));\\n\\n    dd = float(indexes_sorted);\\n    samplerUV.y = int(floor(dd / dim.x));\\n    samplerUV.x = int(mod(dd, dim.x));\\n\\n    vec4 cov3D_4 = texelFetch(covarianceTexture0, samplerUV, 0);\\n    vec2 cov3D_2 = texelFetch(covarianceTexture1, samplerUV, 0).rg;\\n\\n\\n    uvec4 sampledCenterColor = texelFetch(posColorTexture, samplerUV, 0);\\n    vec3 instancePosition = uintBitsToFloat(uvec3(sampledCenterColor.gba));\\n    \\n    vec3 nodePosition = instancePosition;\\n    instancePosition += globalOffset;\\n\\n    uint nodeIndex = texelFetch(nodeIndicesTexture, samplerUV, 0).r;\\n\\n\\n    vID = vec2(indexes_sorted, nodeIndex);\\n\\n    samplerUV = ivec2(0, 0);\\n    dd = float(nodeIndex);\\n    samplerUV.y = int(floor(dd / 100.));\\n    samplerUV.x = int(mod(dd, 100.));\\n\\n    vec4 nodeData = texelFetch(nodeTexture, samplerUV, 0);\\n    vec4 nodeData2 = texelFetch(nodeTexture2, samplerUV, 0);\\n\\n    nodePosition += vec3(nodeData.a, nodeData2.ba);\\n\\n    ivec2 levelAndVnStart =  ivec2(nodeData2.rg);\\n    int vnStart = levelAndVnStart.r;\\n    int level = levelAndVnStart.g;\\n\\n    vec4 viewCenter = modelViewMatrix * vec4(instancePosition, 1.0);\\n    vec4 clipCenter = projectionMatrix * viewCenter;\\n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\\n\\n    mat3 Vrk = mat3(\\n        cov3D_4.x, cov3D_4.y, cov3D_4.z,\\n        cov3D_4.y, cov3D_4.w, cov3D_2.x,\\n        cov3D_4.z, cov3D_2.x, cov3D_2.y\\n    );\\n\\n    mat3 J;\\n    float s = 1.0 / (viewCenter.z * viewCenter.z);\\n    J = mat3(\\n        focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\\n        0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\\n        0., 0., 0.\\n    );\\n\\n    mat3 W = transpose(mat3(modelViewMatrix));\\n    mat3 T = W * J;\\n\\n    mat3 cov2Dm = transpose(T) * Vrk * T;\\n    cov2Dm[0][0] += 0.3;\\n    cov2Dm[1][1] += 0.3;\\n\\n    vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\\n\\n    float a = cov2Dv.x;\\n    float d = cov2Dv.z;\\n    float b = cov2Dv.y;\\n    float D = a * d - b * b;\\n    float trace = a + d;\\n    float traceOver2 = 0.5 * trace;\\n    float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));\\n    float eigenValue1 = traceOver2 + term2;\\n    float eigenValue2 = traceOver2 - term2;\\n\\n    if (eigenValue2 <= 0.0) return;\\n\\n    vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\\n    // since the eigen vectors are orthogonal, we derive the second one from the first\\n    vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\\n\\n    //Get the adaptive size\\n    float renderScale = 1.;\\n\\n    if(adaptiveSize) {\\n        float lodSplatScale = clamp(getLOD( nodePosition, int(vnStart), float(level) ) / maxDepth, 0., 1.);\\n        float currentSplatScale = lodSplatScale < 2. ? initialSplatScale : splatScale;\\n        renderScale = mix(maxSplatScale * currentSplatScale, 1., lodSplatScale);\\n    }\\n\\n    vRenderScale = renderScale;\\n\\n    float cameraDistance = length(cameraPosition - instancePosition);\\n\\n    // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.\\n    vec2 basisVector1 = eigenVector1 * renderScale * min(sqrt8 * sqrt(eigenValue1), 1024.);\\n    vec2 basisVector2 = eigenVector2 * renderScale * min(sqrt8 * sqrt(eigenValue2), 1024.);\\n\\n    vec2 ndcOffset = vec2(position.x * basisVector1 + position.y * basisVector2) *\\n                        basisViewport * 2.0 * inverseFocalAdjustment;\\n\\n    vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\\n    vZ = ndcCenter.z;\\n    gl_Position = quadPos;\\n\\n    vPosition = position.xy;\\n    vPosition *= sqrt8;\\n\\n    vec4 colorData = uintToRGBAVec(sampledCenterColor.r);\\n\\n    vColor = colorData.rgb;\\n\\n    vec4 worldCenter = modelMatrix * vec4(instancePosition, 1.0);\\n\\n    vec3 worldViewDir = normalize(worldCenter.xyz - cameraPosition);\\n\\n    //Harmonics\\n    vec3 harmonics = vec3(0.);\\n    vec3 sh1 = vec3(0.);\\n    vec3 sh2 = vec3(0.);\\n    vec3 sh3 = vec3(0.);\\n\\n    vec3 sh4 = vec3(0.);\\n    vec3 sh5 = vec3(0.);\\n    vec3 sh6 = vec3(0.);\\n    vec3 sh7 = vec3(0.);\\n    vec3 sh8 = vec3(0.);\\n\\n    vec3 sh9 = vec3(0.);\\n    vec3 sh10 = vec3(0.);\\n    vec3 sh11 = vec3(0.);\\n    vec3 sh12 = vec3(0.);\\n    vec3 sh13 = vec3(0.);\\n    vec3 sh14 = vec3(0.);\\n    vec3 sh15 = vec3(0.);\\n\\n    if(harmonicsDegree > 0. && !renderIds) {\\n\\n        vec2 degree1TextureSize = vec2(textureSize(harmonicsTexture1, 0));\\n\\n        uint d1 = texelFetch(harmonicsTexture1, getDataUVSplat(3, 0, degree1TextureSize, indexes_sorted), 0).r;\\n        uint d2 = texelFetch(harmonicsTexture1, getDataUVSplat(3, 1, degree1TextureSize, indexes_sorted), 0).r;\\n        uint d3 = texelFetch(harmonicsTexture1, getDataUVSplat(3, 2, degree1TextureSize, indexes_sorted), 0).r;\\n\\n        sh1 = unpack111011s(d1);\\n        sh2 = unpack111011s(d2);\\n        sh3 = unpack111011s(d3);\\n\\n        float x = worldViewDir.x;\\n        float y = worldViewDir.y;\\n        float z = worldViewDir.z;\\n\\n        float xx = 1.;\\n        float yy = 1.;\\n        float zz = 1.;\\n        float xy = 1.;\\n        float yz = 1.;\\n        float xz = 1.;\\n\\n        harmonics = SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);\\n\\n        if(harmonicsDegree > 1.) {\\n\\n            vec2 degree2TextureSize = vec2(textureSize(harmonicsTexture2, 0));\\n\\n            uint d4 = texelFetch(harmonicsTexture2, getDataUVSplat(5, 0, degree2TextureSize, indexes_sorted), 0).r;\\n            uint d5 = texelFetch(harmonicsTexture2, getDataUVSplat(5, 1, degree2TextureSize, indexes_sorted), 0).r;\\n            uint d6 = texelFetch(harmonicsTexture2, getDataUVSplat(5, 2, degree2TextureSize, indexes_sorted), 0).r;\\n            uint d7 = texelFetch(harmonicsTexture2, getDataUVSplat(5, 3, degree2TextureSize, indexes_sorted), 0).r;\\n            uint d8 = texelFetch(harmonicsTexture2, getDataUVSplat(5, 4, degree2TextureSize, indexes_sorted), 0).r;\\n\\n\\n            sh4 = unpack111011s(d4);\\n            sh5 = unpack111011s(d5);\\n            sh6 = unpack111011s(d6);\\n            sh7 = unpack111011s(d7);\\n            sh8 = unpack111011s(d8);\\n\\n\\n            xx = x * x;\\n            yy = y * y;\\n            zz = z * z;\\n            xy = x * y;\\n            yz = y * z;\\n            xz = x * z;\\n\\n            harmonics += \\n                (SH_C2[0] * xy) * sh4 +\\n                (SH_C2[1] * yz) * sh5 +\\n                (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +\\n                (SH_C2[3] * xz) * sh7 +\\n                (SH_C2[4] * (xx - yy)) * sh8;\\n\\n            if(harmonicsDegree > 2.) {\\n\\n                vec2 degree3TextureSize = vec2(textureSize(harmonicsTexture3, 0));\\n\\n                uint d9 =  texelFetch(harmonicsTexture3, getDataUVSplat(7, 0, degree3TextureSize, indexes_sorted), 0).r;\\n                uint d10 = texelFetch(harmonicsTexture3, getDataUVSplat(7, 1, degree3TextureSize, indexes_sorted), 0).r;\\n                uint d11 = texelFetch(harmonicsTexture3, getDataUVSplat(7, 2, degree3TextureSize, indexes_sorted), 0).r;\\n                uint d12 = texelFetch(harmonicsTexture3, getDataUVSplat(7, 3, degree3TextureSize, indexes_sorted), 0).r;\\n                uint d13 = texelFetch(harmonicsTexture3, getDataUVSplat(7, 4, degree3TextureSize, indexes_sorted), 0).r;\\n                uint d14 = texelFetch(harmonicsTexture3, getDataUVSplat(7, 5, degree3TextureSize, indexes_sorted), 0).r;\\n                uint d15 = texelFetch(harmonicsTexture3, getDataUVSplat(7, 6, degree3TextureSize, indexes_sorted), 0).r;\\n\\n                sh9 =  unpack111011s(d9);\\n                sh10 = unpack111011s(d10);\\n                sh11 = unpack111011s(d11);\\n                sh12 = unpack111011s(d12);\\n                sh13 = unpack111011s(d13);\\n                sh14 = unpack111011s(d14);\\n\\n                harmonics +=\\n                    SH_C3[0] * y * (3.0 * xx - yy) * sh9 +\\n                    SH_C3[1] * xy * z * sh10 +\\n                    SH_C3[2] * y * (4.0 * zz - xx - yy) * sh11 +\\n                    SH_C3[3] * z * (2.0 * zz - 3.0 * xx - 3.0 * yy) * sh12 +\\n                    SH_C3[4] * x * (4.0 * zz - xx - yy) * sh13 +\\n                    SH_C3[5] * z * (xx - yy) * sh14 +\\n                    SH_C3[6] * x * (xx - 3.0 * yy) * sh15;\\n            }\\n        }\\n    }\\n\\n    if(renderOnlyHarmonics) {\\n        vColor = harmonicsScale * harmonics;\\n    } else {\\n        vColor += harmonics;\\n    }\\n    \\n    vColor.rgb = clamp(vColor.rgb, vec3(0.), vec3(1.));\\n\\n    if(renderLoD) {\\n        //Test the LOD\\n        int LOD = int(getLOD( nodePosition, int(vnStart), float(level) ));\\n        switch ( LOD ) {\\n            case 0:\\n                vColor.rgb = vec3(1., 0., 0.);\\n            break;\\n            case 1:\\n                vColor.rgb = vec3(0., 1., 0.);\\n            break;\\n            case 2:\\n                vColor.rgb = vec3(0., 0., 1.);\\n            break;\\n            case 3:\\n                vColor.rgb = vec3(1., 0., 1.);\\n            break;\\n            case 4:\\n                vColor.rgb = vec3(1., 1., 0.);\\n            break;\\n            case 5:\\n                vColor.rgb = vec3(0., 1., 1.);\\n            break;\\n            case 6:\\n                vColor.rgb = vec3(0.5, 0., 0.);\\n            break;\\n            case 7:\\n                vColor.rgb = vec3(0., 0.5, 0.);\\n            break;\\n            case 8:\\n                vColor.rgb = vec3(0.0, 0., 0.5);\\n            break;\\n            case 9:\\n                vColor.rgb = vec3(0.5, 0., 0.5);\\n            break;\\n            case 10:\\n                vColor.rgb = vec3(0.5, 0.5, 0.0);\\n            break;\\n            case 11:\\n                vColor.rgb = vec3(0.0, 0.5, 0.5);\\n            break;\\n            case 12:\\n                vColor.rgb = vec3(1., 1., 1.);\\n            break;\\n        }\\n    }\\n\\n\\tvOpacity = colorData.a;\\n}\\n\";","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Box3, Matrix4, Vector3 } from 'three';\n\nexport enum ClipMode {\n  DISABLED = 0,\n  CLIP_OUTSIDE = 1,\n  HIGHLIGHT_INSIDE = 2,\n  CLIP_HORIZONTALLY = 3,\n  CLIP_VERTICALLY = 4,\n  CLIP_INSIDE = 5,\n}\n\nexport interface IClipBox {\n  box: Box3;\n  inverse: Matrix4;\n  matrix: Matrix4;\n  position: Vector3;\n}\n","export enum PointSizeType {\n  FIXED = 0,\n  ATTENUATED = 1,\n  ADAPTIVE = 2,\n}\n\nexport enum PointShape {\n  SQUARE = 0,\n  CIRCLE = 1,\n  PARABOLOID = 2,\n}\n\nexport enum TreeType {\n  OCTREE = 0,\n  KDTREE = 1,\n}\n\nexport enum PointOpacityType {\n  FIXED = 0,\n  ATTENUATED = 1,\n}\n\nexport enum PointColorType {\n  RGB = 0,\n  COLOR = 1,\n  DEPTH = 2,\n  HEIGHT = 3,\n  ELEVATION = 3,\n  INTENSITY = 4,\n  INTENSITY_GRADIENT = 5,\n  LOD = 6,\n  LEVEL_OF_DETAIL = 6,\n  POINT_INDEX = 7,\n  CLASSIFICATION = 8,\n  RETURN_NUMBER = 9,\n  SOURCE = 10,\n  NORMAL = 11,\n  PHONG = 12,\n  RGB_HEIGHT = 13,\n  COMPOSITE = 50,\n}\n\nexport enum NormalFilteringMode {\n  ABSOLUTE_NORMAL_FILTERING_MODE = 1,\n  LESS_EQUAL_NORMAL_FILTERING_MODE = 2,\n  GREATER_NORMAL_FILTERING_MODE = 3,\n}\n\nexport enum PointCloudMixingMode {\n  CHECKBOARD = 1,\n  STRIPES = 2,\n}\n","import { ShaderMaterial, Texture } from 'three';\nimport { IUniform } from './types';\n\n// see http://john-chapman-graphics.blogspot.co.at/2013/01/ssao-tutorial.html\n\nexport interface IBlurMaterialUniforms {\n  [name: string]: IUniform<any>;\n  screenWidth: IUniform<number>;\n  screenHeight: IUniform<number>;\n  map: IUniform<Texture | null>;\n}\n\nexport class BlurMaterial extends ShaderMaterial {\n  vertexShader = require('./shaders/blur.vert');\n  fragmentShader = require('./shaders/blur.frag');\n  uniforms: IBlurMaterialUniforms = {\n    screenWidth: { type: 'f', value: 0 },\n    screenHeight: { type: 'f', value: 0 },\n    map: { type: 't', value: null },\n  };\n}\n","import { Color, Vector4 } from 'three';\n\nexport const DEFAULT_RGB_BRIGHTNESS = 0;\nexport const DEFAULT_RGB_CONTRAST = 0;\nexport const DEFAULT_RGB_GAMMA = 1;\nexport const DEFAULT_MAX_POINT_SIZE = 50;\nexport const DEFAULT_MIN_NODE_PIXEL_SIZE = 0;\nexport const DEFAULT_MIN_POINT_SIZE = 1;\nexport const DEFAULT_PICK_WINDOW_SIZE = 15;\nexport const DEFAULT_POINT_BUDGET = 3_000_000;\nexport const MAX_AMOUNT_OF_SPLATS = 5290000;\nexport const MAX_LOADS_TO_GPU = 50;\nexport const MAX_NUM_NODES_LOADING = 100;\nexport const MEMORY_SCALE = 2;\nexport const PERSPECTIVE_CAMERA = 'PerspectiveCamera';\nexport const COLOR_BLACK = new Color(0, 0, 0);\nexport const DEFAULT_HIGHLIGHT_COLOR = new Vector4(1, 0, 0, 1);\n","import { IPointCloudTreeNode } from '../types';\n\nexport function getIndexFromName(name: string) {\n  return parseInt(name.charAt(name.length - 1), 10);\n}\n\n/**\n * When passed to `[].sort`, sorts the array by level and index: r, r0, r3, r4, r01, r07, r30, ...\n */\nexport function byLevelAndIndex(a: IPointCloudTreeNode, b: IPointCloudTreeNode) {\n  const na = a.name;\n  const nb = b.name;\n  if (na.length !== nb.length) {\n    return na.length - nb.length;\n  } else if (na < nb) {\n    return -1;\n  } else if (na > nb) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function handleFailedRequest(response: Response): Response {\n  if (response.status !== 200) {\n    throw Error('Response error');\n  }\n  return response;\n}\n\nexport function handleEmptyBuffer(buffer: ArrayBuffer) {\n  if (!buffer || buffer.byteLength === 0) {\n    throw Error('Empty buffer');\n  }\n  return buffer;\n}\n","import { Vector4 } from 'three';\nimport { IClassification } from './types';\n\nexport const DEFAULT_CLASSIFICATION: IClassification = {\n  0: new Vector4(0.5, 0.5, 0.5, 1.0),\n  1: new Vector4(0.5, 0.5, 0.5, 1.0),\n  2: new Vector4(0.63, 0.32, 0.18, 1.0),\n  3: new Vector4(0.0, 1.0, 0.0, 1.0),\n  4: new Vector4(0.0, 0.8, 0.0, 1.0),\n  5: new Vector4(0.0, 0.6, 0.0, 1.0),\n  6: new Vector4(1.0, 0.66, 0.0, 1.0),\n  7: new Vector4(1.0, 0, 1.0, 1.0),\n  8: new Vector4(1.0, 0, 0.0, 1.0),\n  9: new Vector4(0.0, 0.0, 1.0, 1.0),\n  12: new Vector4(1.0, 1.0, 0.0, 1.0),\n  DEFAULT: new Vector4(0.3, 0.6, 0.6, 0.5),\n};\n","import { Color } from 'three';\nimport { IGradient } from '../types';\n\nexport const GRAYSCALE: IGradient = [\n  [0, new Color(0, 0, 0)],\n  [1, new Color(1, 1, 1)],\n];\n","import { Color } from 'three';\nimport { IGradient } from '../types';\n\nexport const INFERNO: IGradient = [\n  [0.0, new Color(0.077, 0.042, 0.206)],\n  [0.1, new Color(0.225, 0.036, 0.388)],\n  [0.2, new Color(0.373, 0.074, 0.432)],\n  [0.3, new Color(0.522, 0.128, 0.42)],\n  [0.4, new Color(0.665, 0.182, 0.37)],\n  [0.5, new Color(0.797, 0.255, 0.287)],\n  [0.6, new Color(0.902, 0.364, 0.184)],\n  [0.7, new Color(0.969, 0.516, 0.063)],\n  [0.8, new Color(0.988, 0.683, 0.072)],\n  [0.9, new Color(0.961, 0.859, 0.298)],\n  [1.0, new Color(0.988, 0.998, 0.645)],\n];\n","import { Color } from 'three';\nimport { IGradient } from '../types';\n\nexport const PLASMA: IGradient = [\n  [0.0, new Color(0.241, 0.015, 0.61)],\n  [0.1, new Color(0.387, 0.001, 0.654)],\n  [0.2, new Color(0.524, 0.025, 0.653)],\n  [0.3, new Color(0.651, 0.125, 0.596)],\n  [0.4, new Color(0.752, 0.227, 0.513)],\n  [0.5, new Color(0.837, 0.329, 0.431)],\n  [0.6, new Color(0.907, 0.435, 0.353)],\n  [0.7, new Color(0.963, 0.554, 0.272)],\n  [0.8, new Color(0.992, 0.681, 0.195)],\n  [0.9, new Color(0.987, 0.822, 0.144)],\n  [1.0, new Color(0.94, 0.975, 0.131)],\n];\n","import { Color } from 'three';\nimport { IGradient } from '../types';\n\nexport const RAINBOW: IGradient = [\n  [0, new Color(0.278, 0, 0.714)],\n  [1 / 6, new Color(0, 0, 1)],\n  [2 / 6, new Color(0, 1, 1)],\n  [3 / 6, new Color(0, 1, 0)],\n  [4 / 6, new Color(1, 1, 0)],\n  [5 / 6, new Color(1, 0.64, 0)],\n  [1, new Color(1, 0, 0)],\n];\n","import { Color } from 'three';\nimport { IGradient } from '../types';\n\n// From chroma spectral http://gka.github.io/chroma.js/\nexport const SPECTRAL: IGradient = [\n  [0, new Color(0.3686, 0.3098, 0.6353)],\n  [0.1, new Color(0.1961, 0.5333, 0.7412)],\n  [0.2, new Color(0.4, 0.7608, 0.6471)],\n  [0.3, new Color(0.6706, 0.8667, 0.6431)],\n  [0.4, new Color(0.902, 0.9608, 0.5961)],\n  [0.5, new Color(1.0, 1.0, 0.749)],\n  [0.6, new Color(0.9961, 0.8784, 0.5451)],\n  [0.7, new Color(0.9922, 0.6824, 0.3804)],\n  [0.8, new Color(0.9569, 0.4275, 0.2627)],\n  [0.9, new Color(0.8353, 0.2431, 0.3098)],\n  [1, new Color(0.6196, 0.0039, 0.2588)],\n];\n","import { Color } from 'three';\nimport { IGradient } from '../types';\n\nexport const VIRIDIS: IGradient = [\n  [0.0, new Color(0.267, 0.005, 0.329)],\n  [0.1, new Color(0.283, 0.141, 0.458)],\n  [0.2, new Color(0.254, 0.265, 0.53)],\n  [0.3, new Color(0.207, 0.372, 0.553)],\n  [0.4, new Color(0.164, 0.471, 0.558)],\n  [0.5, new Color(0.128, 0.567, 0.551)],\n  [0.6, new Color(0.135, 0.659, 0.518)],\n  [0.7, new Color(0.267, 0.749, 0.441)],\n  [0.8, new Color(0.478, 0.821, 0.318)],\n  [0.9, new Color(0.741, 0.873, 0.15)],\n  [1.0, new Color(0.993, 0.906, 0.144)],\n];\n","import { Color } from 'three';\nimport { IGradient } from '../types';\n\nexport const YELLOW_GREEN: IGradient = [\n  [0, new Color(0.1647, 0.2824, 0.3451)],\n  [0.1, new Color(0.1338, 0.3555, 0.4227)],\n  [0.2, new Color(0.061, 0.4319, 0.4864)],\n  [0.3, new Color(0.0, 0.5099, 0.5319)],\n  [0.4, new Color(0.0, 0.5881, 0.5569)],\n  [0.5, new Color(0.137, 0.665, 0.5614)],\n  [0.6, new Color(0.2906, 0.7395, 0.5477)],\n  [0.7, new Color(0.4453, 0.8099, 0.5201)],\n  [0.8, new Color(0.6102, 0.8748, 0.485)],\n  [0.9, new Color(0.7883, 0.9323, 0.4514)],\n  [1, new Color(0.9804, 0.9804, 0.4314)],\n];\n","import {\n  CanvasTexture,\n  Color,\n  DataTexture,\n  LinearFilter,\n  NearestFilter,\n  RGBAFormat,\n  Texture,\n} from 'three';\nimport { IClassification, IGradient } from '../materials/types';\n\nexport function generateDataTexture(width: number, height: number, color: Color): Texture {\n  const size = width * height;\n  const data = new Uint8Array(4 * size);\n\n  const r = Math.floor(color.r * 255);\n  const g = Math.floor(color.g * 255);\n  const b = Math.floor(color.b * 255);\n\n  for (let i = 0; i < size; i++) {\n    data[i * 3] = r;\n    data[i * 3 + 1] = g;\n    data[i * 3 + 2] = b;\n  }\n\n  const texture = new DataTexture(data, width, height, RGBAFormat);\n  texture.needsUpdate = true;\n  texture.magFilter = NearestFilter;\n\n  return texture;\n}\n\nexport function generateGradientTexture(gradient: IGradient): Texture {\n  const size = 64;\n\n  const canvas = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n\n  const context = canvas.getContext('2d')!;\n\n  context.rect(0, 0, size, size);\n  const ctxGradient = context.createLinearGradient(0, 0, size, size);\n\n  for (let i = 0; i < gradient.length; i++) {\n    const step = gradient[i];\n    ctxGradient.addColorStop(step[0], `#${step[1].getHexString()}`);\n  }\n\n  context.fillStyle = ctxGradient;\n  context.fill();\n\n  const texture = new CanvasTexture(canvas);\n  texture.needsUpdate = true;\n\n  texture.minFilter = LinearFilter;\n  // textureImage = texture.image;\n\n  return texture;\n}\n\nexport function generateClassificationTexture(classification: IClassification): Texture {\n  const width = 256;\n  const height = 256;\n  const size = width * height;\n\n  const data = new Uint8Array(4 * size);\n\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const i = x + width * y;\n\n      let color;\n      if (classification[x]) {\n        color = classification[x];\n      } else if (classification[x % 32]) {\n        color = classification[x % 32];\n      } else {\n        color = classification.DEFAULT;\n      }\n\n      data[4 * i + 0] = 255 * color.x;\n      data[4 * i + 1] = 255 * color.y;\n      data[4 * i + 2] = 255 * color.z;\n      data[4 * i + 3] = 255 * color.w;\n    }\n  }\n\n  const texture = new DataTexture(data, width, height, RGBAFormat);\n  texture.magFilter = NearestFilter;\n  texture.needsUpdate = true;\n\n  return texture;\n}\n","import {\n  AdditiveBlending,\n  BufferGeometry,\n  Camera,\n  Color,\n  GLSL3,\n  LessEqualDepth,\n  Material,\n  NearestFilter,\n  NoBlending,\n  PerspectiveCamera,\n  RawShaderMaterial,\n  Scene,\n  Texture,\n  Vector2,\n  Vector3,\n  Vector4,\n  WebGLRenderer,\n} from 'three';\nimport {\n  DEFAULT_HIGHLIGHT_COLOR,\n  DEFAULT_MAX_POINT_SIZE,\n  DEFAULT_MIN_POINT_SIZE,\n  DEFAULT_RGB_BRIGHTNESS,\n  DEFAULT_RGB_CONTRAST,\n  DEFAULT_RGB_GAMMA,\n  PERSPECTIVE_CAMERA,\n} from '../constants';\nimport { PointCloudOctree } from '../point-cloud-octree';\nimport { PointCloudOctreeNode } from '../point-cloud-octree-node';\nimport { byLevelAndIndex } from '../utils/utils';\nimport { DEFAULT_CLASSIFICATION } from './classification';\nimport { ClipMode, IClipBox } from './clipping';\nimport {\n  NormalFilteringMode,\n  PointCloudMixingMode,\n  PointColorType,\n  PointOpacityType,\n  PointShape,\n  PointSizeType,\n  TreeType,\n} from './enums';\nimport { SPECTRAL } from './gradients';\nimport {\n  generateClassificationTexture,\n  generateDataTexture,\n  generateGradientTexture,\n} from './texture-generation';\nimport { IClassification, IGradient, IUniform } from './types';\n\nexport interface IPointCloudMaterialParameters {\n  size: number;\n  minSize: number;\n  maxSize: number;\n  treeType: TreeType;\n  colorRgba: boolean;\n}\n\nexport interface IPointCloudMaterialUniforms {\n  bbSize: IUniform<[number, number, number]>;\n  blendDepthSupplement: IUniform<number>;\n  blendHardness: IUniform<number>;\n  classificationLUT: IUniform<Texture>;\n  clipBoxCount: IUniform<number>;\n  clipBoxes: IUniform<Float32Array>;\n  clipExtent: IUniform<[number, number, number, number]>;\n  depthMap: IUniform<Texture | null>;\n  diffuse: IUniform<[number, number, number]>;\n  fov: IUniform<number>;\n  gradient: IUniform<Texture>;\n  heightMax: IUniform<number>;\n  heightMin: IUniform<number>;\n  intensityBrightness: IUniform<number>;\n  intensityContrast: IUniform<number>;\n  intensityGamma: IUniform<number>;\n  intensityRange: IUniform<[number, number]>;\n  level: IUniform<number>;\n  maxSize: IUniform<number>;\n  minSize: IUniform<number>;\n  octreeSize: IUniform<number>;\n  opacity: IUniform<number>;\n  pcIndex: IUniform<number>;\n  rgbBrightness: IUniform<number>;\n  rgbContrast: IUniform<number>;\n  rgbGamma: IUniform<number>;\n  screenHeight: IUniform<number>;\n  screenWidth: IUniform<number>;\n  size: IUniform<number>;\n  spacing: IUniform<number>;\n  toModel: IUniform<number[]>;\n  transition: IUniform<number>;\n  uColor: IUniform<Color>;\n  visibleNodes: IUniform<Texture>;\n  vnStart: IUniform<number>;\n  wClassification: IUniform<number>;\n  wElevation: IUniform<number>;\n  wIntensity: IUniform<number>;\n  wReturnNumber: IUniform<number>;\n  wRGB: IUniform<number>;\n  wSourceID: IUniform<number>;\n  opacityAttenuation: IUniform<number>;\n  filterByNormalThreshold: IUniform<number>;\n  highlightedPointCoordinate: IUniform<Vector3>;\n  highlightedPointColor: IUniform<Vector4>;\n  enablePointHighlighting: IUniform<boolean>;\n  highlightedPointScale: IUniform<number>;\n  normalFilteringMode: IUniform<number>;\n  backgroundMap: IUniform<Texture | null>;\n  pointCloudID: IUniform<number>;\n  pointCloudMixAngle: IUniform<number>;\n  stripeDistanceX: IUniform<number>;\n  stripeDistanceY: IUniform<number>;\n  stripeDivisorX: IUniform<number>;\n  stripeDivisorY: IUniform<number>;\n  pointCloudMixingMode: IUniform<number>;\n  renderDepth: IUniform<boolean>;\n}\n\nconst TREE_TYPE_DEFS = {\n  [TreeType.OCTREE]: 'tree_type_octree',\n  [TreeType.KDTREE]: 'tree_type_kdtree',\n};\n\nconst SIZE_TYPE_DEFS = {\n  [PointSizeType.FIXED]: 'fixed_point_size',\n  [PointSizeType.ATTENUATED]: 'attenuated_point_size',\n  [PointSizeType.ADAPTIVE]: 'adaptive_point_size',\n};\n\nconst OPACITY_DEFS = {\n  [PointOpacityType.ATTENUATED]: 'attenuated_opacity',\n  [PointOpacityType.FIXED]: 'fixed_opacity',\n};\n\nconst SHAPE_DEFS = {\n  [PointShape.SQUARE]: 'square_point_shape',\n  [PointShape.CIRCLE]: 'circle_point_shape',\n  [PointShape.PARABOLOID]: 'paraboloid_point_shape',\n};\n\nconst COLOR_DEFS = {\n  [PointColorType.RGB]: 'color_type_rgb',\n  [PointColorType.COLOR]: 'color_type_color',\n  [PointColorType.DEPTH]: 'color_type_depth',\n  [PointColorType.HEIGHT]: 'color_type_height',\n  [PointColorType.INTENSITY]: 'color_type_intensity',\n  [PointColorType.INTENSITY_GRADIENT]: 'color_type_intensity_gradient',\n  [PointColorType.LOD]: 'color_type_lod',\n  [PointColorType.POINT_INDEX]: 'color_type_point_index',\n  [PointColorType.CLASSIFICATION]: 'color_type_classification',\n  [PointColorType.RETURN_NUMBER]: 'color_type_return_number',\n  [PointColorType.SOURCE]: 'color_type_source',\n  [PointColorType.NORMAL]: 'color_type_normal',\n  [PointColorType.PHONG]: 'color_type_phong',\n  [PointColorType.RGB_HEIGHT]: 'color_type_rgb_height',\n  [PointColorType.COMPOSITE]: 'color_type_composite',\n};\n\nconst CLIP_MODE_DEFS = {\n  [ClipMode.DISABLED]: 'clip_disabled',\n  [ClipMode.CLIP_OUTSIDE]: 'clip_outside',\n  [ClipMode.HIGHLIGHT_INSIDE]: 'clip_highlight_inside',\n  [ClipMode.CLIP_HORIZONTALLY]: 'clip_horizontally',\n  [ClipMode.CLIP_VERTICALLY]: 'clip_vertically',\n  [ClipMode.CLIP_INSIDE]: 'clip_inside',\n};\n\nexport class PointCloudMaterial extends RawShaderMaterial {\n  private static helperVec3 = new Vector3();\n  private static helperVec2 = new Vector2();\n\n  /**\n   * Use the drawing buffer size instead of the dom client width and height when passing the screen height and screen width uniforms to the\n   * shader. This is useful if you have offscreen canvases (which in some browsers return 0 as client width and client height).\n   */\n  useDrawingBufferSize = false;\n  lights = false;\n  fog = false;\n  colorRgba = false;\n  numClipBoxes: number = 0;\n  clipBoxes: IClipBox[] = [];\n  visibleNodesTexture: Texture | undefined;\n  visibleNodeTextureOffsets = new Map<string, number>();\n\n  private _gradient = SPECTRAL;\n  private gradientTexture: Texture | undefined = generateGradientTexture(this._gradient);\n\n  private _classification: IClassification = DEFAULT_CLASSIFICATION;\n  private classificationTexture: Texture | undefined = generateClassificationTexture(\n    this._classification,\n  );\n\n  uniforms: IPointCloudMaterialUniforms & Record<string, IUniform<any>> = {\n    bbSize: makeUniform('fv', [0, 0, 0] as [number, number, number]),\n    blendDepthSupplement: makeUniform('f', 0.0),\n    blendHardness: makeUniform('f', 2.0),\n    classificationLUT: makeUniform('t', this.classificationTexture || new Texture()),\n    clipBoxCount: makeUniform('f', 0),\n    clipBoxes: makeUniform('Matrix4fv', [] as any),\n    clipExtent: makeUniform('fv', [0.0, 0.0, 1.0, 1.0] as [number, number, number, number]),\n    depthMap: makeUniform('t', null),\n    diffuse: makeUniform('fv', [1, 1, 1] as [number, number, number]),\n    fov: makeUniform('f', 1.0),\n    gradient: makeUniform('t', this.gradientTexture || new Texture()),\n    heightMax: makeUniform('f', 1.0),\n    heightMin: makeUniform('f', 0.0),\n    intensityBrightness: makeUniform('f', 0),\n    intensityContrast: makeUniform('f', 0),\n    intensityGamma: makeUniform('f', 1),\n    intensityRange: makeUniform('fv', [0, 65000] as [number, number]),\n    isLeafNode: makeUniform('b', 0),\n    level: makeUniform('f', 0.0),\n    maxSize: makeUniform('f', DEFAULT_MAX_POINT_SIZE),\n    minSize: makeUniform('f', DEFAULT_MIN_POINT_SIZE),\n    octreeSize: makeUniform('f', 0),\n    opacity: makeUniform('f', 1.0),\n    pcIndex: makeUniform('f', 0),\n    rgbBrightness: makeUniform('f', DEFAULT_RGB_BRIGHTNESS),\n    rgbContrast: makeUniform('f', DEFAULT_RGB_CONTRAST),\n    rgbGamma: makeUniform('f', DEFAULT_RGB_GAMMA),\n    screenHeight: makeUniform('f', 1.0),\n    screenWidth: makeUniform('f', 1.0),\n    size: makeUniform('f', 1),\n    spacing: makeUniform('f', 1.0),\n    toModel: makeUniform('Matrix4f', []),\n    transition: makeUniform('f', 0.5),\n    uColor: makeUniform('c', new Color(0xffffff)),\n    // @ts-ignore\n    visibleNodes: makeUniform('t', this.visibleNodesTexture || new Texture()),\n    vnStart: makeUniform('f', 0.0),\n    wClassification: makeUniform('f', 0),\n    wElevation: makeUniform('f', 0),\n    wIntensity: makeUniform('f', 0),\n    wReturnNumber: makeUniform('f', 0),\n    wRGB: makeUniform('f', 1),\n    wSourceID: makeUniform('f', 0),\n    opacityAttenuation: makeUniform('f', 1),\n    filterByNormalThreshold: makeUniform('f', 0),\n    highlightedPointCoordinate: makeUniform('fv', new Vector3()),\n    highlightedPointColor: makeUniform('fv', DEFAULT_HIGHLIGHT_COLOR.clone()),\n    enablePointHighlighting: makeUniform('b', true),\n    highlightedPointScale: makeUniform('f', 2.0),\n    backgroundMap: makeUniform('t', null),\n    normalFilteringMode: makeUniform('i', NormalFilteringMode.ABSOLUTE_NORMAL_FILTERING_MODE),\n    pointCloudID: makeUniform('f', 2),\n    pointCloudMixingMode: makeUniform('i', PointCloudMixingMode.CHECKBOARD),\n    stripeDistanceX: makeUniform('f', 5),\n    stripeDistanceY: makeUniform('f', 5),\n    stripeDivisorX: makeUniform('f', 2),\n    stripeDivisorY: makeUniform('f', 2),\n    pointCloudMixAngle: makeUniform('f', 31),\n    renderDepth: makeUniform('bool', false),\n  };\n\n  @uniform('bbSize') bbSize!: [number, number, number];\n  @uniform('clipExtent') clipExtent!: [number, number, number, number];\n  @uniform('depthMap') depthMap!: Texture | undefined;\n  @uniform('fov') fov!: number;\n  @uniform('heightMax') heightMax!: number;\n  @uniform('heightMin') heightMin!: number;\n  @uniform('intensityBrightness') intensityBrightness!: number;\n  @uniform('intensityContrast') intensityContrast!: number;\n  @uniform('intensityGamma') intensityGamma!: number;\n  @uniform('intensityRange') intensityRange!: [number, number];\n  @uniform('maxSize') maxSize!: number;\n  @uniform('minSize') minSize!: number;\n  @uniform('octreeSize') octreeSize!: number;\n  @uniform('opacity', true) opacity!: number;\n  @uniform('rgbBrightness', true) rgbBrightness!: number;\n  @uniform('rgbContrast', true) rgbContrast!: number;\n  @uniform('rgbGamma', true) rgbGamma!: number;\n  @uniform('screenHeight') screenHeight!: number;\n  @uniform('screenWidth') screenWidth!: number;\n  @uniform('size') size!: number;\n  @uniform('spacing') spacing!: number;\n  @uniform('transition') transition!: number;\n  @uniform('uColor') color!: Color;\n  @uniform('wClassification') weightClassification!: number;\n  @uniform('wElevation') weightElevation!: number;\n  @uniform('wIntensity') weightIntensity!: number;\n  @uniform('wReturnNumber') weightReturnNumber!: number;\n  @uniform('wRGB') weightRGB!: number;\n  @uniform('wSourceID') weightSourceID!: number;\n  @uniform('opacityAttenuation') opacityAttenuation!: number;\n  @uniform('filterByNormalThreshold') filterByNormalThreshold!: number;\n  @uniform('highlightedPointCoordinate') highlightedPointCoordinate!: Vector3;\n  @uniform('highlightedPointColor') highlightedPointColor!: Vector4;\n  @uniform('enablePointHighlighting') enablePointHighlighting!: boolean;\n  @uniform('highlightedPointScale') highlightedPointScale!: number;\n  @uniform('normalFilteringMode') normalFilteringMode!: number;\n  @uniform('backgroundMap') backgroundMap!: Texture | undefined;\n  @uniform('pointCloudID') pointCloudID!: number;\n  @uniform('pointCloudMixingMode') pointCloudMixingMode!: number;\n  @uniform('stripeDistanceX') stripeDistanceX!: number;\n  @uniform('stripeDistanceY') stripeDistanceY!: number;\n  @uniform('stripeDivisorX') stripeDivisorX!: number;\n  @uniform('stripeDivisorY') stripeDivisorY!: number;\n  @uniform('pointCloudMixAngle') pointCloudMixAngle!: number;\n  @uniform('renderDepth') renderDepth!: boolean;\n\n  @requiresShaderUpdate() useClipBox: boolean = false;\n  @requiresShaderUpdate() weighted: boolean = false;\n  @requiresShaderUpdate() pointColorType: PointColorType = PointColorType.RGB;\n  @requiresShaderUpdate() pointSizeType: PointSizeType = PointSizeType.ADAPTIVE;\n  @requiresShaderUpdate() clipMode: ClipMode = ClipMode.DISABLED;\n  @requiresShaderUpdate() useEDL: boolean = false;\n  @requiresShaderUpdate() shape: PointShape = PointShape.SQUARE;\n  @requiresShaderUpdate() treeType: TreeType = TreeType.OCTREE;\n  @requiresShaderUpdate() pointOpacityType: PointOpacityType = PointOpacityType.FIXED;\n  @requiresShaderUpdate() useFilterByNormal: boolean = false;\n  @requiresShaderUpdate() useTextureBlending: boolean = false;\n  @requiresShaderUpdate() usePointCloudMixing: boolean = false;\n  @requiresShaderUpdate() highlightPoint: boolean = false;\n\n  attributes = {\n    position: { type: 'fv', value: [] },\n    color: { type: 'fv', value: [] },\n    normal: { type: 'fv', value: [] },\n    intensity: { type: 'f', value: [] },\n    classification: { type: 'f', value: [] },\n    returnNumber: { type: 'f', value: [] },\n    numberOfReturns: { type: 'f', value: [] },\n    pointSourceID: { type: 'f', value: [] },\n    indices: { type: 'fv', value: [] },\n  };\n\n  constructor(parameters: Partial<IPointCloudMaterialParameters> = {}) {\n    super();\n\n    this.glslVersion = GLSL3;\n\n    const tex = (this.visibleNodesTexture = generateDataTexture(2048, 1, new Color(0xffffff)));\n    tex.minFilter = NearestFilter;\n    tex.magFilter = NearestFilter;\n    this.setUniform('visibleNodes', tex);\n\n    this.treeType = getValid(parameters.treeType, TreeType.OCTREE);\n    this.size = getValid(parameters.size, 1.0);\n    this.minSize = getValid(parameters.minSize, 2.0);\n    this.maxSize = getValid(parameters.maxSize, 50.0);\n\n    this.colorRgba = Boolean(parameters.colorRgba);\n\n    this.classification = DEFAULT_CLASSIFICATION;\n\n    this.defaultAttributeValues.normal = [0, 0, 0];\n    this.defaultAttributeValues.classification = [0, 0, 0];\n    this.defaultAttributeValues.indices = [0, 0, 0, 0];\n\n    this.vertexColors = true;\n\n    this.updateShaderSource();\n  }\n\n  dispose(): void {\n    super.dispose();\n\n    if (this.gradientTexture) {\n      this.gradientTexture.dispose();\n      this.gradientTexture = undefined;\n    }\n\n    if (this.visibleNodesTexture) {\n      this.visibleNodesTexture.dispose();\n      this.visibleNodesTexture = undefined;\n    }\n\n    this.clearVisibleNodeTextureOffsets();\n\n    if (this.classificationTexture) {\n      this.classificationTexture.dispose();\n      this.classificationTexture = undefined;\n    }\n\n    if (this.depthMap) {\n      this.depthMap.dispose();\n      this.depthMap = undefined;\n    }\n    if (this.backgroundMap) {\n      this.backgroundMap.dispose();\n      this.backgroundMap = undefined;\n    }\n  }\n\n  clearVisibleNodeTextureOffsets(): void {\n    this.visibleNodeTextureOffsets.clear();\n  }\n\n  updateShaderSource(): void {\n    this.vertexShader = this.applyDefines(require('./shaders/pointcloud.vert').default);\n    this.fragmentShader = this.applyDefines(require('./shaders/pointcloud.frag').default);\n\n    if (this.opacity === 1.0) {\n      this.blending = NoBlending;\n      this.transparent = false;\n      this.depthTest = true;\n      this.depthWrite = true;\n      this.depthFunc = LessEqualDepth;\n    } else if (this.opacity < 1.0 && !this.useEDL) {\n      this.blending = AdditiveBlending;\n      this.transparent = true;\n      this.depthTest = false;\n      this.depthWrite = true;\n    }\n\n    if (this.weighted) {\n      this.blending = AdditiveBlending;\n      this.transparent = true;\n      this.depthTest = true;\n      this.depthWrite = false;\n      this.depthFunc = LessEqualDepth;\n    }\n\n    this.needsUpdate = true;\n  }\n\n  applyDefines(shaderSrc: string): string {\n    const parts: string[] = [];\n\n    function define(value: string | undefined) {\n      if (value) {\n        parts.push(`#define ${value}`);\n      }\n    }\n\n    define(TREE_TYPE_DEFS[this.treeType]);\n    define(SIZE_TYPE_DEFS[this.pointSizeType]);\n    define(SHAPE_DEFS[this.shape]);\n    define(COLOR_DEFS[this.pointColorType]);\n    define(CLIP_MODE_DEFS[this.clipMode]);\n    define(OPACITY_DEFS[this.pointOpacityType]);\n\n    // We only perform gamma and brightness/contrast calculations per point if values are specified.\n    if (\n      this.rgbGamma !== DEFAULT_RGB_GAMMA ||\n      this.rgbBrightness !== DEFAULT_RGB_BRIGHTNESS ||\n      this.rgbContrast !== DEFAULT_RGB_CONTRAST\n    ) {\n      define('use_rgb_gamma_contrast_brightness');\n    }\n\n    if (this.useFilterByNormal) {\n      define('use_filter_by_normal');\n    }\n\n    if (this.useEDL) {\n      define('use_edl');\n    }\n\n    if (this.weighted) {\n      define('weighted_splats');\n    }\n\n    if (this.numClipBoxes > 0) {\n      define('use_clip_box');\n    }\n\n    if (this.highlightPoint) {\n      define('highlight_point');\n    }\n\n    if (this.useTextureBlending) {\n      define('use_texture_blending');\n    }\n\n    if (this.usePointCloudMixing) {\n      define('use_point_cloud_mixing');\n    }\n\n    if (this.colorRgba) {\n      define('color_rgba');\n    }\n\n    define('MAX_POINT_LIGHTS 0');\n    define('MAX_DIR_LIGHTS 0');\n\n    parts.push(shaderSrc);\n\n    return parts.join('\\n');\n  }\n\n  setPointCloudMixingMode(mode: PointCloudMixingMode) {\n    this.pointCloudMixingMode = mode;\n  }\n\n  getPointCloudMixingMode(): PointCloudMixingMode {\n    if (this.pointCloudMixingMode === PointCloudMixingMode.STRIPES) {\n      return PointCloudMixingMode.STRIPES;\n    }\n\n    return PointCloudMixingMode.CHECKBOARD;\n  }\n\n  setClipBoxes(clipBoxes: IClipBox[]): void {\n    if (!clipBoxes) {\n      return;\n    }\n\n    this.clipBoxes = clipBoxes;\n\n    const doUpdate =\n      this.numClipBoxes !== clipBoxes.length && (clipBoxes.length === 0 || this.numClipBoxes === 0);\n\n    this.numClipBoxes = clipBoxes.length;\n    this.setUniform('clipBoxCount', this.numClipBoxes);\n\n    if (doUpdate) {\n      this.updateShaderSource();\n    }\n\n    const clipBoxesLength = this.numClipBoxes * 16;\n    const clipBoxesArray = new Float32Array(clipBoxesLength);\n\n    for (let i = 0; i < this.numClipBoxes; i++) {\n      clipBoxesArray.set(clipBoxes[i].inverse.elements, 16 * i);\n    }\n\n    for (let i = 0; i < clipBoxesLength; i++) {\n      if (isNaN(clipBoxesArray[i])) {\n        clipBoxesArray[i] = Infinity;\n      }\n    }\n\n    this.setUniform('clipBoxes', clipBoxesArray);\n  }\n\n  get gradient(): IGradient {\n    return this._gradient;\n  }\n\n  set gradient(value: IGradient) {\n    if (this._gradient !== value) {\n      this._gradient = value;\n      this.gradientTexture = generateGradientTexture(this._gradient);\n      this.setUniform('gradient', this.gradientTexture);\n    }\n  }\n\n  get classification(): IClassification {\n    return this._classification;\n  }\n\n  set classification(value: IClassification) {\n    const copy: IClassification = {} as any;\n    for (const key of Object.keys(value)) {\n      copy[key] = value[key].clone();\n    }\n\n    let isEqual = false;\n    if (this._classification === undefined) {\n      isEqual = false;\n    } else {\n      isEqual = Object.keys(copy).length === Object.keys(this._classification).length;\n\n      for (const key of Object.keys(copy)) {\n        isEqual = isEqual && this._classification[key] !== undefined;\n        isEqual = isEqual && copy[key].equals(this._classification[key]);\n      }\n    }\n\n    if (!isEqual) {\n      this._classification = copy;\n      this.recomputeClassification();\n    }\n  }\n\n  private recomputeClassification(): void {\n    this.classificationTexture = generateClassificationTexture(this._classification);\n    this.setUniform('classificationLUT', this.classificationTexture);\n  }\n\n  get elevationRange(): [number, number] {\n    return [this.heightMin, this.heightMax];\n  }\n\n  set elevationRange(value: [number, number]) {\n    this.heightMin = value[0];\n    this.heightMax = value[1];\n  }\n\n  getUniform<K extends keyof IPointCloudMaterialUniforms>(\n    name: K,\n  ): IPointCloudMaterialUniforms[K]['value'] {\n    return this.uniforms === undefined ? (undefined as any) : this.uniforms[name].value;\n  }\n\n  setUniform<K extends keyof IPointCloudMaterialUniforms>(\n    name: K,\n    value: IPointCloudMaterialUniforms[K]['value'],\n  ): void {\n    if (this.uniforms === undefined) {\n      return;\n    }\n\n    const uObj = this.uniforms[name];\n\n    if (uObj.type === 'c') {\n      (uObj.value as Color).copy(value as Color);\n    } else if (value !== uObj.value) {\n      uObj.value = value;\n    }\n  }\n\n  updateMaterial(\n    octree: PointCloudOctree,\n    visibleNodes: PointCloudOctreeNode[],\n    camera: Camera,\n    renderer: WebGLRenderer,\n  ): void {\n    const pixelRatio = renderer.getPixelRatio();\n\n    if (camera.type === PERSPECTIVE_CAMERA) {\n      this.fov = (camera as PerspectiveCamera).fov * (Math.PI / 180);\n    } else {\n      this.fov = Math.PI / 2; // will result in slope = 1 in the shader\n    }\n    const renderTarget = renderer.getRenderTarget();\n    if (renderTarget !== null) {\n      this.screenWidth = renderTarget.width;\n      this.screenHeight = renderTarget.height;\n    } else {\n      this.screenWidth = renderer.domElement.clientWidth * pixelRatio;\n      this.screenHeight = renderer.domElement.clientHeight * pixelRatio;\n    }\n\n    if (this.useDrawingBufferSize) {\n      renderer.getDrawingBufferSize(PointCloudMaterial.helperVec2);\n      this.screenWidth = PointCloudMaterial.helperVec2.width;\n      this.screenHeight = PointCloudMaterial.helperVec2.height;\n    }\n\n    const maxScale = Math.max(octree.scale.x, octree.scale.y, octree.scale.z);\n    this.spacing = octree.pcoGeometry.spacing * maxScale;\n    this.octreeSize = octree.pcoGeometry.boundingBox.getSize(PointCloudMaterial.helperVec3).x;\n    if (\n      this.pointSizeType === PointSizeType.ADAPTIVE ||\n      this.pointColorType === PointColorType.LOD\n    ) {\n      this.updateVisibilityTextureData(visibleNodes);\n    }\n  }\n\n  private updateVisibilityTextureData(nodes: PointCloudOctreeNode[]) {\n    nodes.sort(byLevelAndIndex);\n\n    const data = new Uint8Array(nodes.length * 4);\n    const offsetsToChild = new Array(nodes.length).fill(Infinity);\n\n    this.visibleNodeTextureOffsets.clear();\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      this.visibleNodeTextureOffsets.set(node.name, i);\n\n      if (i > 0) {\n        const parentName = node.name.slice(0, -1);\n        const parentOffset = this.visibleNodeTextureOffsets.get(parentName)!;\n        const parentOffsetToChild = i - parentOffset;\n\n        offsetsToChild[parentOffset] = Math.min(offsetsToChild[parentOffset], parentOffsetToChild);\n\n        // tslint:disable:no-bitwise\n        const offset = parentOffset * 4;\n        data[offset] = data[offset] | (1 << node.index);\n        data[offset + 1] = offsetsToChild[parentOffset] >> 8;\n        data[offset + 2] = offsetsToChild[parentOffset] % 256;\n        // tslint:enable:no-bitwise\n      }\n\n      data[i * 4 + 3] = node.name.length;\n    }\n\n    const texture = this.visibleNodesTexture;\n    if (texture) {\n      texture.image.data.set(data);\n      texture.needsUpdate = true;\n    }\n  }\n\n  static makeOnBeforeRender(\n    octree: PointCloudOctree,\n    node: PointCloudOctreeNode,\n    pcIndex?: number,\n  ) {\n    return (\n      _renderer: WebGLRenderer,\n      _scene: Scene,\n      _camera: Camera,\n      _geometry: BufferGeometry,\n      material: Material,\n    ) => {\n      const pointCloudMaterial = material as PointCloudMaterial;\n      const materialUniforms = pointCloudMaterial.uniforms;\n\n      materialUniforms.level.value = node.level;\n      materialUniforms.isLeafNode.value = node.isLeafNode;\n\n      const vnStart = pointCloudMaterial.visibleNodeTextureOffsets.get(node.name);\n      if (vnStart !== undefined) {\n        materialUniforms.vnStart.value = vnStart;\n      }\n\n      materialUniforms.pcIndex.value =\n        pcIndex !== undefined ? pcIndex : octree.visibleNodes.indexOf(node);\n\n      // Note: when changing uniforms in onBeforeRender, the flag uniformsNeedUpdate has to be\n      // set to true to instruct ThreeJS to upload them. See also\n      // https://github.com/mrdoob/three.js/issues/9870#issuecomment-368750182.\n\n      // Remove the cast to any after updating to Three.JS >= r113\n      (material as any) /*ShaderMaterial*/.uniformsNeedUpdate = true;\n    };\n  }\n}\n\nfunction makeUniform<T>(type: string, value: T): IUniform<T> {\n  return { type, value };\n}\n\nfunction getValid<T>(a: T | undefined, b: T): T {\n  return a === undefined ? b : a;\n}\n\n// tslint:disable:no-invalid-this\nfunction uniform<K extends keyof IPointCloudMaterialUniforms>(\n  uniformName: K,\n  requireSrcUpdate: boolean = false,\n): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol): void => {\n    Object.defineProperty(target, propertyKey, {\n      get() {\n        return this.getUniform(uniformName);\n      },\n      set(value: any) {\n        if (value !== this.getUniform(uniformName)) {\n          this.setUniform(uniformName, value);\n          if (requireSrcUpdate) {\n            this.updateShaderSource();\n          }\n        }\n      },\n    });\n  };\n}\n\nfunction requiresShaderUpdate() {\n  return (target: Object, propertyKey: string | symbol): void => {\n    const fieldName = `_${propertyKey.toString()}`;\n\n    Object.defineProperty(target, propertyKey, {\n      get() {\n        return this[fieldName];\n      },\n      set(value: any) {\n        if (value !== this[fieldName]) {\n          this[fieldName] = value;\n          this.updateShaderSource();\n        }\n      },\n    });\n  };\n}\n","// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\n\nexport enum PointAttributeName {\n  POSITION_CARTESIAN = 0, // float x, y, z;\n  COLOR_PACKED = 1, // byte r, g, b, a; \tI = [0,1]\n  COLOR_FLOATS_1 = 2, // float r, g, b; \t\tI = [0,1]\n  COLOR_FLOATS_255 = 3, // float r, g, b; \t\tI = [0,255]\n  NORMAL_FLOATS = 4, // float x, y, z;\n  FILLER = 5,\n  INTENSITY = 6,\n  CLASSIFICATION = 7,\n  NORMAL_SPHEREMAPPED = 8,\n  NORMAL_OCT16 = 9,\n  NORMAL = 10,\n}\n\nexport interface PointAttributeType {\n  ordinal: number;\n  size: number;\n}\n\nexport const POINT_ATTRIBUTE_TYPES: Record<string, PointAttributeType> = {\n  DATA_TYPE_DOUBLE: { ordinal: 0, size: 8 },\n  DATA_TYPE_FLOAT: { ordinal: 1, size: 4 },\n  DATA_TYPE_INT8: { ordinal: 2, size: 1 },\n  DATA_TYPE_UINT8: { ordinal: 3, size: 1 },\n  DATA_TYPE_INT16: { ordinal: 4, size: 2 },\n  DATA_TYPE_UINT16: { ordinal: 5, size: 2 },\n  DATA_TYPE_INT32: { ordinal: 6, size: 4 },\n  DATA_TYPE_UINT32: { ordinal: 7, size: 4 },\n  DATA_TYPE_INT64: { ordinal: 8, size: 8 },\n  DATA_TYPE_UINT64: { ordinal: 9, size: 8 },\n};\n\nexport interface IPointAttribute {\n  name: PointAttributeName;\n  type: PointAttributeType;\n  numElements: number;\n  byteSize: number;\n}\n\nexport interface IPointAttributes {\n  attributes: IPointAttribute[];\n  byteSize: number;\n  size: number;\n}\n\nfunction makePointAttribute(\n  name: PointAttributeName,\n  type: PointAttributeType,\n  numElements: number,\n): IPointAttribute {\n  return {\n    name,\n    type,\n    numElements,\n    byteSize: numElements * type.size,\n  };\n}\n\nconst RGBA_PACKED = makePointAttribute(\n  PointAttributeName.COLOR_PACKED,\n  POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8,\n  4,\n);\n\nexport const POINT_ATTRIBUTES = {\n  POSITION_CARTESIAN: makePointAttribute(\n    PointAttributeName.POSITION_CARTESIAN,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT,\n    3,\n  ),\n  RGBA_PACKED,\n  COLOR_PACKED: RGBA_PACKED,\n  RGB_PACKED: makePointAttribute(\n    PointAttributeName.COLOR_PACKED,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8,\n    3,\n  ),\n  NORMAL_FLOATS: makePointAttribute(\n    PointAttributeName.NORMAL_FLOATS,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT,\n    3,\n  ),\n  FILLER_1B: makePointAttribute(\n    PointAttributeName.FILLER,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8,\n    1,\n  ),\n  INTENSITY: makePointAttribute(\n    PointAttributeName.INTENSITY,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT16,\n    1,\n  ),\n  CLASSIFICATION: makePointAttribute(\n    PointAttributeName.CLASSIFICATION,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8,\n    1,\n  ),\n  NORMAL_SPHEREMAPPED: makePointAttribute(\n    PointAttributeName.NORMAL_SPHEREMAPPED,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8,\n    2,\n  ),\n  NORMAL_OCT16: makePointAttribute(\n    PointAttributeName.NORMAL_OCT16,\n    POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8,\n    2,\n  ),\n  NORMAL: makePointAttribute(PointAttributeName.NORMAL, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\n};\n\nexport type PointAttributeStringName = keyof typeof POINT_ATTRIBUTES;\n\nexport class PointAttributes implements IPointAttributes {\n  attributes: IPointAttribute[] = [];\n  byteSize: number = 0;\n  size: number = 0;\n\n  constructor(pointAttributeNames: PointAttributeStringName[] = []) {\n    for (let i = 0; i < pointAttributeNames.length; i++) {\n      const pointAttributeName = pointAttributeNames[i];\n      const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\n      this.attributes.push(pointAttribute);\n      this.byteSize += pointAttribute.byteSize;\n      this.size++;\n    }\n  }\n\n  add(pointAttribute: IPointAttribute): void {\n    this.attributes.push(pointAttribute);\n    this.byteSize += pointAttribute.byteSize;\n    this.size++;\n  }\n\n  hasColors(): boolean {\n    return this.attributes.find(isColorAttribute) !== undefined;\n  }\n\n  hasNormals(): boolean {\n    return this.attributes.find(isNormalAttribute) !== undefined;\n  }\n}\n\nfunction isColorAttribute({ name }: IPointAttribute): boolean {\n  return name === PointAttributeName.COLOR_PACKED;\n}\n\nfunction isNormalAttribute({ name }: IPointAttribute): boolean {\n  return (\n    name === PointAttributeName.NORMAL_SPHEREMAPPED ||\n    name === PointAttributeName.NORMAL_FLOATS ||\n    name === PointAttributeName.NORMAL ||\n    name === PointAttributeName.NORMAL_OCT16\n  );\n}\n","import { Box3, Matrix4, Vector3 } from 'three';\n\n/**\n * adapted from mhluska at https://github.com/mrdoob/three.js/issues/1561\n */\nexport function computeTransformedBoundingBox(box: Box3, transform: Matrix4): Box3 {\n  return new Box3().setFromPoints([\n    new Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\n    new Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\n    new Vector3(box.max.x, box.min.y, box.min.z).applyMatrix4(transform),\n    new Vector3(box.min.x, box.max.y, box.min.z).applyMatrix4(transform),\n    new Vector3(box.min.x, box.min.y, box.max.z).applyMatrix4(transform),\n    new Vector3(box.min.x, box.max.y, box.max.z).applyMatrix4(transform),\n    new Vector3(box.max.x, box.max.y, box.min.z).applyMatrix4(transform),\n    new Vector3(box.max.x, box.min.y, box.max.z).applyMatrix4(transform),\n    new Vector3(box.max.x, box.max.y, box.max.z).applyMatrix4(transform),\n  ]);\n}\n\nexport function createChildAABB(aabb: Box3, index: number): Box3 {\n  const min = aabb.min.clone();\n  const max = aabb.max.clone();\n  const size = new Vector3().subVectors(max, min);\n\n  // tslint:disable-next-line:no-bitwise\n  if ((index & 0b0001) > 0) {\n    min.z += size.z / 2;\n  } else {\n    max.z -= size.z / 2;\n  }\n\n  // tslint:disable-next-line:no-bitwise\n  if ((index & 0b0010) > 0) {\n    min.y += size.y / 2;\n  } else {\n    max.y -= size.y / 2;\n  }\n\n  // tslint:disable-next-line:no-bitwise\n  if ((index & 0b0100) > 0) {\n    min.x += size.x / 2;\n  } else {\n    max.x -= size.x / 2;\n  }\n\n  return new Box3(min, max);\n}\n","/**\n * Adapted from Potree.js http://potree.org\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\n */\n\nimport { Box3, BufferGeometry, EventDispatcher, Sphere, Vector3 } from 'three';\nimport { PointCloudOctreeGeometry } from './point-cloud-octree-geometry';\nimport { IPointCloudGeometryNode } from './types';\nimport { createChildAABB } from './utils/bounds';\nimport { getIndexFromName, handleEmptyBuffer, handleFailedRequest } from './utils/utils';\n\nexport interface NodeData {\n  children: number;\n  numPoints: number;\n  name: string;\n}\n\nconst NODE_STRIDE = 5;\n\nexport class PointCloudOctreeGeometryNode\n  extends EventDispatcher\n  implements IPointCloudGeometryNode\n{\n  id: number = PointCloudOctreeGeometryNode.idCount++;\n  name: string;\n  pcoGeometry: PointCloudOctreeGeometry;\n  index: number;\n  level: number = 0;\n  spacing: number = 0;\n  hasChildren: boolean = false;\n  readonly children: ReadonlyArray<PointCloudOctreeGeometryNode | null> = [\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n  ];\n  boundingBox: Box3;\n  tightBoundingBox: Box3;\n  boundingSphere: Sphere;\n  mean: Vector3 = new Vector3();\n  numPoints: number = 0;\n  geometry: BufferGeometry | undefined;\n  loaded: boolean = false;\n  loading: boolean = false;\n  failed: boolean = false;\n  parent: PointCloudOctreeGeometryNode | null = null;\n  oneTimeDisposeHandlers: (() => void)[] = [];\n  isLeafNode: boolean = true;\n  readonly isTreeNode: boolean = false;\n  readonly isGeometryNode: boolean = true;\n\n  private static idCount = 0;\n\n  constructor(name: string, pcoGeometry: PointCloudOctreeGeometry, boundingBox: Box3) {\n    super();\n\n    this.name = name;\n    this.index = getIndexFromName(name);\n    this.pcoGeometry = pcoGeometry;\n    this.boundingBox = boundingBox;\n    this.tightBoundingBox = boundingBox.clone();\n    this.boundingSphere = boundingBox.getBoundingSphere(new Sphere());\n  }\n\n  dispose(): void {\n    if (!this.geometry || !this.parent) {\n      return;\n    }\n\n    this.geometry.dispose();\n    this.geometry = undefined;\n    this.loaded = false;\n\n    this.oneTimeDisposeHandlers.forEach((handler) => handler());\n    this.oneTimeDisposeHandlers = [];\n  }\n\n  /**\n   * Gets the url of the binary file for this node.\n   */\n  getUrl(): string {\n    const geometry = this.pcoGeometry;\n    const version = geometry.loader.version;\n    const pathParts = [geometry.octreeDir];\n\n    if (geometry.loader && version.equalOrHigher('1.5')) {\n      pathParts.push(this.getHierarchyBaseUrl());\n      pathParts.push(this.name);\n    } else if (version.equalOrHigher('1.4')) {\n      pathParts.push(this.name);\n    } else if (version.upTo('1.3')) {\n      pathParts.push(this.name);\n    }\n\n    return pathParts.join('/');\n  }\n\n  /**\n   * Gets the url of the hierarchy file for this node.\n   */\n  getHierarchyUrl(): string {\n    return `${this.pcoGeometry.octreeDir}/${this.getHierarchyBaseUrl()}/${this.name}.hrc`;\n  }\n\n  /**\n   * Adds the specified node as a child of the current node.\n   *\n   * @param child\n   *    The node which is to be added as a child.\n   */\n  addChild(child: PointCloudOctreeGeometryNode): void {\n    (this.children as any)[child.index] = child;\n    this.isLeafNode = false;\n    child.parent = this;\n  }\n\n  /**\n   * Calls the specified callback for the current node (if includeSelf is set to true) and all its\n   * children.\n   *\n   * @param cb\n   *    The function which is to be called for each node.\n   */\n  traverse(cb: (node: PointCloudOctreeGeometryNode) => void, includeSelf = true): void {\n    const stack: PointCloudOctreeGeometryNode[] = includeSelf ? [this] : [];\n\n    let current: PointCloudOctreeGeometryNode | undefined;\n\n    while ((current = stack.pop()) !== undefined) {\n      cb(current);\n\n      for (const child of current.children) {\n        if (child !== null) {\n          stack.push(child);\n        }\n      }\n    }\n  }\n\n  load(): Promise<void> {\n    if (!this.canLoad()) {\n      return Promise.resolve();\n    }\n\n    this.loading = true;\n    this.pcoGeometry.numNodesLoading++;\n    this.pcoGeometry.needsUpdate = true;\n\n    let promise: Promise<void>;\n\n    if (\n      this.pcoGeometry.loader.version.equalOrHigher('1.5') &&\n      this.level % this.pcoGeometry.hierarchyStepSize === 0 &&\n      this.hasChildren\n    ) {\n      promise = this.loadHierachyThenPoints();\n    } else {\n      promise = this.loadPoints();\n    }\n\n    return promise.catch((reason) => {\n      this.loading = false;\n      this.failed = true;\n      this.pcoGeometry.numNodesLoading--;\n      throw reason;\n    });\n  }\n\n  private canLoad(): boolean {\n    return (\n      !this.loading &&\n      !this.loaded &&\n      !this.pcoGeometry.disposed &&\n      !this.pcoGeometry.loader.disposed &&\n      this.pcoGeometry.numNodesLoading < this.pcoGeometry.maxNumNodesLoading\n    );\n  }\n\n  private loadPoints(): Promise<void> {\n    this.pcoGeometry.needsUpdate = true;\n    return this.pcoGeometry.loader.load(this);\n  }\n\n  private loadHierachyThenPoints(): Promise<any> {\n    if (this.level % this.pcoGeometry.hierarchyStepSize !== 0) {\n      return Promise.resolve();\n    }\n\n    return Promise.resolve(this.pcoGeometry.loader.getUrl(this.getHierarchyUrl()))\n      .then((url) => this.pcoGeometry.xhrRequest(url, { mode: 'cors' }))\n      .then((res) => handleFailedRequest(res))\n      .then((okRes) => okRes.arrayBuffer())\n      .then((buffer) => handleEmptyBuffer(buffer))\n      .then((okBuffer) => this.loadHierarchy(this, okBuffer));\n  }\n\n  /**\n   * Gets the url of the folder where the hierarchy is, relative to the octreeDir.\n   */\n  private getHierarchyBaseUrl(): string {\n    const hierarchyStepSize = this.pcoGeometry.hierarchyStepSize;\n    const indices = this.name.substr(1);\n    const numParts = Math.floor(indices.length / hierarchyStepSize);\n\n    let path = 'r/';\n    for (let i = 0; i < numParts; i++) {\n      path += `${indices.substr(i * hierarchyStepSize, hierarchyStepSize)}/`;\n    }\n\n    return path.slice(0, -1);\n  }\n\n  // tslint:disable:no-bitwise\n  private loadHierarchy(node: PointCloudOctreeGeometryNode, buffer: ArrayBuffer) {\n    const view = new DataView(buffer);\n\n    const firstNodeData = this.getNodeData(node.name, 0, view);\n    node.numPoints = firstNodeData.numPoints;\n\n    // Nodes which need be visited.\n    const stack: NodeData[] = [firstNodeData];\n    // Nodes which have already been decoded. We will take nodes from the stack and place them here.\n    const decoded: NodeData[] = [];\n\n    let offset = NODE_STRIDE;\n    while (stack.length > 0) {\n      const stackNodeData = stack.shift()!;\n\n      // From the last bit, all the way to the 8th one from the right.\n      let mask = 1;\n      for (let i = 0; i < 8 && offset + 1 < buffer.byteLength; i++) {\n        if ((stackNodeData.children & mask) !== 0) {\n          const nodeData = this.getNodeData(stackNodeData.name + i, offset, view);\n\n          decoded.push(nodeData); // Node is decoded.\n          stack.push(nodeData); // Need to check its children.\n\n          offset += NODE_STRIDE; // Move over to the next node in the buffer.\n        }\n\n        mask = mask * 2;\n      }\n    }\n\n    node.pcoGeometry.needsUpdate = true;\n\n    // Map containing all the nodes.\n    const nodes = new Map<string, PointCloudOctreeGeometryNode>();\n    nodes.set(node.name, node);\n    decoded.forEach((nodeData) => this.addNode(nodeData, node.pcoGeometry, nodes));\n\n    node.loadPoints();\n  }\n\n  // tslint:enable:no-bitwise\n\n  private getNodeData(name: string, offset: number, view: DataView): NodeData {\n    const children = view.getUint8(offset);\n    const numPoints = view.getUint32(offset + 1, true);\n    return { children: children, numPoints: numPoints, name };\n  }\n\n  addNode(\n    { name, numPoints, children }: NodeData,\n    pco: PointCloudOctreeGeometry,\n    nodes: Map<string, PointCloudOctreeGeometryNode>,\n  ): void {\n    const index = getIndexFromName(name);\n    const parentName = name.substring(0, name.length - 1);\n    const parentNode = nodes.get(parentName)!;\n    const level = name.length - 1;\n    const boundingBox = createChildAABB(parentNode.boundingBox, index);\n\n    const node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n    node.level = level;\n    node.numPoints = numPoints;\n    node.hasChildren = children > 0;\n    node.spacing = pco.spacing / Math.pow(2, level);\n\n    parentNode.addChild(node);\n    nodes.set(name, node);\n  }\n}\n","import { Box3, Vector3 } from 'three';\nimport { BinaryLoader, XhrRequest } from './loading';\nimport { PointAttributes } from './point-attributes';\nimport { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';\n\nexport class PointCloudOctreeGeometry {\n  disposed: boolean = false;\n  needsUpdate: boolean = true;\n  root!: PointCloudOctreeGeometryNode;\n  octreeDir: string = '';\n  hierarchyStepSize: number = -1;\n  nodes: Record<string, PointCloudOctreeGeometryNode> = {};\n  numNodesLoading: number = 0;\n  maxNumNodesLoading: number = 3;\n  spacing: number = 0;\n  pointAttributes: PointAttributes = new PointAttributes([]);\n  projection: any = null;\n  url: string | null = null;\n\n  constructor(\n    public loader: BinaryLoader,\n    public boundingBox: Box3,\n    public tightBoundingBox: Box3,\n    public offset: Vector3,\n    public xhrRequest: XhrRequest,\n  ) {}\n\n  dispose(): void {\n    this.loader.dispose();\n    this.root.traverse((node) => node.dispose());\n\n    this.disposed = true;\n  }\n\n  addNodeLoadedCallback(callback: (node: PointCloudOctreeGeometryNode) => void): void {\n    this.loader.callbacks.push(callback);\n  }\n\n  clearNodeLoadedCallbacks(): void {\n    this.loader.callbacks = [];\n  }\n}\n","import { Box3, BufferGeometry, EventDispatcher, Object3D, Points, Sphere } from 'three';\nimport { IPointCloudGeometryNode, IPointCloudTreeNode } from './types';\n\nexport class PointCloudOctreeNode extends EventDispatcher implements IPointCloudTreeNode {\n  geometryNode: IPointCloudGeometryNode;\n  sceneNode: Points;\n  pcIndex: number | undefined = undefined;\n  boundingBoxNode: Object3D | null = null;\n  readonly children: (IPointCloudTreeNode | null)[];\n  readonly loaded = true;\n  readonly isTreeNode: boolean = true;\n  readonly isGeometryNode: boolean = false;\n\n  constructor(geometryNode: IPointCloudGeometryNode, sceneNode: Points) {\n    super();\n\n    this.geometryNode = geometryNode;\n    this.sceneNode = sceneNode;\n    this.children = geometryNode.children.slice();\n  }\n\n  dispose(): void {\n    this.geometryNode.dispose();\n  }\n\n  disposeSceneNode(): void {\n    const node = this.sceneNode;\n\n    if (node.geometry instanceof BufferGeometry) {\n      const attributes = node.geometry.attributes;\n\n      // tslint:disable-next-line:forin\n      for (const key in attributes) {\n        delete (attributes[key] as any).array;\n        delete attributes[key];\n      }\n\n      node.geometry.dispose();\n      node.geometry = undefined as any;\n    }\n  }\n\n  traverse(cb: (node: IPointCloudTreeNode) => void, includeSelf?: boolean): void {\n    this.geometryNode.traverse(cb, includeSelf);\n  }\n\n  get id() {\n    return this.geometryNode.id;\n  }\n\n  get name() {\n    return this.geometryNode.name;\n  }\n\n  get level(): number {\n    return this.geometryNode.level;\n  }\n\n  get isLeafNode(): boolean {\n    return this.geometryNode.isLeafNode;\n  }\n\n  get numPoints(): number {\n    return this.geometryNode.numPoints;\n  }\n\n  get index() {\n    return this.geometryNode.index;\n  }\n\n  get boundingSphere(): Sphere {\n    return this.geometryNode.boundingSphere;\n  }\n\n  get boundingBox(): Box3 {\n    return this.geometryNode.boundingBox;\n  }\n\n  get spacing() {\n    return this.geometryNode.spacing;\n  }\n}\n","export function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(min, value), max);\n}\n","import {\n  BufferAttribute,\n  Camera,\n  Color,\n  LinearFilter,\n  NearestFilter,\n  NoBlending,\n  Points,\n  Ray,\n  RGBAFormat,\n  Scene,\n  Sphere,\n  Vector3,\n  Vector4,\n  WebGLRenderer,\n  WebGLRenderTarget,\n} from 'three';\nimport { COLOR_BLACK, DEFAULT_PICK_WINDOW_SIZE } from './constants';\nimport { ClipMode, PointCloudMaterial, PointColorType } from './materials';\nimport { PointCloudOctree } from './point-cloud-octree';\nimport { PointCloudOctreeNode } from './point-cloud-octree-node';\nimport { PickPoint, PointCloudHit } from './types';\nimport { clamp } from './utils/math';\n\nexport interface PickParams {\n  pickWindowSize: number;\n  pickOutsideClipRegion: boolean;\n  /**\n   * If provided, the picking will use this pixel position instead of the `Ray` passed to the `pick`\n   * method.\n   */\n  pixelPosition: Vector3;\n  /**\n   * Function which gets called after a picking material has been created and setup and before the\n   * point cloud is rendered into the picking render target. This gives applications a chance to\n   * customize the renderTarget and the material.\n   *\n   * @param material\n   *    The pick material.\n   * @param renterTarget\n   *    The render target used for picking.\n   */\n  onBeforePickRender: (material: PointCloudMaterial, renterTarget: WebGLRenderTarget) => void;\n}\n\ninterface IPickState {\n  renderTarget: WebGLRenderTarget;\n  material: PointCloudMaterial;\n  scene: Scene;\n}\n\ninterface RenderedNode {\n  node: PointCloudOctreeNode;\n  octree: PointCloudOctree;\n}\n\nexport class PointCloudOctreePicker {\n  private static readonly helperVec3 = new Vector3();\n  private static readonly helperSphere = new Sphere();\n  private static readonly clearColor = new Color();\n  private pickState: IPickState | undefined;\n\n  dispose() {\n    if (this.pickState) {\n      this.pickState.material.dispose();\n      this.pickState.renderTarget.dispose();\n    }\n  }\n\n  pick(\n    renderer: WebGLRenderer,\n    camera: Camera,\n    ray: Ray,\n    octrees: PointCloudOctree[],\n    params: Partial<PickParams> = {},\n  ): PickPoint | null {\n    if (octrees.length === 0) {\n      return null;\n    }\n\n    const pickState = this.pickState\n      ? this.pickState\n      : (this.pickState = PointCloudOctreePicker.getPickState());\n\n    const pickMaterial = pickState.material;\n\n    const pixelRatio = renderer.getPixelRatio();\n    const width = Math.ceil(renderer.domElement.clientWidth * pixelRatio);\n    const height = Math.ceil(renderer.domElement.clientHeight * pixelRatio);\n    PointCloudOctreePicker.updatePickRenderTarget(this.pickState, width, height);\n\n    const pixelPosition = PointCloudOctreePicker.helperVec3; // Use helper vector to prevent extra allocations.\n\n    if (params.pixelPosition) {\n      pixelPosition.copy(params.pixelPosition);\n    } else {\n      pixelPosition.addVectors(ray.origin, ray.direction).project(camera);\n      pixelPosition.x = (pixelPosition.x + 1) * width * 0.5;\n      pixelPosition.y = (pixelPosition.y + 1) * height * 0.5;\n    }\n\n    const pickWndSize = Math.floor(\n      (params.pickWindowSize || DEFAULT_PICK_WINDOW_SIZE) * pixelRatio,\n    );\n    const halfPickWndSize = (pickWndSize - 1) / 2;\n    const x = Math.floor(clamp(pixelPosition.x - halfPickWndSize, 0, width));\n    const y = Math.floor(clamp(pixelPosition.y - halfPickWndSize, 0, height));\n\n    PointCloudOctreePicker.prepareRender(renderer, x, y, pickWndSize, pickMaterial, pickState);\n\n    const renderedNodes = PointCloudOctreePicker.render(\n      renderer,\n      camera,\n      pickMaterial,\n      octrees,\n      ray,\n      pickState,\n      params,\n    );\n\n    // Cleanup\n    pickMaterial.clearVisibleNodeTextureOffsets();\n\n    // Read back image and decode hit point\n    const pixels = PointCloudOctreePicker.readPixels(renderer, x, y, pickWndSize);\n    const hit = PointCloudOctreePicker.findHit(pixels, pickWndSize);\n    return PointCloudOctreePicker.getPickPoint(hit, renderedNodes);\n  }\n\n  private static prepareRender(\n    renderer: WebGLRenderer,\n    x: number,\n    y: number,\n    pickWndSize: number,\n    pickMaterial: PointCloudMaterial,\n    pickState: IPickState,\n  ) {\n    // Render the intersected nodes onto the pick render target, clipping to a small pick window.\n    renderer.setScissor(x, y, pickWndSize, pickWndSize);\n    renderer.setScissorTest(true);\n    renderer.state.buffers.depth.setTest(pickMaterial.depthTest);\n    renderer.state.buffers.depth.setMask(pickMaterial.depthWrite);\n    renderer.state.setBlending(NoBlending);\n\n    renderer.setRenderTarget(pickState.renderTarget);\n\n    // Save the current clear color and clear the renderer with black color and alpha 0.\n    renderer.getClearColor(this.clearColor);\n    const oldClearAlpha = renderer.getClearAlpha();\n    renderer.setClearColor(COLOR_BLACK, 0);\n    renderer.clear(true, true, true);\n    renderer.setClearColor(this.clearColor, oldClearAlpha);\n  }\n\n  private static render(\n    renderer: WebGLRenderer,\n    camera: Camera,\n    pickMaterial: PointCloudMaterial,\n    octrees: PointCloudOctree[],\n    ray: Ray,\n    pickState: IPickState,\n    params: Partial<PickParams>,\n  ): RenderedNode[] {\n    const renderedNodes: RenderedNode[] = [];\n    for (const octree of octrees) {\n      // Get all the octree nodes which intersect the picking ray. We only need to render those.\n      const nodes = PointCloudOctreePicker.nodesOnRay(octree, ray);\n      if (!nodes.length) {\n        continue;\n      }\n\n      PointCloudOctreePicker.updatePickMaterial(pickMaterial, octree.material, params);\n      pickMaterial.updateMaterial(octree, nodes, camera, renderer);\n\n      if (params.onBeforePickRender) {\n        params.onBeforePickRender(pickMaterial, pickState.renderTarget);\n      }\n\n      // Create copies of the nodes so we can render them differently than in the normal point cloud.\n      pickState.scene.children = PointCloudOctreePicker.createTempNodes(\n        octree,\n        nodes,\n        pickMaterial,\n        renderedNodes.length,\n      );\n\n      renderer.render(pickState.scene, camera);\n\n      nodes.forEach((node) => renderedNodes.push({ node, octree }));\n    }\n    return renderedNodes;\n  }\n\n  private static nodesOnRay(octree: PointCloudOctree, ray: Ray): PointCloudOctreeNode[] {\n    const nodesOnRay: PointCloudOctreeNode[] = [];\n\n    const rayClone = ray.clone();\n    for (const node of octree.visibleNodes) {\n      const sphere = PointCloudOctreePicker.helperSphere\n        .copy(node.boundingSphere)\n        .applyMatrix4(octree.matrixWorld);\n\n      if (rayClone.intersectsSphere(sphere)) {\n        nodesOnRay.push(node);\n      }\n    }\n\n    return nodesOnRay;\n  }\n\n  private static readPixels(\n    renderer: WebGLRenderer,\n    x: number,\n    y: number,\n    pickWndSize: number,\n  ): Uint8Array {\n    // Read the pixel from the pick render target.\n    const pixels = new Uint8Array(4 * pickWndSize * pickWndSize);\n    renderer.readRenderTargetPixels(\n      renderer.getRenderTarget()!,\n      x,\n      y,\n      pickWndSize,\n      pickWndSize,\n      pixels,\n    );\n    renderer.setScissorTest(false);\n    renderer.setRenderTarget(null!);\n    return pixels;\n  }\n\n  private static createTempNodes(\n    octree: PointCloudOctree,\n    nodes: PointCloudOctreeNode[],\n    pickMaterial: PointCloudMaterial,\n    nodeIndexOffset: number,\n  ): Points[] {\n    const tempNodes: Points[] = [];\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const sceneNode = node.sceneNode;\n      const tempNode = new Points(sceneNode.geometry, pickMaterial);\n      tempNode.matrix = sceneNode.matrix;\n      tempNode.matrixWorld = sceneNode.matrixWorld;\n      tempNode.matrixAutoUpdate = false;\n      tempNode.frustumCulled = false;\n      const nodeIndex = nodeIndexOffset + i + 1;\n      if (nodeIndex > 255) {\n        console.error('More than 255 nodes for pick are not supported.');\n      }\n      tempNode.onBeforeRender = PointCloudMaterial.makeOnBeforeRender(octree, node, nodeIndex);\n\n      tempNodes.push(tempNode);\n    }\n    return tempNodes;\n  }\n\n  private static updatePickMaterial(\n    pickMaterial: PointCloudMaterial,\n    nodeMaterial: PointCloudMaterial,\n    params: Partial<PickParams>,\n  ): void {\n    pickMaterial.pointSizeType = nodeMaterial.pointSizeType;\n    pickMaterial.shape = nodeMaterial.shape;\n    pickMaterial.size = nodeMaterial.size;\n    pickMaterial.minSize = nodeMaterial.minSize;\n    pickMaterial.maxSize = nodeMaterial.maxSize;\n    pickMaterial.classification = nodeMaterial.classification;\n    pickMaterial.useFilterByNormal = nodeMaterial.useFilterByNormal;\n    pickMaterial.filterByNormalThreshold = nodeMaterial.filterByNormalThreshold;\n\n    if (params.pickOutsideClipRegion) {\n      pickMaterial.clipMode = ClipMode.DISABLED;\n    } else {\n      pickMaterial.clipMode = nodeMaterial.clipMode;\n      pickMaterial.clipExtent = nodeMaterial.clipExtent;\n      pickMaterial.setClipBoxes(\n        nodeMaterial.clipMode === ClipMode.CLIP_OUTSIDE ? nodeMaterial.clipBoxes : [],\n      );\n    }\n  }\n\n  private static updatePickRenderTarget(\n    pickState: IPickState,\n    width: number,\n    height: number,\n  ): void {\n    if (pickState.renderTarget.width === width && pickState.renderTarget.height === height) {\n      return;\n    }\n\n    pickState.renderTarget.dispose();\n    pickState.renderTarget = PointCloudOctreePicker.makePickRenderTarget();\n    pickState.renderTarget.setSize(width, height);\n  }\n\n  private static makePickRenderTarget() {\n    return new WebGLRenderTarget(1, 1, {\n      minFilter: LinearFilter,\n      magFilter: NearestFilter,\n      format: RGBAFormat,\n    });\n  }\n\n  private static findHit(pixels: Uint8Array, pickWndSize: number): PointCloudHit | null {\n    const ibuffer = new Uint32Array(pixels.buffer);\n\n    // Find closest hit inside pixelWindow boundaries\n    let min = Number.MAX_VALUE;\n    let hit: PointCloudHit | null = null;\n    for (let u = 0; u < pickWndSize; u++) {\n      for (let v = 0; v < pickWndSize; v++) {\n        const offset = u + v * pickWndSize;\n        const distance =\n          Math.pow(u - (pickWndSize - 1) / 2, 2) + Math.pow(v - (pickWndSize - 1) / 2, 2);\n\n        const pcIndex = pixels[4 * offset + 3];\n        pixels[4 * offset + 3] = 0;\n        const pIndex = ibuffer[offset];\n\n        if (pcIndex > 0 && distance < min) {\n          hit = {\n            pIndex: pIndex,\n            pcIndex: pcIndex - 1,\n          };\n          min = distance;\n        }\n      }\n    }\n    return hit;\n  }\n\n  private static getPickPoint(hit: PointCloudHit | null, nodes: RenderedNode[]): PickPoint | null {\n    if (!hit) {\n      return null;\n    }\n\n    const point: PickPoint = {};\n\n    const points = nodes[hit.pcIndex] && nodes[hit.pcIndex].node.sceneNode;\n    if (!points) {\n      return null;\n    }\n\n    point.pointCloud = nodes[hit.pcIndex].octree;\n\n    const attributes: BufferAttribute[] = (points.geometry as any).attributes;\n\n    for (const property in attributes) {\n      if (!attributes.hasOwnProperty(property)) {\n        continue;\n      }\n\n      const values = attributes[property];\n\n      // tslint:disable-next-line:prefer-switch\n      if (property === 'position') {\n        PointCloudOctreePicker.addPositionToPickPoint(point, hit, values, points);\n      } else if (property === 'normal') {\n        PointCloudOctreePicker.addNormalToPickPoint(point, hit, values, points);\n      } else if (property === 'indices') {\n        // TODO\n      } else {\n        if (values.itemSize === 1) {\n          point[property] = values.array[hit.pIndex];\n        } else {\n          const value: number[] = [];\n          for (let j = 0; j < values.itemSize; j++) {\n            value.push(values.array[values.itemSize * hit.pIndex + j]);\n          }\n          point[property] = value;\n        }\n      }\n    }\n\n    return point;\n  }\n\n  private static addPositionToPickPoint(\n    point: PickPoint,\n    hit: PointCloudHit,\n    values: BufferAttribute,\n    points: Points,\n  ): void {\n    point.position = new Vector3()\n      .fromBufferAttribute(values, hit.pIndex)\n      .applyMatrix4(points.matrixWorld);\n  }\n\n  private static addNormalToPickPoint(\n    point: PickPoint,\n    hit: PointCloudHit,\n    values: BufferAttribute,\n    points: Points,\n  ): void {\n    const normal = new Vector3().fromBufferAttribute(values, hit.pIndex);\n    const normal4 = new Vector4(normal.x, normal.y, normal.z, 0).applyMatrix4(points.matrixWorld);\n    normal.set(normal4.x, normal4.y, normal4.z);\n\n    point.normal = normal;\n  }\n\n  private static getPickState() {\n    const scene = new Scene();\n    scene.matrixAutoUpdate = false;\n\n    const material = new PointCloudMaterial();\n    material.pointColorType = PointColorType.POINT_INDEX;\n\n    return {\n      renderTarget: PointCloudOctreePicker.makePickRenderTarget(),\n      material: material,\n      scene: scene,\n    };\n  }\n}\n","import { Box3, Sphere, Vector3 } from 'three';\nimport { OctreeGeometryNode } from './octree-geometry-node';\nimport { Metadata, NodeLoader } from './octree-loader';\nimport { PointAttributes } from './point-attributes';\n\nexport class OctreeGeometry {\n  boundingSphere: Sphere;\n  tightBoundingBox: Box3;\n  tightBoundingSphere: Sphere;\n  maxNumNodesLoading: number = Infinity;\n  numNodesLoading: number = 0;\n  needsUpdate: boolean = true;\n  disposed: boolean = false;\n  offset!: Vector3;\n  pointAttributes: PointAttributes | null = null;\n  projection?: Metadata['projection'];\n  root!: OctreeGeometryNode;\n  scale!: [number, number, number];\n  spacing: number = 0;\n  url: string | null = null;\n\n  constructor(\n    public loader: NodeLoader,\n    public boundingBox: Box3,\n  ) {\n    this.tightBoundingBox = this.boundingBox.clone();\n    this.boundingSphere = this.boundingBox.getBoundingSphere(new Sphere());\n    this.tightBoundingSphere = this.boundingSphere.clone();\n  }\n\n  dispose(): void {\n    this.root.traverse((node) => node.dispose());\n    this.disposed = true;\n  }\n}\n","import { Object3D } from 'three';\nimport { IPointCloudTreeNode } from './types';\n\nexport class PointCloudTree extends Object3D {\n  root: IPointCloudTreeNode | null = null;\n\n  initialized() {\n    return this.root !== null;\n  }\n}\n","function sortWorker(self: any) {\n  function toUint8Array(s: any) {\n    return new Uint8Array(atob(s).split('').map(charCodeAt));\n  }\n\n  function charCodeAt(c: string) {\n    return c.charCodeAt(0);\n  }\n\n  const MemoryPageSize = 65536;\n  const BytesPerFloat = 4;\n  const BytesPerInt = 4;\n  const DefaultSplatSortDistanceMapPrecision = 16;\n\n  // let centersReady = false;\n  let wasmInstance: any;\n  let wasmMemory: any;\n  let splatCount: number;\n  let indexesToSortOffset: number;\n  let sortedIndexesOffset: number;\n  let mappedDistancesOffset: number;\n  let frequenciesOffset: number;\n  let centersOffset: number;\n  let modelViewProjOffset: number;\n  let countsZero: any;\n  let distanceMapRange = 1 << DefaultSplatSortDistanceMapPrecision;\n  let indices: any;\n\n  self.onmessage = (e: any) => {\n    if (e.data.init) startWasmModule(e.data.splatCount);\n    if (e.data.sort) sort(e);\n  };\n\n  function sort(e: any) {\n    let centers = e.data.sort.centers;\n    let splats = e.data.sort.totalSplats;\n    let modelViewProj = e.data.sort.modelViewProj;\n\n    //pass the centers to the memory\n    new Float32Array(wasmMemory, centersOffset, centers.byteLength / BytesPerFloat).set(\n      new Float32Array(centers),\n    );\n\n    //pass the indices\n    new Int32Array(wasmMemory, 0, e.data.sort.indices.byteLength / BytesPerFloat).set(\n      e.data.sort.indices,\n    );\n\n    if (!countsZero) countsZero = new Uint32Array(distanceMapRange);\n    new Float32Array(wasmMemory, modelViewProjOffset, 16).set(modelViewProj);\n    new Uint32Array(wasmMemory, frequenciesOffset, distanceMapRange).set(countsZero);\n\n    wasmInstance.exports.sortIndexes(\n      indexesToSortOffset,\n      centersOffset,\n      mappedDistancesOffset,\n      frequenciesOffset,\n      modelViewProjOffset,\n      sortedIndexesOffset,\n      distanceMapRange,\n      splats,\n    );\n\n    const sortedIndexesC = new Int32Array(wasmMemory, sortedIndexesOffset, splats);\n\n    self.postMessage({\n      dataSorted: sortedIndexesC,\n    });\n  }\n\n  function startWasmModule(_splatCount: number) {\n    splatCount = _splatCount;\n\n    //Memory setup\n    const CENTERS_BYTES_PER_ENTRY = BytesPerFloat * 4;\n    const matrixSize = 16 * BytesPerFloat;\n\n    const memoryRequiredForIndexesToSort = splatCount * BytesPerInt;\n    const memoryRequiredForCenters = splatCount * CENTERS_BYTES_PER_ENTRY;\n    const memoryRequiredForModelViewProjectionMatrix = matrixSize;\n    const memoryRequiredForMappedDistances = splatCount * BytesPerInt;\n    const memoryRequiredForSortedIndexes = splatCount * BytesPerInt;\n    const memoryRequiredForIntermediateSortBuffers = distanceMapRange * BytesPerFloat * 2;\n    const extraMemory = MemoryPageSize * 32;\n\n    const totalRequiredMemory =\n      memoryRequiredForIndexesToSort +\n      memoryRequiredForCenters +\n      memoryRequiredForModelViewProjectionMatrix +\n      memoryRequiredForMappedDistances +\n      memoryRequiredForIntermediateSortBuffers +\n      memoryRequiredForSortedIndexes +\n      extraMemory;\n\n    const totalPagesRequired = Math.floor(totalRequiredMemory / MemoryPageSize) + 1;\n\n    //Memory used to the sorter\n    const sorterWasmImport = {\n      module: {},\n      env: {\n        memory: new WebAssembly.Memory({\n          initial: totalPagesRequired,\n          maximum: totalPagesRequired,\n        }),\n      },\n    };\n\n    /*\n\n        USED WASM2JS (https://github.com/thlorenz/wasm2js) to extract the base64 file required for the sorter.\n\n\n                    The process goes as follows\n                                |\n                                |\n                                v\n           sorter_test.cpp file (original C sorter file) \n                                |\n                                |\n                                v   \n      sorter_test.wasm file (compiled WASM file from the original C file)\n                                |\n                                |\n                                v\n      buffer string with base64 (obtained from sorter_test.wasm using WASM2JS)\n\n\n        */\n\n    const buffer = toUint8Array(\n      'AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAEPAmAAAGAIf39/f39/f38AAg8BA2VudgZtZW1vcnkCAAADAwIAAQcjAhFfX3dhc21fY2FsbF9jdG9ycwAAC3NvcnRJbmRleGVzAAEKhgMCAwABC/8CAgN/A30gBwRAIAQqAighCyAEKgIYIQwgBCoCCCENQfj///8HIQlBiICAgHghBANAIAIgCkECdCIIaiALIAEgACAIaigCAEEEdGoiCCoCCJQgDSAIKgIAlCAMIAgqAgSUkpJDAACARZT8ACIINgIAIAkgCCAIIAlKGyEJIAQgCCAEIAhKGyEEIApBAWoiCiAHRw0ACyAGQQFrsyAEsiAJspOVIQtBACEEA0AgAiAEQQJ0aiIBIAsgASgCACAJa7KU/AAiATYCACADIAFBAnRqIgEgASgCAEEBajYCACAEQQFqIgQgB0cNAAsLIAZBAk8EQCADKAIAIQlBASEEA0AgAyAEQQJ0aiIBIAEoAgAgCWoiCTYCACAEQQFqIgQgBkcNAAsLIAdBAEoEQCAHIQQDQCAFIAcgAyACIARBAWsiAUECdCIGaigCAEECdGoiCSgCACIIa0ECdGogACAGaigCADYCACAJIAhBAWs2AgAgBEEBSyEGIAEhBCAGDQALCws=',\n    );\n\n    WebAssembly.instantiate(buffer, sorterWasmImport).then((result) => {\n      //Save the instance of the WASM to use\n      wasmInstance = result.instance;\n\n      //Retrieve the memory used in the C module.\n      wasmMemory = sorterWasmImport.env.memory.buffer;\n\n      indices = new Int32Array(splatCount);\n      for (let i = 0; i < splatCount; i++) {\n        indices[i] = i;\n      }\n\n      //Define the offsets used to allocate the data inside memory.\n      indexesToSortOffset = 0;\n      centersOffset = indexesToSortOffset + memoryRequiredForIndexesToSort;\n      modelViewProjOffset = centersOffset + memoryRequiredForCenters;\n      mappedDistancesOffset = modelViewProjOffset + memoryRequiredForModelViewProjectionMatrix;\n      frequenciesOffset = mappedDistancesOffset + memoryRequiredForMappedDistances;\n      sortedIndexesOffset = frequenciesOffset + memoryRequiredForIntermediateSortBuffers;\n\n      self.postMessage({\n        sorterReady: true,\n      });\n    });\n  }\n}\n\nexport function createSortWorker(splatCount: number): Promise<Worker> {\n  return new Promise((resolve) => {\n    const worker = new Worker(\n      URL.createObjectURL(\n        new Blob(['(', sortWorker.toString(), ')(self)'], {\n          type: 'application/javascript',\n        }),\n      ),\n    );\n\n    //Setup the WASM module\n    worker.postMessage({\n      init: true,\n      splatCount,\n    });\n\n    worker.onmessage = (e: any) => {\n      //pass the centers information\n      if (e.data.sorterReady) {\n        resolve(worker);\n      }\n    };\n  });\n}\n","import {\n  Mesh,\n  Vector2,\n  RawShaderMaterial,\n  InstancedBufferGeometry,\n  BufferGeometry,\n  BufferAttribute,\n  Matrix4,\n  Vector3,\n  Camera,\n  Quaternion,\n  ShaderMaterial,\n  GLSL3,\n  Object3D,\n  Vector4,\n  NearestFilter,\n  RGBAIntegerFormat,\n  UnsignedIntType,\n  DataTexture,\n  RGBAFormat,\n  FloatType,\n  RGFormat,\n  RedIntegerFormat,\n  Texture,\n  FrontSide,\n} from 'three';\n\nimport { createSortWorker } from './workers/SortWorker';\nimport { PointCloudMaterial } from './materials';\n\nconst DELAYED_FRAMES = 2;\nexport class SplatsMesh extends Object3D {\n  public mesh: any;\n  public material: ShaderMaterial | null = null;\n  private forceSorting: boolean = true;\n  public continuousSorting: boolean = true;\n  public totalSplats: number = 500000;\n\n  private textureSorted: DataTexture;\n  private texturePosColor: DataTexture;\n  private textureCovariance0: DataTexture;\n  private textureCovariance1: DataTexture;\n  private textureNode: DataTexture;\n  private textureNode2: DataTexture;\n  private textureNodeIndices: DataTexture;\n  private textureVisibilityNodes: DataTexture;\n  private textureHarmonics1: DataTexture;\n  private textureHarmonics2: DataTexture;\n  private textureHarmonics3: DataTexture;\n\n  private indexesBuffer: Int32Array;\n  private bufferSorted: Uint32Array;\n  private bufferPosColor: Uint32Array;\n  private bufferCovariance0: Float32Array;\n  private bufferCovariance1: Float32Array;\n  private bufferNodes: Float32Array;\n  private bufferNodes2: Float32Array;\n  private bufferNodesIndices: Uint32Array;\n  private bufferVisibilityNodes: Uint8Array;\n  private bufferHarmonics1: Uint32Array;\n  private bufferHarmonics2: Uint32Array;\n  private bufferHarmonics3: Uint32Array;\n\n  private bufferCenters: Float32Array;\n  private bufferPositions: Float32Array;\n  private bufferScale: Float32Array;\n  private bufferOrientation: Float32Array;\n\n  private textures: Array<Texture> = new Array();\n\n  private nodesAsString: string = '';\n\n  private sorter: any;\n  private lastSortViewDir = new Vector3(0, 0, -1);\n  private sortViewDir = new Vector3(0, 0, -1);\n  private lastSortViewPos = new Vector3();\n  private sortViewOffset = new Vector3();\n\n  private enableSorting = true;\n\n  private enabled: boolean = false;\n\n  private instanceCount: number = 0;\n  private debugMode = false;\n\n  rendererSize = new Vector2();\n\n  private harmonicsEnabled: boolean = false;\n  private maxPointBudget: number = 0;\n\n  constructor(debug: boolean = false, maxPointBudget: number, renderHamonics = false) {\n    super();\n    this.debugMode = debug;\n    this.harmonicsEnabled = renderHamonics;\n    this.maxPointBudget = maxPointBudget;\n\n    this.indexesBuffer = new Int32Array(maxPointBudget);\n    let indexesToSort = new Int32Array(maxPointBudget);\n\n    for (let i = 0; i < maxPointBudget; i++) {\n      this.indexesBuffer[i] = i;\n      indexesToSort[i] = i;\n    }\n\n    //Create the global textures\n    let size = Math.ceil(Math.sqrt(maxPointBudget));\n\n    //For the harmonics\n    let degree1Size = renderHamonics ? Math.ceil(Math.sqrt(maxPointBudget * 3)) : 1;\n    let degree2Size = renderHamonics ? Math.ceil(Math.sqrt(maxPointBudget * 5)) : 1;\n    let degree3Size = renderHamonics ? Math.ceil(Math.sqrt(maxPointBudget * 7)) : 1;\n\n    this.bufferCenters = new Float32Array(size * size * 4);\n    this.bufferPositions = new Float32Array(size * size * 4);\n    this.bufferScale = new Float32Array(size * size * 3);\n    this.bufferOrientation = new Float32Array(size * size * 4);\n\n    this.bufferSorted = new Uint32Array(maxPointBudget);\n    this.bufferOrientation = new Float32Array(size * size * 4);\n    this.bufferPosColor = new Uint32Array(size * size * 4);\n    this.bufferCovariance0 = new Float32Array(size * size * 4);\n    this.bufferCovariance1 = new Float32Array(size * size * 2);\n    this.bufferNodes = new Float32Array(100 * 100 * 4);\n    this.bufferNodes2 = new Float32Array(100 * 100 * 4);\n    this.bufferNodesIndices = new Uint32Array(size * size);\n    this.bufferVisibilityNodes = new Uint8Array(2048 * 4);\n    this.bufferHarmonics1 = new Uint32Array(degree1Size * degree1Size);\n    this.bufferHarmonics2 = new Uint32Array(degree2Size * degree2Size);\n    this.bufferHarmonics3 = new Uint32Array(degree3Size * degree3Size);\n\n    //This should be able to save up to 10000 nodes\n    this.textureNode = new DataTexture(this.bufferNodes, 100, 100, RGBAFormat, FloatType);\n    this.textureNode2 = new DataTexture(this.bufferNodes2, 100, 100, RGBAFormat, FloatType);\n\n    this.textureSorted = new DataTexture(\n      this.bufferSorted,\n      size,\n      size,\n      RedIntegerFormat,\n      UnsignedIntType,\n    );\n    this.textureSorted.internalFormat = 'R32UI';\n\n    this.textureNodeIndices = new DataTexture(\n      this.bufferNodesIndices,\n      size,\n      size,\n      RedIntegerFormat,\n      UnsignedIntType,\n    );\n    this.textureNodeIndices.internalFormat = 'R32UI';\n\n    this.textureCovariance0 = new DataTexture(\n      this.bufferCovariance0,\n      size,\n      size,\n      RGBAFormat,\n      FloatType,\n    );\n    this.textureCovariance1 = new DataTexture(\n      this.bufferCovariance1,\n      size,\n      size,\n      RGFormat,\n      FloatType,\n    );\n    this.texturePosColor = new DataTexture(\n      this.bufferPosColor,\n      size,\n      size,\n      RGBAIntegerFormat,\n      UnsignedIntType,\n    );\n    this.texturePosColor.internalFormat = 'RGBA32UI';\n\n    this.textureHarmonics1 = new DataTexture(\n      this.bufferHarmonics1,\n      degree1Size,\n      degree1Size,\n      RedIntegerFormat,\n      UnsignedIntType,\n    );\n    this.textureHarmonics1.internalFormat = 'R32UI';\n    this.textureHarmonics2 = new DataTexture(\n      this.bufferHarmonics2,\n      degree2Size,\n      degree2Size,\n      RedIntegerFormat,\n      UnsignedIntType,\n    );\n    this.textureHarmonics2.internalFormat = 'R32UI';\n    this.textureHarmonics3 = new DataTexture(\n      this.bufferHarmonics3,\n      degree3Size,\n      degree3Size,\n      RedIntegerFormat,\n      UnsignedIntType,\n    );\n    this.textureHarmonics3.internalFormat = 'R32UI';\n\n    this.textureVisibilityNodes = new DataTexture(this.bufferVisibilityNodes, 2048, 1, RGBAFormat);\n    this.textureVisibilityNodes.magFilter = NearestFilter;\n    this.textureVisibilityNodes.minFilter = NearestFilter;\n\n    this.textures = [];\n\n    this.textures.push(this.textureSorted);\n    this.textures.push(this.textureNode);\n    this.textures.push(this.textureNode2);\n    this.textures.push(this.textureNodeIndices);\n    this.textures.push(this.textureCovariance0);\n    this.textures.push(this.textureCovariance1);\n    this.textures.push(this.texturePosColor);\n    this.textures.push(this.textureHarmonics1);\n    this.textures.push(this.textureHarmonics2);\n    this.textures.push(this.textureHarmonics3);\n    this.textures.push(this.textureVisibilityNodes);\n    this.textures.forEach((text) => (text.needsUpdate = true));\n\n    this.initialize();\n  }\n\n  initialize() {\n    return createSortWorker(this.maxPointBudget).then((result) => {\n      this.sorter = result;\n\n      const quadVertices = new Float32Array([-1, -1, 0.0, 1, -1, 0.0, -1, 1, 0.0, 1, 1, 0.0]);\n      const quadIndices = new Uint16Array([2, 1, 0, 3, 1, 2]);\n\n      //Global mesh used to setup the global rendering of the points\n      let shader = new ShaderMaterial({\n        glslVersion: GLSL3,\n        vertexShader: require('./materials/shaders/splats.vert').default,\n        fragmentShader: require('./materials/shaders/splats.frag').default,\n        transparent: true,\n        depthTest: true,\n        depthWrite: false,\n        side: FrontSide,\n        uniforms: {\n          focal: { value: new Vector2(0, 0) },\n          inverseFocalAdjustment: { value: 1 },\n          splatScale: { value: 1 },\n          initialSplatScale: { value: 1 },\n          basisViewport: { value: new Vector2(0, 0) },\n          globalOffset: { value: new Vector3(0, 0, 0) },\n          sortedTexture: { value: null },\n          covarianceTexture0: { value: null },\n          covarianceTexture1: { value: null },\n          posColorTexture: { value: null },\n          nodeTexture: { value: null },\n          nodeTexture2: { value: null },\n          nodeIndicesTexture: { value: null },\n          indicesTexture: { value: null },\n          harmonicsTexture1: { value: null },\n          harmonicsTexture2: { value: null },\n          harmonicsTexture3: { value: null },\n          visibleNodes: { value: null },\n          cameraPosition: { value: new Vector3(0, 0, 0) },\n          harmonicsDegree: { value: this.harmonicsEnabled ? 3 : 0 },\n          renderIds: { value: false },\n          debugMode: { value: false },\n          renderOnlyHarmonics: { value: false },\n          renderLoD: { value: true },\n          adaptiveSize: { value: true },\n          harmonicsScale: { value: 4 },\n          octreeSize: { value: 0 },\n          fov: { value: 1 },\n          maxSplatScale: { value: 3 },\n          screenHeight: { value: 1 },\n          spacing: { value: 1 },\n          useClipping: { value: false },\n          screenWidth: { value: 0 },\n          clipExtent: { value: new Vector4(0, 0, 1, 1) },\n          maxDepth: { value: 1 },\n        },\n      });\n\n      this.material = shader;\n      this.instanceCount = 0;\n\n      //Create the global textures\n      if (this.material) {\n        this.material.uniforms['sortedTexture'].value = this.textureSorted;\n        this.material.uniforms['posColorTexture'].value = this.texturePosColor;\n        this.material.uniforms['covarianceTexture0'].value = this.textureCovariance0;\n        this.material.uniforms['covarianceTexture1'].value = this.textureCovariance1;\n        this.material.uniforms['nodeTexture'].value = this.textureNode;\n        this.material.uniforms['nodeTexture2'].value = this.textureNode2;\n        this.material.uniforms['nodeIndicesTexture'].value = this.textureNodeIndices;\n        this.material.uniforms['harmonicsTexture1'].value = this.textureHarmonics1;\n        this.material.uniforms['harmonicsTexture2'].value = this.textureHarmonics2;\n        this.material.uniforms['harmonicsTexture3'].value = this.textureHarmonics3;\n        this.material.uniforms.visibleNodes.value = this.textureVisibilityNodes;\n      }\n\n      let geom = new InstancedBufferGeometry();\n\n      geom.setAttribute('position', new BufferAttribute(quadVertices, 3));\n      geom.setIndex(new BufferAttribute(quadIndices, 1));\n\n      this.mesh = new Mesh(geom, shader);\n      this.mesh.frustumCulled = false;\n      this.add(this.mesh);\n\n      this.enabled = true;\n    });\n  }\n\n  renderSplatsIDs(status: boolean) {\n    if (this.material == null) return;\n\n    this.material.uniforms['renderIds'].value = status;\n    this.material.transparent = !status;\n  }\n\n  update(mesh: Mesh, camera: Camera, size: Vector2, callback = () => {}) {\n    if (this.material == null) return;\n\n    this.material.uniforms['cameraPosition'].value = camera.position;\n\n    let mat = mesh.material as RawShaderMaterial;\n    mat.visible = false;\n\n    //Passing the uniforms from the point cloud material to the splats material.\n    this.material.uniforms.octreeSize.value = mat.uniforms.octreeSize.value;\n    this.material.uniforms.fov.value = mat.uniforms.fov.value;\n    this.material.uniforms.spacing.value = mat.uniforms.spacing.value;\n    this.material.uniforms.screenHeight.value = mat.uniforms.screenHeight.value;\n    this.material.uniforms.screenWidth.value = mat.uniforms.screenWidth.value;\n\n    let material = this.material as RawShaderMaterial;\n\n    material.uniforms.basisViewport.value.set(1.0 / size.x, 1.0 / size.y);\n\n    const focalLengthX = camera.projectionMatrix.elements[0] * 0.5 * size.x;\n\n    const focalLengthY = camera.projectionMatrix.elements[5] * 0.5 * size.y;\n\n    material.uniforms.focal.value.set(focalLengthX, focalLengthY);\n\n    let instanceCount = 0;\n    let nodesCount = 0;\n    let nodesAsString = '';\n\n    let totalMemoryUsed = 0;\n    let totalMemoryInDisplay = 0;\n\n    mesh.traverse((el) => {\n      let m = el as Mesh;\n      let g = m.geometry as BufferGeometry;\n      instanceCount += g.drawRange.count;\n    });\n\n    totalMemoryUsed = instanceCount * (this.harmonicsEnabled ? 236 : 56);\n\n    mesh.traverseVisible((el) => {\n      nodesAsString += el.name;\n    });\n\n    this.forceSorting = false;\n\n    if (nodesAsString !== this.nodesAsString && this.enableSorting) {\n      this.nodesAsString = nodesAsString;\n\n      instanceCount = 0;\n      nodesCount = 0;\n\n      //Copy the data from the visibility nodes, it uses a separated texture to sync when\n      //it is updated in relationship with the other textures.\n      this.bufferVisibilityNodes.set(mat.uniforms.visibleNodes.value.image.data);\n\n      mesh.traverseVisible((el) => {\n        let m = el as Mesh;\n        let g = m.geometry as BufferGeometry;\n\n        if (this.material) {\n          if (m.name === 'r') {\n            this.material?.uniforms.globalOffset.value.copy(g.userData.offset);\n          }\n\n          this.material.uniforms.maxDepth.value = g.userData.maxDepth;\n          this.material.uniforms.maxSplatScale.value = g.userData.maxDepth;\n          this.totalSplats = g.userData.totalSplats;\n        }\n\n        let pointCloudMaterial = mesh.material as PointCloudMaterial;\n        const vnStart = pointCloudMaterial.visibleNodeTextureOffsets.get(el.name)!;\n        const level = m.name.length - 1;\n\n        let offset = g.userData.offset;\n        let nodeInfo = [m.position.x, m.position.y, m.position.z, offset.x];\n        let nodeInfo2 = [vnStart, level, offset.y, offset.z];\n        this.bufferNodes.set(nodeInfo, nodesCount * 4);\n        this.bufferNodes2.set(nodeInfo2, nodesCount * 4);\n\n        this.bufferNodesIndices.set(\n          new Uint32Array(g.drawRange.count).fill(nodesCount),\n          instanceCount,\n        );\n\n        //Used for sorting\n        this.bufferCenters.set(g.getAttribute('raw_position').array, instanceCount * 4);\n\n        //Used for raycasting\n        this.bufferPositions.set(g.getAttribute('centers').array, instanceCount * 4);\n        this.bufferScale.set(g.getAttribute('scale').array, instanceCount * 3);\n        this.bufferOrientation.set(g.getAttribute('orientation').array, instanceCount * 4);\n\n        //Used for rendering\n        this.bufferCovariance0.set(g.getAttribute('COVARIANCE0').array, instanceCount * 4);\n        this.bufferCovariance1.set(g.getAttribute('COVARIANCE1').array, instanceCount * 2);\n        this.bufferPosColor.set(g.getAttribute('POS_COLOR').array, instanceCount * 4);\n\n        if (this.harmonicsEnabled) {\n          this.bufferHarmonics1.set(g.getAttribute('HARMONICS1').array, instanceCount * 3);\n          this.bufferHarmonics2.set(g.getAttribute('HARMONICS2').array, instanceCount * 5);\n          this.bufferHarmonics3.set(g.getAttribute('HARMONICS3').array, instanceCount * 7);\n        }\n\n        instanceCount += g.drawRange.count;\n        nodesCount++;\n      });\n\n      totalMemoryInDisplay = instanceCount * (this.harmonicsEnabled ? 236 : 56);\n\n      if (this.debugMode) {\n        console.log('total memory in usage: ' + Math.ceil(totalMemoryUsed / 1000000) + ' MB');\n        console.log('total memory displayed: ' + Math.ceil(totalMemoryInDisplay / 1000000) + ' MB');\n        console.log('levels displayed: ' + nodesAsString);\n      }\n\n      this.instanceCount = instanceCount;\n\n      this.forceSorting = true;\n\n      this.sortSplats(camera, callback);\n\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  defer() {\n    let promise = new Promise((resolve) => {\n      let counter = 0;\n\n      let frameCounter = () => {\n        let anim = requestAnimationFrame(frameCounter);\n        if (counter == DELAYED_FRAMES) {\n          resolve('true');\n          cancelAnimationFrame(anim);\n        }\n        counter++;\n      };\n\n      frameCounter();\n    });\n\n    return promise;\n  }\n\n  sortSplats(camera: Camera, callback = () => {}) {\n    if (this.mesh == null || this.instanceCount == 0) return;\n\n    let mvpMatrix = new Matrix4();\n    camera.updateMatrixWorld();\n    mvpMatrix.copy(camera.matrixWorld).invert();\n    mvpMatrix.premultiply(camera.projectionMatrix);\n    mvpMatrix.multiply(this.mesh.matrixWorld);\n\n    let angleDiff = 0;\n    let positionDiff = 0;\n\n    this.sortViewDir.set(0, 0, -1).applyQuaternion(camera.quaternion);\n    angleDiff = this.sortViewDir.dot(this.lastSortViewDir);\n    positionDiff = this.sortViewOffset.copy(camera.position).sub(this.lastSortViewPos).length();\n\n    if (\n      (this.continuousSorting || this.forceSorting || angleDiff <= 0.99 || positionDiff >= 1.0) &&\n      this.enableSorting\n    ) {\n      let sortMessage = {\n        indices: this.indexesBuffer,\n        centers: this.bufferCenters,\n        modelViewProj: mvpMatrix.elements,\n        totalSplats: this.instanceCount,\n      };\n\n      this.sorter.postMessage({\n        sort: sortMessage,\n      });\n\n      this.enableSorting = false;\n      this.forceSorting = false;\n\n      this.sorter.onmessage = async (e: any) => {\n        if (e.data.dataSorted) {\n          if (e.data.dataSorted != null) {\n            this.bufferSorted.set(new Uint32Array(e.data.dataSorted), 0);\n            this.textures.forEach((text: any) => (text.needsUpdate = true));\n\n            this.mesh.geometry.instanceCount = this.instanceCount;\n\n            this.defer().then((_) => {\n              callback();\n              this.enableSorting = true;\n            });\n          } else {\n            this.enableSorting = true;\n          }\n        }\n      };\n\n      this.lastSortViewPos.copy(camera.position);\n      this.lastSortViewDir.copy(this.sortViewDir);\n    }\n  }\n\n  getSplatData(globalID: any, nodeID: any) {\n    if (this.mesh == null) return null;\n\n    let center = new Vector3();\n    let offset = new Vector3();\n\n    let scale = new Vector3();\n    let orientation = new Quaternion();\n\n    center.x = this.bufferPositions[4 * globalID + 0];\n    center.y = this.bufferPositions[4 * globalID + 1];\n    center.z = this.bufferPositions[4 * globalID + 2];\n\n    scale.x = this.bufferScale[3 * globalID + 0];\n    scale.y = this.bufferScale[3 * globalID + 1];\n    scale.z = this.bufferScale[3 * globalID + 2];\n\n    orientation.w = this.bufferOrientation[4 * globalID + 0];\n    orientation.x = this.bufferOrientation[4 * globalID + 1];\n    orientation.y = this.bufferOrientation[4 * globalID + 2];\n    orientation.z = this.bufferOrientation[4 * globalID + 3];\n\n    offset.x = this.bufferNodes[4 * nodeID + 0];\n    offset.y = this.bufferNodes[4 * nodeID + 1];\n    offset.z = this.bufferNodes[4 * nodeID + 2];\n\n    center.add(offset);\n\n    let result = this.mesh.localToWorld(center);\n\n    return {\n      position: result,\n      scale,\n      orientation,\n    };\n  }\n\n  dispose() {\n    if (!this.enabled) return;\n\n    //Terminate the sorter\n    this.sorter.terminate();\n    this.sorter = null;\n\n    //Removing attributes\n    this.mesh.geometry.dispose();\n\n    //Remove the shader\n    this.material?.dispose();\n\n    //Remove textures and buffers\n    this.textures.forEach((texture) => {\n      texture.dispose();\n      (texture as any) = null;\n    });\n\n    this.textures = [];\n\n    //Set to 0 the length of the arrays\n    this.bufferCenters = new Float32Array(0);\n    this.bufferPositions = new Float32Array(0);\n    this.bufferScale = new Float32Array(0);\n    this.bufferOrientation = new Float32Array(0);\n\n    this.bufferSorted = new Uint32Array(0);\n    this.bufferOrientation = new Float32Array(0);\n    this.bufferPosColor = new Uint32Array(0);\n    this.bufferCovariance0 = new Float32Array(0);\n    this.bufferCovariance1 = new Float32Array(0);\n    this.bufferNodes = new Float32Array(0);\n    this.bufferNodes2 = new Float32Array(0);\n    this.bufferNodesIndices = new Uint32Array(0);\n    this.bufferVisibilityNodes = new Uint8Array(0);\n    this.bufferHarmonics1 = new Uint32Array(0);\n    this.bufferHarmonics2 = new Uint32Array(0);\n    this.bufferHarmonics3 = new Uint32Array(0);\n\n    //kill the mesh\n    this.mesh = null;\n\n    this.enabled = false;\n  }\n\n  get splatsEnabled(): boolean {\n    return this.enabled;\n  }\n}\n","import {\n  Box3,\n  Camera,\n  Object3D,\n  Points,\n  Ray,\n  Sphere,\n  Vector3,\n  Vector2,\n  WebGLRenderer,\n  Mesh,\n  BufferGeometry,\n} from 'three';\nimport { DEFAULT_MIN_NODE_PIXEL_SIZE, MAX_AMOUNT_OF_SPLATS } from './constants';\nimport { OctreeGeometry } from './loading2/octree-geometry';\nimport { PointCloudMaterial, PointSizeType } from './materials';\nimport { PointCloudOctreeNode } from './point-cloud-octree-node';\nimport { PickParams, PointCloudOctreePicker } from './point-cloud-octree-picker';\nimport { PointCloudTree } from './point-cloud-tree';\nimport {\n  IPointCloudGeometryNode,\n  IPointCloudTreeNode,\n  IPotree,\n  PCOGeometry,\n  PickPoint,\n} from './types';\nimport { computeTransformedBoundingBox } from './utils/bounds';\nimport { SplatsMesh } from './splats-mesh';\n\nconst DEBUG_MODE = false;\nexport class PointCloudOctree extends PointCloudTree {\n  potree: IPotree;\n  disposed: boolean = false;\n  pcoGeometry: PCOGeometry;\n  boundingBox: Box3;\n  boundingSphere: Sphere;\n  material: PointCloudMaterial;\n  level: number = 0;\n  maxLevel: number = Infinity;\n  splatsMesh: SplatsMesh | null = null;\n\n  /**\n   * The minimum radius of a node's bounding sphere on the screen in order to be displayed.\n   */\n  minNodePixelSize: number = DEFAULT_MIN_NODE_PIXEL_SIZE;\n  root: IPointCloudTreeNode | null = null;\n  boundingBoxNodes: Object3D[] = [];\n  visibleNodes: PointCloudOctreeNode[] = [];\n  visibleGeometry: IPointCloudGeometryNode[] = [];\n  numVisiblePoints: number = 0;\n  showBoundingBox: boolean = false;\n\n  private visibleBounds: Box3 = new Box3();\n  private picker: PointCloudOctreePicker | undefined;\n  private renderAsSplats: boolean | null = null;\n  private loadHarmonics: boolean = false;\n  private maxAmountOfSplats: number = MAX_AMOUNT_OF_SPLATS;\n\n  constructor(\n    potree: IPotree,\n    pcoGeometry: PCOGeometry,\n    material?: PointCloudMaterial,\n    loadHarmonics: boolean = false,\n    maxAmountOfSplats: number = MAX_AMOUNT_OF_SPLATS,\n  ) {\n    super();\n\n    this.name = '';\n    this.potree = potree;\n    this.root = pcoGeometry.root;\n    this.pcoGeometry = pcoGeometry;\n    this.boundingBox = pcoGeometry.boundingBox;\n    this.boundingSphere = this.boundingBox.getBoundingSphere(new Sphere());\n    this.loadHarmonics = loadHarmonics;\n    this.maxAmountOfSplats = maxAmountOfSplats;\n    this.position.copy(pcoGeometry.offset);\n    this.updateMatrix();\n\n    this.material =\n      material || pcoGeometry instanceof OctreeGeometry\n        ? new PointCloudMaterial({ colorRgba: true })\n        : new PointCloudMaterial();\n\n    this.initMaterial(this.material);\n  }\n\n  private initMaterial(material: PointCloudMaterial): void {\n    this.updateMatrixWorld(true);\n\n    const { min, max } = computeTransformedBoundingBox(\n      this.pcoGeometry.tightBoundingBox || this.getBoundingBoxWorld(),\n      this.matrixWorld,\n    );\n\n    const bWidth = max.z - min.z;\n    material.heightMin = min.z - 0.2 * bWidth;\n    material.heightMax = max.z + 0.2 * bWidth;\n  }\n\n  dispose(): void {\n    if (this.root) {\n      this.root.dispose();\n    }\n\n    this.pcoGeometry.root.traverse((n) => this.potree.lru.remove(n));\n    this.pcoGeometry.dispose();\n    this.material.dispose();\n\n    this.visibleNodes = [];\n    this.visibleGeometry = [];\n\n    if (this.picker) {\n      this.picker.dispose();\n      this.picker = undefined;\n    }\n\n    if (this.splatsMesh !== null) {\n      this.splatsMesh.dispose();\n      this.splatsMesh = null;\n    }\n\n    this.disposed = true;\n  }\n\n  get pointSizeType(): PointSizeType {\n    return this.material.pointSizeType;\n  }\n\n  set pointSizeType(value: PointSizeType) {\n    this.material.pointSizeType = value;\n  }\n\n  toTreeNode(\n    geometryNode: IPointCloudGeometryNode,\n    parent?: PointCloudOctreeNode | null,\n  ): PointCloudOctreeNode {\n    const points = new Points(geometryNode.geometry, this.material);\n    const node = new PointCloudOctreeNode(geometryNode, points);\n    points.name = geometryNode.name;\n    points.position.copy(geometryNode.boundingBox.min);\n    points.frustumCulled = false;\n    points.onBeforeRender = PointCloudMaterial.makeOnBeforeRender(this, node);\n\n    if (parent) {\n      parent.sceneNode.add(points);\n      parent.children[geometryNode.index] = node;\n\n      geometryNode.oneTimeDisposeHandlers.push(() => {\n        node.disposeSceneNode();\n        parent.sceneNode.remove(node.sceneNode);\n        // Replace the tree node (rendered and in the GPU) with the geometry node.\n        parent.children[geometryNode.index] = geometryNode;\n      });\n    } else {\n      this.root = node;\n      this.add(points);\n    }\n\n    return node;\n  }\n\n  updateSplats(camera: Camera, size: Vector2, callback = () => {}) {\n    let mesh = this.children[0] as Mesh;\n    if (!mesh) return;\n\n    //Parse the nodes to see if they contain splats information.\n    if (this.renderAsSplats === null || !this.renderAsSplats) {\n      this.renderAsSplats = false;\n      mesh.traverse((el) => {\n        let m = el as Mesh;\n        let g = m.geometry as BufferGeometry;\n        if (g.hasAttribute('COVARIANCE0')) this.renderAsSplats = true;\n      });\n\n      //Initialise the splats mesh if the nodes contain splats information\n      if (this.renderAsSplats && this.splatsMesh === null) {\n        this.splatsMesh = new SplatsMesh(DEBUG_MODE, this.maxAmountOfSplats, this.loadHarmonics);\n        this.add(this.splatsMesh);\n      }\n    }\n\n    if (this.splatsMesh !== null) {\n      if (this.renderAsSplats && this.splatsMesh.splatsEnabled) {\n        let runSort = this.splatsMesh.update(mesh, camera, size, callback);\n        if (this.splatsMesh.splatsEnabled && this.progress > 0.99 && runSort)\n          this.splatsMesh.sortSplats(camera, callback);\n      }\n    }\n  }\n\n  updateVisibleBounds() {\n    const bounds = this.visibleBounds;\n    bounds.min.set(Infinity, Infinity, Infinity);\n    bounds.max.set(-Infinity, -Infinity, -Infinity);\n\n    for (const node of this.visibleNodes) {\n      if (node.isLeafNode) {\n        bounds.expandByPoint(node.boundingBox.min);\n        bounds.expandByPoint(node.boundingBox.max);\n      }\n    }\n  }\n\n  updateBoundingBoxes(): void {\n    if (!this.showBoundingBox || !this.parent) {\n      return;\n    }\n\n    let bbRoot: any = this.parent.getObjectByName('bbroot');\n    if (!bbRoot) {\n      bbRoot = new Object3D();\n      bbRoot.name = 'bbroot';\n      this.parent.add(bbRoot);\n    }\n\n    const visibleBoxes: (Object3D | null)[] = [];\n    for (const node of this.visibleNodes) {\n      if (node.boundingBoxNode !== undefined && node.isLeafNode) {\n        visibleBoxes.push(node.boundingBoxNode);\n      }\n    }\n\n    bbRoot.children = visibleBoxes;\n  }\n\n  updateMatrixWorld(force: boolean): void {\n    if (this.matrixAutoUpdate === true) {\n      this.updateMatrix();\n    }\n\n    if (this.matrixWorldNeedsUpdate === true || force === true) {\n      if (!this.parent) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n\n      this.matrixWorldNeedsUpdate = false;\n\n      force = true;\n    }\n  }\n\n  hideDescendants(object: Object3D): void {\n    const toHide: Object3D[] = [];\n    addVisibleChildren(object);\n\n    while (toHide.length > 0) {\n      const objToHide = toHide.shift()!;\n      objToHide.visible = false;\n      addVisibleChildren(objToHide);\n    }\n\n    function addVisibleChildren(obj: Object3D) {\n      for (const child of obj.children) {\n        if (child.visible) {\n          toHide.push(child);\n        }\n      }\n    }\n  }\n\n  moveToOrigin(): void {\n    this.position.set(0, 0, 0); // Reset, then the matrix will be updated in getBoundingBoxWorld()\n    this.position.set(0, 0, 0).sub(this.getBoundingBoxWorld().getCenter(new Vector3()));\n  }\n\n  moveToGroundPlane(): void {\n    this.position.y += -this.getBoundingBoxWorld().min.y;\n  }\n\n  getBoundingBoxWorld(): Box3 {\n    this.updateMatrixWorld(true);\n    return computeTransformedBoundingBox(this.boundingBox, this.matrixWorld);\n  }\n\n  getVisibleExtent() {\n    return this.visibleBounds.applyMatrix4(this.matrixWorld);\n  }\n\n  pick(\n    renderer: WebGLRenderer,\n    camera: Camera,\n    ray: Ray,\n    params: Partial<PickParams> = {},\n  ): PickPoint | null {\n    this.picker = this.picker || new PointCloudOctreePicker();\n    return this.picker.pick(renderer, camera, ray, [this], params);\n  }\n\n  get progress() {\n    return this.visibleGeometry.length === 0\n      ? 0\n      : this.visibleNodes.length / this.visibleGeometry.length;\n  }\n\n  get maxAmountOfSplatsToRender() {\n    return this.maxAmountOfSplats;\n  }\n}\n","const canvas = document.createElement('canvas');\nconst gl: WebGLRenderingContext | null = canvas.getContext('webgl');\n\nexport const FEATURES = {\n  SHADER_INTERPOLATION: hasExtension('EXT_frag_depth') && hasMinVaryingVectors(8),\n  SHADER_SPLATS:\n    hasExtension('EXT_frag_depth') && hasExtension('OES_texture_float') && hasMinVaryingVectors(8),\n  SHADER_EDL: hasExtension('OES_texture_float') && hasMinVaryingVectors(8),\n  precision: getPrecision(),\n};\n\nfunction hasExtension(ext: string) {\n  return gl !== null && Boolean(gl.getExtension(ext));\n}\n\nfunction hasMinVaryingVectors(value: number) {\n  return gl !== null && gl.getParameter(gl.MAX_VARYING_VECTORS) >= value;\n}\n\nfunction getPrecision() {\n  if (gl === null) {\n    return '';\n  }\n\n  const vsHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);\n  const vsMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);\n\n  const fsHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n  const fsMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n\n  const highpAvailable =\n    vsHighpFloat && fsHighpFloat && vsHighpFloat.precision > 0 && fsHighpFloat.precision > 0;\n\n  const mediumpAvailable =\n    vsMediumpFloat &&\n    fsMediumpFloat &&\n    vsMediumpFloat.precision > 0 &&\n    fsMediumpFloat.precision > 0;\n\n  return highpAvailable ? 'highp' : mediumpAvailable ? 'mediump' : 'lowp';\n}\n","export class AsyncBlockingQueue<T> {\n  private promises: Promise<T>[];\n  private resolvers: ((t: T) => void)[];\n\n  constructor() {\n    this.resolvers = [];\n    this.promises = [];\n  }\n\n  public enqueue(t: T): void {\n    if (!this.resolvers.length) {\n      this.add();\n    }\n    const resolve = this.resolvers.shift()!;\n    resolve(t);\n  }\n\n  public dequeue(): Promise<T> {\n    if (!this.promises.length) {\n      this.add();\n    }\n    return this.promises.shift()!;\n  }\n\n  private add(): void {\n    this.promises.push(\n      new Promise((resolve) => {\n        this.resolvers.push(resolve);\n      }),\n    );\n  }\n}\n","import { AsyncBlockingQueue } from './async-blocking-queue';\n\nexport class AutoTerminatingWorker {\n  private timeoutId: number | undefined = undefined;\n  private terminated: boolean = false;\n\n  constructor(\n    private wrappedWorker: Worker,\n    private maxIdle: number,\n  ) {}\n\n  public get worker(): Worker {\n    return this.wrappedWorker;\n  }\n\n  get isTerminated(): boolean {\n    return this.terminated;\n  }\n\n  markIdle(): void {\n    this.timeoutId = window.setTimeout(() => {\n      this.terminated = true;\n      this.wrappedWorker.terminate();\n    }, this.maxIdle);\n  }\n\n  markInUse(): void {\n    if (this.timeoutId) {\n      window.clearTimeout(this.timeoutId);\n    }\n  }\n}\n\nexport class WorkerPool {\n  /**\n   * The maximum amount of idle time that can elapse before a worker from this pool is automatically terminated\n   */\n  private static readonly POOL_MAX_IDLE = 7000;\n\n  private pool = new AsyncBlockingQueue<AutoTerminatingWorker>();\n  private poolSize = 0;\n\n  constructor(\n    public maxWorkers: number,\n    private workerType: any,\n  ) {}\n\n  /**\n   * Returns a worker promise which is resolved when one is available.\n   */\n  public getWorker(): Promise<AutoTerminatingWorker> {\n    // If the number of active workers is smaller than the maximum, return a new one.\n    // Otherwise, return a promise for worker from the pool.\n    if (this.poolSize < this.maxWorkers) {\n      this.poolSize++;\n      return Promise.resolve(\n        new AutoTerminatingWorker(new this.workerType(), WorkerPool.POOL_MAX_IDLE),\n      );\n    } else {\n      return this.pool.dequeue().then((worker) => {\n        worker.markInUse();\n        // If the dequeued worker has been terminated, decrease the pool size and make a recursive call to get a new worker\n        if (worker.isTerminated) {\n          this.poolSize--;\n          return this.getWorker();\n        }\n        return worker;\n      });\n    }\n  }\n\n  /**\n   * Releases a Worker back into the pool\n   * @param worker\n   */\n  public releaseWorker(worker: AutoTerminatingWorker): void {\n    worker.markIdle();\n    this.pool.enqueue(worker);\n  }\n}\n","export class Version {\n  version: string;\n  versionMajor: number;\n  versionMinor: number = 0;\n\n  constructor(version: string) {\n    this.version = version;\n\n    const vmLength = version.indexOf('.') === -1 ? version.length : version.indexOf('.');\n    this.versionMajor = parseInt(version.substr(0, vmLength), 10);\n    this.versionMinor = parseInt(version.substr(vmLength + 1), 10);\n    if (isNaN(this.versionMinor)) {\n      this.versionMinor = 0;\n    }\n  }\n\n  newerThan(version: string): boolean {\n    const v = new Version(version);\n\n    if (this.versionMajor > v.versionMajor) {\n      return true;\n    } else if (this.versionMajor === v.versionMajor && this.versionMinor > v.versionMinor) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  equalOrHigher(version: string): boolean {\n    const v = new Version(version);\n\n    if (this.versionMajor > v.versionMajor) {\n      return true;\n    } else if (this.versionMajor === v.versionMajor && this.versionMinor >= v.versionMinor) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  upTo(version: string): boolean {\n    return !this.newerThan(version);\n  }\n}\n","// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\n\nimport { Box3, BufferAttribute, BufferGeometry, Uint8BufferAttribute, Vector3 } from 'three';\nimport { PointAttributeName, PointAttributeType } from '../point-attributes';\nimport { PointCloudOctreeGeometryNode } from '../point-cloud-octree-geometry-node';\nimport { handleEmptyBuffer, handleFailedRequest } from '../utils/utils';\nimport { WorkerPool } from '../utils/worker-pool';\nimport { Version } from '../version';\nimport { GetUrlFn, XhrRequest } from './types';\n\ninterface AttributeData {\n  attribute: {\n    name: PointAttributeName;\n    type: PointAttributeType;\n    byteSize: number;\n    numElements: number;\n  };\n  buffer: ArrayBuffer;\n}\n\ninterface WorkerResponse {\n  data: {\n    attributeBuffers: { [name: string]: AttributeData };\n    indices: ArrayBuffer;\n    tightBoundingBox: { min: number[]; max: number[] };\n    mean: number[];\n  };\n}\n\ninterface BinaryLoaderOptions {\n  getUrl?: GetUrlFn;\n  version: string;\n  boundingBox: Box3;\n  scale: number;\n  xhrRequest: XhrRequest;\n}\n\ntype Callback = (node: PointCloudOctreeGeometryNode) => void;\n\nexport class BinaryLoader {\n  version: Version;\n  boundingBox: Box3;\n  scale: number;\n  getUrl: GetUrlFn;\n  disposed: boolean = false;\n  xhrRequest: XhrRequest;\n  callbacks: Callback[];\n\n  public static readonly WORKER_POOL = new WorkerPool(\n    32,\n    require('../workers/binary-decoder.worker.js').default,\n  );\n\n  constructor({\n    getUrl = (s) => Promise.resolve(s),\n    version,\n    boundingBox,\n    scale,\n    xhrRequest,\n  }: BinaryLoaderOptions) {\n    if (typeof version === 'string') {\n      this.version = new Version(version);\n    } else {\n      this.version = version;\n    }\n\n    this.xhrRequest = xhrRequest;\n    this.getUrl = getUrl;\n    this.boundingBox = boundingBox;\n    this.scale = scale;\n    this.callbacks = [];\n  }\n\n  dispose(): void {\n    this.disposed = true;\n  }\n\n  load(node: PointCloudOctreeGeometryNode): Promise<void> {\n    if (node.loaded || this.disposed) {\n      return Promise.resolve();\n    }\n\n    return Promise.resolve(this.getUrl(this.getNodeUrl(node)))\n      .then((url) => this.xhrRequest(url, { mode: 'cors' }))\n      .then((res) => handleFailedRequest(res))\n      .then((okRes) => okRes.arrayBuffer())\n      .then((buffer) => handleEmptyBuffer(buffer))\n      .then((okBuffer) => {\n        return new Promise((resolve) => this.parse(node, okBuffer, resolve));\n      });\n  }\n\n  private getNodeUrl(node: PointCloudOctreeGeometryNode): string {\n    let url = node.getUrl();\n    if (this.version.equalOrHigher('1.4')) {\n      url += '.bin';\n    }\n\n    return url;\n  }\n\n  private parse(\n    node: PointCloudOctreeGeometryNode,\n    buffer: ArrayBuffer,\n    resolve: () => void,\n  ): void {\n    if (this.disposed) {\n      resolve();\n      return;\n    }\n\n    BinaryLoader.WORKER_POOL.getWorker().then((autoTerminatingWorker) => {\n      const pointAttributes = node.pcoGeometry.pointAttributes;\n      const numPoints = buffer.byteLength / pointAttributes.byteSize;\n\n      if (this.version.upTo('1.5')) {\n        node.numPoints = numPoints;\n      }\n\n      autoTerminatingWorker.worker.onmessage = (e: WorkerResponse) => {\n        if (this.disposed) {\n          resolve();\n          BinaryLoader.WORKER_POOL.releaseWorker(autoTerminatingWorker);\n          return;\n        }\n\n        const data = e.data;\n\n        const geometry = (node.geometry = node.geometry || new BufferGeometry());\n        geometry.boundingBox = node.boundingBox;\n\n        this.addBufferAttributes(geometry, data.attributeBuffers);\n        this.addIndices(geometry, data.indices);\n        this.addNormalAttribute(geometry, numPoints);\n\n        node.mean = new Vector3().fromArray(data.mean);\n        node.tightBoundingBox = this.getTightBoundingBox(data.tightBoundingBox);\n        node.loaded = true;\n        node.loading = false;\n        node.failed = false;\n        node.pcoGeometry.numNodesLoading--;\n        node.pcoGeometry.needsUpdate = true;\n\n        this.callbacks.forEach((callback) => callback(node));\n        resolve();\n        BinaryLoader.WORKER_POOL.releaseWorker(autoTerminatingWorker);\n      };\n\n      const message = {\n        buffer,\n        pointAttributes,\n        version: this.version.version,\n        min: node.boundingBox.min.toArray(),\n        offset: node.pcoGeometry.offset.toArray(),\n        scale: this.scale,\n        spacing: node.spacing,\n        hasChildren: node.hasChildren,\n      };\n\n      autoTerminatingWorker.worker.postMessage(message, [message.buffer]);\n    });\n  }\n\n  private getTightBoundingBox({ min, max }: { min: number[]; max: number[] }): Box3 {\n    const box = new Box3(new Vector3().fromArray(min), new Vector3().fromArray(max));\n    box.max.sub(box.min);\n    box.min.set(0, 0, 0);\n\n    return box;\n  }\n\n  private addBufferAttributes(\n    geometry: BufferGeometry,\n    buffers: { [name: string]: { buffer: ArrayBuffer } },\n  ): void {\n    Object.keys(buffers).forEach((property) => {\n      const buffer = buffers[property].buffer;\n\n      if (this.isAttribute(property, PointAttributeName.POSITION_CARTESIAN)) {\n        geometry.setAttribute('position', new BufferAttribute(new Float32Array(buffer), 3));\n      } else if (this.isAttribute(property, PointAttributeName.COLOR_PACKED)) {\n        geometry.setAttribute('color', new BufferAttribute(new Uint8Array(buffer), 3, true));\n      } else if (this.isAttribute(property, PointAttributeName.INTENSITY)) {\n        geometry.setAttribute('intensity', new BufferAttribute(new Float32Array(buffer), 1));\n      } else if (this.isAttribute(property, PointAttributeName.CLASSIFICATION)) {\n        geometry.setAttribute('classification', new BufferAttribute(new Uint8Array(buffer), 1));\n      } else if (this.isAttribute(property, PointAttributeName.NORMAL_SPHEREMAPPED)) {\n        geometry.setAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\n      } else if (this.isAttribute(property, PointAttributeName.NORMAL_OCT16)) {\n        geometry.setAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\n      } else if (this.isAttribute(property, PointAttributeName.NORMAL)) {\n        geometry.setAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\n      }\n    });\n  }\n\n  private addIndices(geometry: BufferGeometry, indices: ArrayBuffer): void {\n    const indicesAttribute = new Uint8BufferAttribute(indices, 4);\n    indicesAttribute.normalized = true;\n    geometry.setAttribute('indices', indicesAttribute);\n  }\n\n  private addNormalAttribute(geometry: BufferGeometry, numPoints: number): void {\n    if (!geometry.getAttribute('normal')) {\n      const buffer = new Float32Array(numPoints * 3);\n      geometry.setAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\n    }\n  }\n\n  private isAttribute(property: string, name: PointAttributeName): boolean {\n    return parseInt(property, 10) === name;\n  }\n}\n","// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\n\nimport { Box3, Vector3 } from 'three';\nimport { PointAttributes, PointAttributeStringName } from '../point-attributes';\nimport { PointCloudOctreeGeometry } from '../point-cloud-octree-geometry';\nimport { PointCloudOctreeGeometryNode } from '../point-cloud-octree-geometry-node';\nimport { createChildAABB } from '../utils/bounds';\nimport { getIndexFromName, handleFailedRequest } from '../utils/utils';\nimport { Version } from '../version';\nimport { BinaryLoader } from './binary-loader';\nimport { GetUrlFn, XhrRequest } from './types';\n\ninterface BoundingBoxData {\n  lx: number;\n  ly: number;\n  lz: number;\n  ux: number;\n  uy: number;\n  uz: number;\n}\n\ninterface POCJson {\n  version: string;\n  octreeDir: string;\n  projection: string;\n  points: number;\n  boundingBox: BoundingBoxData;\n  tightBoundingBox?: BoundingBoxData;\n  pointAttributes: PointAttributeStringName[];\n  spacing: number;\n  scale: number;\n  hierarchyStepSize: number;\n  hierarchy: [string, number][]; // [name, numPoints][]\n}\n\n/**\n *\n * @param url\n *    The url of the point cloud file (usually cloud.js).\n * @param getUrl\n *    Function which receives the relative URL of a point cloud chunk file which is to be loaded\n *    and shoud return a new url (e.g. signed) in the form of a string or a promise.\n * @param xhrRequest An arrow function for a fetch request\n * @returns\n *    An observable which emits once when the first LOD of the point cloud is loaded.\n */\nexport function loadPOC(\n  url: string,\n  getUrl: GetUrlFn,\n  xhrRequest: XhrRequest,\n): Promise<PointCloudOctreeGeometry> {\n  return Promise.resolve(getUrl(url)).then((transformedUrl) => {\n    return xhrRequest(transformedUrl, { mode: 'cors' })\n      .then((res) => handleFailedRequest(res))\n      .then((okRes) => okRes.json())\n      .then(parse(transformedUrl, getUrl, xhrRequest));\n  });\n}\n\nfunction parse(url: string, getUrl: GetUrlFn, xhrRequest: XhrRequest) {\n  return (data: POCJson): Promise<PointCloudOctreeGeometry> => {\n    const { offset, boundingBox, tightBoundingBox } = getBoundingBoxes(data);\n\n    const loader = new BinaryLoader({\n      getUrl,\n      version: data.version,\n      boundingBox,\n      scale: data.scale,\n      xhrRequest,\n    });\n\n    const pco = new PointCloudOctreeGeometry(\n      loader,\n      boundingBox,\n      tightBoundingBox,\n      offset,\n      xhrRequest,\n    );\n\n    pco.url = url;\n    pco.octreeDir = data.octreeDir;\n    pco.needsUpdate = true;\n    pco.spacing = data.spacing;\n    pco.hierarchyStepSize = data.hierarchyStepSize;\n    pco.projection = data.projection;\n    pco.offset = offset;\n    pco.pointAttributes = new PointAttributes(data.pointAttributes);\n\n    const nodes: Record<string, PointCloudOctreeGeometryNode> = {};\n\n    const version = new Version(data.version);\n\n    return loadRoot(pco, data, nodes, version).then(() => {\n      if (version.upTo('1.4')) {\n        loadRemainingHierarchy(pco, data, nodes);\n      }\n\n      pco.nodes = nodes;\n      return pco;\n    });\n  };\n}\n\nfunction getBoundingBoxes(data: POCJson): {\n  offset: Vector3;\n  boundingBox: Box3;\n  tightBoundingBox: Box3;\n} {\n  const min = new Vector3(data.boundingBox.lx, data.boundingBox.ly, data.boundingBox.lz);\n  const max = new Vector3(data.boundingBox.ux, data.boundingBox.uy, data.boundingBox.uz);\n  const boundingBox = new Box3(min, max);\n  const tightBoundingBox = boundingBox.clone();\n\n  const offset = min.clone();\n\n  if (data.tightBoundingBox) {\n    const { lx, ly, lz, ux, uy, uz } = data.tightBoundingBox;\n    tightBoundingBox.min.set(lx, ly, lz);\n    tightBoundingBox.max.set(ux, uy, uz);\n  }\n\n  boundingBox.min.sub(offset);\n  boundingBox.max.sub(offset);\n  tightBoundingBox.min.sub(offset);\n  tightBoundingBox.max.sub(offset);\n\n  return { offset, boundingBox, tightBoundingBox };\n}\n\nfunction loadRoot(\n  pco: PointCloudOctreeGeometry,\n  data: POCJson,\n  nodes: Record<string, PointCloudOctreeGeometryNode>,\n  version: Version,\n): Promise<void> {\n  const name = 'r';\n\n  const root = new PointCloudOctreeGeometryNode(name, pco, pco.boundingBox);\n  root.hasChildren = true;\n  root.spacing = pco.spacing;\n\n  if (version.upTo('1.5')) {\n    root.numPoints = data.hierarchy[0][1];\n  } else {\n    root.numPoints = 0;\n  }\n\n  pco.root = root;\n  nodes[name] = root;\n  return pco.root.load();\n}\n\nfunction loadRemainingHierarchy(\n  pco: PointCloudOctreeGeometry,\n  data: POCJson,\n  nodes: Record<string, PointCloudOctreeGeometryNode>,\n): void {\n  for (let i = 1; i < data.hierarchy.length; i++) {\n    const [name, numPoints] = data.hierarchy[i];\n    const { index, parentName, level } = parseName(name);\n    const parentNode = nodes[parentName];\n\n    const boundingBox = createChildAABB(parentNode.boundingBox, index);\n    const node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n    node.level = level;\n    node.numPoints = numPoints;\n    node.spacing = pco.spacing / Math.pow(2, node.level);\n\n    nodes[name] = node;\n    parentNode.addChild(node);\n  }\n}\n\nfunction parseName(name: string): { index: number; parentName: string; level: number } {\n  return {\n    index: getIndexFromName(name),\n    parentName: name.substring(0, name.length - 1),\n    level: name.length - 1,\n  };\n}\n","// Create enums for different types of workers\nexport enum WorkerType {\n  DECODER_WORKER = 'DECODER_WORKER',\n  DECODER_WORKER_GLTF = 'DECODER_WORKER_GLTF',\n  DECODER_WORKER_SPLATS = 'DECODER_WORKER_SPLATS',\n  DECODER_WORKER_SPLATS_COMPRESSED = 'DECODER_WORKER_SPLATS_COMPRESSED',\n}\n\n// Worker JS names: 'BinaryDecoderWorker.js', 'DEMWorker.js', 'EptBinaryDecoderWorker.js', 'EptLaszipDecoderWorker.js',\n// EptZstandardDecoder_preamble.js', 'EptZstandardDecoderWorker.js', 'LASDecoderWorker.js', 'LASLAZWorker.js', 'LazLoaderWorker.js'\n\nfunction createWorker(type: WorkerType): Worker {\n  switch (type) {\n    case WorkerType.DECODER_WORKER: {\n      const DecoderWorker = require('./decoder.worker.js').default;\n      return new DecoderWorker();\n    }\n    case WorkerType.DECODER_WORKER_GLTF: {\n      const DecoderWorker_GLTF = require('./gltf-decoder.worker.js').default;\n      return new DecoderWorker_GLTF();\n    }\n    case WorkerType.DECODER_WORKER_SPLATS: {\n      const DecoderWorker_GLTF = require('./gltf-splats-decoder.worker.js').default;\n      return new DecoderWorker_GLTF();\n    }\n    case WorkerType.DECODER_WORKER_SPLATS_COMPRESSED: {\n      const DecoderWorker_GLTF = require('./gltf-splats-compressed-decoder.worker.js').default;\n      return new DecoderWorker_GLTF();\n    }\n    default:\n      throw new Error('Unknown worker type');\n  }\n}\n\nexport class WorkerPool {\n  // Workers will be an object that has a key for each worker type and the value is an array of Workers that can be empty\n  private workers: { [key in WorkerType]: Worker[] } = {\n    DECODER_WORKER: [],\n    DECODER_WORKER_GLTF: [],\n    DECODER_WORKER_SPLATS: [],\n    DECODER_WORKER_SPLATS_COMPRESSED: [],\n  };\n\n  getWorker(workerType: WorkerType): Worker {\n    // Throw error if workerType is not recognized\n    if (this.workers[workerType] === undefined) {\n      throw new Error('Unknown worker type');\n    }\n    // Given a worker URL, if URL does not exist in the worker object, create a new array with the URL as a key\n    if (this.workers[workerType].length === 0) {\n      const worker = createWorker(workerType);\n      this.workers[workerType].push(worker);\n    }\n    const worker = this.workers[workerType].pop();\n    if (worker === undefined) {\n      // Typescript needs this\n      throw new Error('No workers available');\n    }\n    // Return the last worker in the array and remove it from the array\n    return worker;\n  }\n\n  returnWorker(workerType: WorkerType, worker: Worker) {\n    this.workers[workerType].push(worker);\n  }\n}\n","import { BufferAttribute, BufferGeometry } from 'three';\nimport { GeometryDecoder } from './geometry-decoder';\nimport { OctreeGeometryNode } from './octree-geometry-node';\nimport { LoadingContext, Metadata } from './octree-loader';\nimport { WorkerType } from './worker-pool';\nimport { XhrRequest } from '../loading/types';\n\n// Buffer files for DEFAULT encoding\nexport const HIERARCHY_FILE = 'hierarchy.bin';\nexport const OCTREE_FILE = 'octree.bin';\n\n// Default buffer files for GLTF encoding\nexport const GLTF_COLORS_FILE = 'colors.glbin';\nexport const GLTF_POSITIONS_FILE = 'positions.glbin';\n\nexport class Decoder implements GeometryDecoder {\n  public readonly workerType = WorkerType.DECODER_WORKER;\n  private _metadata: Metadata;\n\n  constructor(\n    public metadata: Metadata,\n    private context: LoadingContext,\n  ) {\n    this._metadata = metadata;\n  }\n\n  async decode(node: OctreeGeometryNode, worker: Worker) {\n    const { byteOffset, byteSize } = node;\n\n    if (byteOffset === undefined || byteSize === undefined) {\n      throw new Error('byteOffset and byteSize are required');\n    }\n\n    let buffer;\n\n    const urlOctree = await this.getUrl(this.octreePath);\n\n    const first = byteOffset;\n    const last = byteOffset + byteSize - BigInt(1);\n\n    if (byteSize === BigInt(0)) {\n      buffer = new ArrayBuffer(0);\n      console.warn(`loaded node with 0 bytes: ${node.name}`);\n    } else {\n      const headers = { Range: `bytes=${first}-${last}` };\n      const response = await this.xhrRequest(urlOctree, { headers });\n\n      buffer = await response.arrayBuffer();\n    }\n\n    const pointAttributes = node.octreeGeometry.pointAttributes;\n    const scale = node.octreeGeometry.scale;\n\n    const box = node.boundingBox;\n    const min = node.octreeGeometry.offset.clone().add(box.min);\n    const size = box.max.clone().sub(box.min);\n    const max = min.clone().add(size);\n    const numPoints = node.numPoints;\n\n    const offset = this._metadata.offset;\n\n    const message = {\n      name: node.name,\n      buffer: buffer,\n      pointAttributes: pointAttributes,\n      scale: scale,\n      min: min,\n      max: max,\n      size: size,\n      offset: offset,\n      numPoints: numPoints,\n    };\n\n    worker.postMessage(message, [message.buffer]);\n\n    const doneEvent = await new Promise<MessageEvent<any>>((res) => {\n      worker.onmessage = res;\n    });\n\n    return this.readSuccessMessage(doneEvent, buffer);\n  }\n\n  private get getUrl() {\n    return this.context.getUrl;\n  }\n\n  private get xhrRequest(): XhrRequest {\n    return this.context.xhrRequest;\n  }\n\n  private get octreePath() {\n    return this.context.octreePath;\n  }\n\n  private readSuccessMessage(e: MessageEvent<any>, buffer: ArrayBuffer) {\n    const data = e.data;\n    const buffers = data.attributeBuffers;\n    const geometry = new BufferGeometry();\n\n    for (const property in buffers) {\n      const buffer = buffers[property].buffer;\n\n      if (property === 'position') {\n        geometry.setAttribute('position', new BufferAttribute(new Float32Array(buffer), 3));\n      } else if (property === 'rgba') {\n        geometry.setAttribute('rgba', new BufferAttribute(new Uint8Array(buffer), 4, true));\n      } else if (property === 'NORMAL') {\n        geometry.setAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\n      } else if (property === 'INDICES') {\n        const bufferAttribute = new BufferAttribute(new Uint8Array(buffer), 4);\n        bufferAttribute.normalized = true;\n        geometry.setAttribute('indices', bufferAttribute);\n      } else {\n        const bufferAttribute: BufferAttribute & {\n          potree?: object;\n        } = new BufferAttribute(new Float32Array(buffer), 1);\n\n        const batchAttribute = buffers[property].attribute;\n        bufferAttribute.potree = {\n          offset: buffers[property].offset,\n          scale: buffers[property].scale,\n          preciseBuffer: buffers[property].preciseBuffer,\n          range: batchAttribute.range,\n        };\n\n        geometry.setAttribute(property, bufferAttribute);\n      }\n    }\n\n    return { data, buffer, geometry };\n  }\n}\n","export function extractBasePath(url: string): string {\n  return url.substring(0, url.lastIndexOf('/') + 1);\n}\n\nexport function buildUrl(basePath: string, fileName: string): string {\n  return `${basePath}${fileName}`;\n}\n\nexport function appendBuffer(buffer1: any, buffer2: any) {\n  var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n","import { BufferAttribute, BufferGeometry } from 'three';\nimport { GetUrlFn, XhrRequest } from '../loading/types';\nimport { DecodedGeometry, GeometryDecoder } from './geometry-decoder';\nimport { OctreeGeometryNode } from './octree-geometry-node';\nimport { LoadingContext, Metadata } from './octree-loader';\nimport { WorkerType } from './worker-pool';\nimport { appendBuffer } from './utils';\n\n// Buffer files for DEFAULT encoding\nexport const HIERARCHY_FILE = 'hierarchy.bin';\nexport const OCTREE_FILE = 'octree.bin';\n\n// Default buffer files for GLTF encoding\nexport const GLTF_COLORS_FILE = 'colors.glbin';\nexport const GLTF_POSITIONS_FILE = 'positions.glbin';\n\nexport class GltfDecoder implements GeometryDecoder {\n  readonly workerType = WorkerType.DECODER_WORKER_GLTF;\n\n  private _metadata: Metadata;\n\n  constructor(\n    public metadata: Metadata,\n    private context: LoadingContext,\n  ) {\n    this._metadata = metadata;\n  }\n\n  async decode(node: OctreeGeometryNode, worker: Worker): Promise<DecodedGeometry | undefined> {\n    const { byteOffset, byteSize } = node;\n\n    if (byteOffset === undefined || byteSize === undefined) {\n      throw new Error('byteOffset and byteSize are required');\n    }\n\n    let buffer;\n\n    const urlColors = await this.getUrl(this.gltfColorsPath);\n    const urlPositions = await this.getUrl(this.gltfPositionsPath);\n\n    if (byteSize === BigInt(0)) {\n      buffer = new ArrayBuffer(0);\n      console.warn(`loaded node with 0 bytes: ${node.name}`);\n    } else {\n      const firstPositions = byteOffset * 4n * 3n;\n      const lastPositions = byteOffset * 4n * 3n + byteSize * 4n * 3n - 1n;\n\n      const headersPositions = { Range: `bytes=${firstPositions}-${lastPositions}` };\n      const responsePositions = await this.xhrRequest(urlPositions, { headers: headersPositions });\n\n      const bufferPositions = await responsePositions.arrayBuffer();\n\n      const firstColors = byteOffset * 4n;\n      const lastColors = byteOffset * 4n + byteSize * 4n - 1n;\n\n      const headersColors = { Range: `bytes=${firstColors}-${lastColors}` };\n      const responseColors = await this.xhrRequest(urlColors, { headers: headersColors });\n      const bufferColors = await responseColors.arrayBuffer();\n\n      buffer = appendBuffer(bufferPositions, bufferColors);\n    }\n\n    const pointAttributes = node.octreeGeometry.pointAttributes;\n    const scale = node.octreeGeometry.scale;\n\n    const box = node.boundingBox;\n    const min = node.octreeGeometry.offset.clone().add(box.min);\n    const size = box.max.clone().sub(box.min);\n    const max = min.clone().add(size);\n    const numPoints = node.numPoints;\n\n    const offset = this._metadata.offset;\n\n    const message = {\n      name: node.name,\n      buffer: buffer,\n      pointAttributes: pointAttributes,\n      scale: scale,\n      min: min,\n      max: max,\n      size: size,\n      offset: offset,\n      numPoints: numPoints,\n    };\n\n    worker.postMessage(message, [message.buffer]);\n\n    const workerDone = await new Promise<MessageEvent<any>>((res) => (worker.onmessage = res));\n    const data = workerDone.data;\n    const buffers = data.attributeBuffers;\n\n    const geometry = new BufferGeometry();\n\n    for (const property in buffers) {\n      const buffer = buffers[property].buffer;\n\n      if (property === 'position') {\n        geometry.setAttribute('position', new BufferAttribute(new Float32Array(buffer), 3));\n      } else if (property === 'rgba') {\n        geometry.setAttribute('rgba', new BufferAttribute(new Uint8Array(buffer), 4, true));\n      } else if (property === 'NORMAL') {\n        geometry.setAttribute('normal', new BufferAttribute(new Float32Array(buffer), 3));\n      } else if (property === 'INDICES') {\n        const bufferAttribute = new BufferAttribute(new Uint8Array(buffer), 4);\n        bufferAttribute.normalized = true;\n        geometry.setAttribute('indices', bufferAttribute);\n      } else {\n        const bufferAttribute: BufferAttribute & {\n          potree?: object;\n        } = new BufferAttribute(new Float32Array(buffer), 1);\n\n        const batchAttribute = buffers[property].attribute;\n        bufferAttribute.potree = {\n          offset: buffers[property].offset,\n          scale: buffers[property].scale,\n          preciseBuffer: buffers[property].preciseBuffer,\n          range: batchAttribute.range,\n        };\n\n        geometry.setAttribute(property, bufferAttribute);\n      }\n    }\n\n    return { buffer, geometry, data };\n  }\n\n  public get gltfColorsPath() {\n    return this.context.gltfColorsPath;\n  }\n\n  public get gltfPositionsPath() {\n    return this.context.gltfPositionsPath;\n  }\n\n  public get getUrl(): GetUrlFn {\n    return this.context.getUrl;\n  }\n\n  private get xhrRequest(): XhrRequest {\n    return this.context.xhrRequest;\n  }\n}\n","import { BufferAttribute, BufferGeometry, Vector3 } from 'three';\nimport { GetUrlFn, XhrRequest } from '../loading/types';\nimport { DecodedGeometry, GeometryDecoder } from './geometry-decoder';\nimport { OctreeGeometryNode } from './octree-geometry-node';\nimport { LoadingContext, Metadata } from './octree-loader';\nimport { appendBuffer } from './utils';\nimport { WorkerType } from './worker-pool';\n\nexport class GltfSplatDecoder implements GeometryDecoder {\n  readonly workerType: WorkerType;\n\n  private _metadata: Metadata;\n\n  private compressed = false;\n\n  constructor(\n    public metadata: Metadata,\n    private context: LoadingContext,\n  ) {\n    this._metadata = metadata;\n\n    /*\n    The non compressed data works with scales of three dimensions, where the Z value is always zero,\n    the compressed data avoids this third value and only works with the XY elements, which is\n    used to know if the metadata points to compressed values (the scale only has two elements).\n    */\n\n    this.workerType = true\n      ? WorkerType.DECODER_WORKER_SPLATS_COMPRESSED\n      : WorkerType.DECODER_WORKER_SPLATS;\n  }\n\n  async decode(node: OctreeGeometryNode, worker: Worker): Promise<DecodedGeometry | undefined> {\n    const { byteOffset, byteSize } = node;\n    if (byteOffset === undefined || byteSize === undefined) {\n      throw new Error('byteOffset and byteSize are required');\n    }\n\n    let urls: Record<string, string>;\n    let buffer: ArrayBuffer;\n\n    let dataUri = this.metadata;\n    let retrieveURL = function (name: string) {\n      let el = dataUri.attributes.filter((att: any) => att.name === name)[0];\n      return el.bufferView.uri;\n    };\n\n    urls = {\n      positions: await this.getUrl(retrieveURL('position')),\n      colors: await this.getUrl(retrieveURL('sh_band_0')),\n      opacities: await this.getUrl(retrieveURL('opacity')),\n      scales: await this.getUrl(retrieveURL('scale')),\n      rotations: await this.getUrl(retrieveURL('rotation')),\n    };\n\n    if (this.harmonicsEnabled) {\n      urls = {\n        positions: await this.getUrl(retrieveURL('position')),\n        colors: await this.getUrl(retrieveURL('sh_band_0')),\n        opacities: await this.getUrl(retrieveURL('opacity')),\n        scales: await this.getUrl(retrieveURL('scale')),\n        rotations: await this.getUrl(retrieveURL('rotation')),\n\n        shBand1_0: await this.getUrl(retrieveURL('sh_band_1_triplet_0')),\n        shBand1_1: await this.getUrl(retrieveURL('sh_band_1_triplet_1')),\n        shBand1_2: await this.getUrl(retrieveURL('sh_band_1_triplet_2')),\n\n        shBand2_0: await this.getUrl(retrieveURL('sh_band_2_triplet_0')),\n        shBand2_1: await this.getUrl(retrieveURL('sh_band_2_triplet_1')),\n        shBand2_2: await this.getUrl(retrieveURL('sh_band_2_triplet_2')),\n        shBand2_3: await this.getUrl(retrieveURL('sh_band_2_triplet_3')),\n        shBand2_4: await this.getUrl(retrieveURL('sh_band_2_triplet_4')),\n\n        shBand3_0: await this.getUrl(retrieveURL('sh_band_3_triplet_0')),\n        shBand3_1: await this.getUrl(retrieveURL('sh_band_3_triplet_1')),\n        shBand3_2: await this.getUrl(retrieveURL('sh_band_3_triplet_2')),\n        shBand3_3: await this.getUrl(retrieveURL('sh_band_3_triplet_3')),\n        shBand3_4: await this.getUrl(retrieveURL('sh_band_3_triplet_4')),\n        shBand3_5: await this.getUrl(retrieveURL('sh_band_3_triplet_5')),\n        shBand3_6: await this.getUrl(retrieveURL('sh_band_3_triplet_6')),\n      };\n    }\n\n    const offsets: Record<string, bigint> = {\n      positions: 3n,\n      colors: 3n,\n      opacities: 1n,\n      scales: this.compressed ? 2n : 3n,\n      rotations: 4n,\n\n      shBand1_0: 3n,\n      shBand1_1: 3n,\n      shBand1_2: 3n,\n\n      shBand2_0: 3n,\n      shBand2_1: 3n,\n      shBand2_2: 3n,\n      shBand2_3: 3n,\n      shBand2_4: 3n,\n\n      shBand3_0: 3n,\n      shBand3_1: 3n,\n      shBand3_2: 3n,\n      shBand3_3: 3n,\n      shBand3_4: 3n,\n      shBand3_5: 3n,\n      shBand3_6: 3n,\n    };\n\n    const intOrFloat = this.compressed ? 1n : 4n;\n\n    const sizes: Record<string, bigint> = {\n      positions: 4n,\n      colors: intOrFloat,\n      opacities: intOrFloat,\n      scales: 4n,\n      rotations: intOrFloat,\n\n      shBand1_0: intOrFloat,\n      shBand1_1: intOrFloat,\n      shBand1_2: intOrFloat,\n\n      shBand2_0: intOrFloat,\n      shBand2_1: intOrFloat,\n      shBand2_2: intOrFloat,\n      shBand2_3: intOrFloat,\n      shBand2_4: intOrFloat,\n\n      shBand3_0: intOrFloat,\n      shBand3_1: intOrFloat,\n      shBand3_2: intOrFloat,\n      shBand3_3: intOrFloat,\n      shBand3_4: intOrFloat,\n      shBand3_5: intOrFloat,\n      shBand3_6: intOrFloat,\n    };\n\n    if (byteSize === BigInt(0)) {\n      //warn(`Loaded node with 0 bytes: ${node.name}`);\n      return;\n    } else {\n      const fetchBuffer = async (\n        url: string,\n        offsetMultiplier: bigint,\n        size: bigint,\n      ): Promise<ArrayBuffer> => {\n        const firstByte = byteOffset * size * offsetMultiplier;\n        const lastByte = firstByte + byteSize * size * offsetMultiplier - 1n;\n        const headers: any = {\n          Range: `bytes=${firstByte}-${lastByte}`,\n          'Transfer-Encoding': 'compress',\n          'Accept-Encoding': 'compress',\n        };\n        const response = await this.xhrRequest(url, { headers });\n        return response.arrayBuffer();\n      };\n\n      const fetchPromises: Promise<ArrayBuffer>[] = Object.entries(urls).map(([key, url]) =>\n        fetchBuffer(url, offsets[key], sizes[key]),\n      );\n\n      const [\n        positions,\n        colors,\n        opacities,\n        scales,\n        rotations,\n\n        shBand1_0,\n        shBand1_1,\n        shBand1_2,\n\n        shBand2_0,\n        shBand2_1,\n        shBand2_2,\n        shBand2_3,\n        shBand2_4,\n\n        shBand3_0,\n        shBand3_1,\n        shBand3_2,\n        shBand3_3,\n        shBand3_4,\n        shBand3_5,\n        shBand3_6,\n      ]: ArrayBuffer[] = await Promise.all(fetchPromises);\n\n      buffer = appendBuffer(positions, colors);\n      buffer = appendBuffer(buffer, opacities);\n      buffer = appendBuffer(buffer, scales);\n      buffer = appendBuffer(buffer, rotations);\n\n      if (this.harmonicsEnabled) {\n        buffer = appendBuffer(buffer, shBand1_0);\n        buffer = appendBuffer(buffer, shBand1_1);\n        buffer = appendBuffer(buffer, shBand1_2);\n\n        buffer = appendBuffer(buffer, shBand2_0);\n        buffer = appendBuffer(buffer, shBand2_1);\n        buffer = appendBuffer(buffer, shBand2_2);\n        buffer = appendBuffer(buffer, shBand2_3);\n        buffer = appendBuffer(buffer, shBand2_4);\n\n        buffer = appendBuffer(buffer, shBand3_0);\n        buffer = appendBuffer(buffer, shBand3_1);\n        buffer = appendBuffer(buffer, shBand3_2);\n        buffer = appendBuffer(buffer, shBand3_3);\n        buffer = appendBuffer(buffer, shBand3_4);\n        buffer = appendBuffer(buffer, shBand3_5);\n        buffer = appendBuffer(buffer, shBand3_6);\n      }\n    }\n\n    const pointAttributes = node.octreeGeometry.pointAttributes;\n    const scale = node.octreeGeometry.scale;\n\n    const box = node.boundingBox;\n    const min = node.octreeGeometry.offset.clone().add(box.min);\n    const size = box.max.clone().sub(box.min);\n    const max = min.clone().add(size);\n    const numPoints = node.numPoints;\n\n    const offset = this._metadata.offset;\n\n    const message = {\n      name: node.name,\n      buffer: buffer,\n      pointAttributes: pointAttributes,\n      scale: scale,\n      min: min,\n      max: max,\n      size: size,\n      offset: offset,\n      numPoints: numPoints,\n      harmonicsEnabled: this.harmonicsEnabled,\n    };\n\n    worker.postMessage(message, [message.buffer]);\n\n    const workerDone = await new Promise<MessageEvent<any>>((res) => (worker.onmessage = res));\n    const data = workerDone.data;\n    const buffers = data.attributeBuffers;\n    const geometry = new BufferGeometry();\n\n    geometry.drawRange.count = node.numPoints;\n\n    for (const property in buffers) {\n      const buffer = buffers[property].buffer;\n\n      if (property === 'position') {\n        geometry.setAttribute('centers', new BufferAttribute(new Float32Array(buffer), 4));\n      }\n\n      if (property === 'scale') {\n        geometry.setAttribute('scale', new BufferAttribute(new Float32Array(buffer), 3));\n      }\n\n      if (property === 'orientation') {\n        geometry.setAttribute('orientation', new BufferAttribute(new Float32Array(buffer), 4));\n      }\n\n      if (property === 'raw_position') {\n        geometry.setAttribute('raw_position', new BufferAttribute(new Float32Array(buffer), 4));\n      } else if (property === 'COVARIANCE0') {\n        geometry.setAttribute('COVARIANCE0', new BufferAttribute(new Float32Array(buffer), 4));\n      } else if (property === 'COVARIANCE1') {\n        geometry.setAttribute('COVARIANCE1', new BufferAttribute(new Float32Array(buffer), 2));\n      } else if (property === 'POS_COLOR') {\n        geometry.setAttribute('POS_COLOR', new BufferAttribute(new Uint32Array(buffer), 4));\n      }\n\n      if (this.harmonicsEnabled) {\n        if (property === 'HARMONICS1') {\n          geometry.setAttribute('HARMONICS1', new BufferAttribute(new Uint32Array(buffer), 3));\n        } else if (property === 'HARMONICS2') {\n          geometry.setAttribute('HARMONICS2', new BufferAttribute(new Uint32Array(buffer), 5));\n        } else if (property === 'HARMONICS3') {\n          geometry.setAttribute('HARMONICS3', new BufferAttribute(new Uint32Array(buffer), 7));\n        }\n      }\n    }\n\n    geometry.userData.maxDepth = this._metadata.hierarchy.depth + 1;\n    geometry.userData.totalSplats = this._metadata.points;\n    geometry.userData.offset = new Vector3(...offset).sub(min);\n\n    return { data, buffer, geometry };\n  }\n\n  private get getUrl(): GetUrlFn {\n    return this.context.getUrl;\n  }\n\n  private get xhrRequest(): XhrRequest {\n    return this.context.xhrRequest;\n  }\n\n  private get harmonicsEnabled(): boolean {\n    return this.context.harmonicsEnabled;\n  }\n}\n","import { Box3, BufferGeometry, Sphere } from 'three';\nimport { IPointCloudGeometryNode } from '../types';\nimport { OctreeGeometry } from './octree-geometry';\n\nexport class OctreeGeometryNode implements IPointCloudGeometryNode {\n  constructor(\n    public name: string,\n    public octreeGeometry: OctreeGeometry,\n    public boundingBox: Box3,\n  ) {\n    this.id = OctreeGeometryNode.IDCount++;\n    this.index = parseInt(name.charAt(name.length - 1));\n    this.boundingSphere = boundingBox.getBoundingSphere(new Sphere());\n    this.tightBoundingBox = boundingBox.clone();\n    this.numPoints = 0;\n    this.oneTimeDisposeHandlers = [];\n  }\n\n  loaded: boolean = false;\n  loading: boolean = false;\n  failed: boolean = false;\n  parent: OctreeGeometryNode | null = null;\n  geometry: BufferGeometry | undefined;\n  nodeType?: number;\n  byteOffset?: bigint;\n  byteSize?: bigint;\n  hierarchyByteOffset?: bigint;\n  hierarchyByteSize?: bigint;\n  hasChildren: boolean = false;\n  spacing!: number;\n  density?: number;\n  isLeafNode: boolean = true;\n\n  readonly isTreeNode: boolean = false;\n  readonly isGeometryNode: boolean = true;\n\n  readonly children: ReadonlyArray<OctreeGeometryNode | null> = [\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n  ];\n\n  static IDCount = 0;\n\n  id: number;\n  index: number;\n  boundingSphere: Sphere;\n  tightBoundingBox: Box3;\n  numPoints: number;\n  level!: number;\n  oneTimeDisposeHandlers: Function[];\n\n  getLevel() {\n    return this.level;\n  }\n\n  isLoaded() {\n    return this.loaded;\n  }\n\n  getBoundingSphere() {\n    return this.boundingSphere;\n  }\n\n  getBoundingBox() {\n    return this.boundingBox;\n  }\n\n  load(): Promise<void> {\n    if (this.octreeGeometry.numNodesLoading >= this.octreeGeometry.maxNumNodesLoading) {\n      return Promise.resolve();\n    }\n\n    if (!this.octreeGeometry.loader) {\n      this.loading = false;\n      this.failed = true;\n      return Promise.reject(`Loader not initialized for ${this.name}`);\n    }\n\n    return this.octreeGeometry.loader.load(this);\n  }\n\n  getNumPoints() {\n    return this.numPoints;\n  }\n\n  dispose(): void {\n    if (this.geometry && this.parent != null) {\n      this.geometry.dispose();\n      this.geometry = undefined;\n      this.loaded = false;\n\n      for (let i = 0; i < this.oneTimeDisposeHandlers.length; i++) {\n        const handler = this.oneTimeDisposeHandlers[i];\n        handler();\n      }\n      this.oneTimeDisposeHandlers = [];\n    }\n  }\n\n  traverse(cb: (node: OctreeGeometryNode) => void, includeSelf = true): void {\n    const stack: OctreeGeometryNode[] = includeSelf ? [this] : [];\n\n    let current: OctreeGeometryNode | undefined;\n\n    while ((current = stack.pop()) !== undefined) {\n      cb(current);\n\n      for (const child of current.children) {\n        if (child !== null) {\n          stack.push(child);\n        }\n      }\n    }\n  }\n}\n\nOctreeGeometryNode.IDCount = 0;\n","/**\n * Some types of possible point attribute data formats\n *\n * @class\n */\nconst PointAttributeTypes: PointAttributeTypesType = {\n  DATA_TYPE_DOUBLE: { ordinal: 0, name: 'double', size: 8 },\n  DATA_TYPE_FLOAT: { ordinal: 1, name: 'float', size: 4 },\n  DATA_TYPE_INT8: { ordinal: 2, name: 'int8', size: 1 },\n  DATA_TYPE_UINT8: { ordinal: 3, name: 'uint8', size: 1 },\n  DATA_TYPE_INT16: { ordinal: 4, name: 'int16', size: 2 },\n  DATA_TYPE_UINT16: { ordinal: 5, name: 'uint16', size: 2 },\n  DATA_TYPE_INT32: { ordinal: 6, name: 'int32', size: 4 },\n  DATA_TYPE_UINT32: { ordinal: 7, name: 'uint32', size: 4 },\n  DATA_TYPE_INT64: { ordinal: 8, name: 'int64', size: 8 },\n  DATA_TYPE_UINT64: { ordinal: 9, name: 'uint64', size: 8 },\n};\n\ntype PointAttributeTypesType = {\n  [key: string]: PointAttributeTypeType;\n};\n\ntype PointAttributeTypeType = {\n  ordinal: number;\n  name: string;\n  size: number;\n};\n\nlet i = 0;\nfor (const obj in PointAttributeTypes) {\n  PointAttributeTypes[i] = PointAttributeTypes[obj];\n  i++;\n}\n\nexport { PointAttributeTypes };\n\ntype RangeType = number[] | [number[], number[]];\n\nclass PointAttribute {\n  byteSize: number;\n\n  description: string;\n\n  public initialRange?: RangeType;\n\n  constructor(\n    public name: string,\n    public type: PointAttributeTypeType,\n    public numElements: number,\n    public range: RangeType = [Infinity, -Infinity],\n    public uri: string | undefined = undefined,\n  ) {\n    this.byteSize = this.numElements * this.type.size;\n    this.description = '';\n  }\n}\n\nexport { PointAttribute };\n\nexport const POINT_ATTRIBUTES: { [key: string]: PointAttribute } = {\n  POSITION_CARTESIAN: new PointAttribute(\n    'POSITION_CARTESIAN',\n    PointAttributeTypes.DATA_TYPE_FLOAT,\n    3,\n  ),\n  RGBA_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\n  COLOR_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\n  RGB_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 3),\n  NORMAL_FLOATS: new PointAttribute('NORMAL_FLOATS', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\n  INTENSITY: new PointAttribute('INTENSITY', PointAttributeTypes.DATA_TYPE_UINT16, 1),\n  CLASSIFICATION: new PointAttribute('CLASSIFICATION', PointAttributeTypes.DATA_TYPE_UINT8, 1),\n  NORMAL_SPHEREMAPPED: new PointAttribute(\n    'NORMAL_SPHEREMAPPED',\n    PointAttributeTypes.DATA_TYPE_UINT8,\n    2,\n  ),\n  NORMAL_OCT16: new PointAttribute('NORMAL_OCT16', PointAttributeTypes.DATA_TYPE_UINT8, 2),\n  NORMAL: new PointAttribute('NORMAL', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\n  RETURN_NUMBER: new PointAttribute('RETURN_NUMBER', PointAttributeTypes.DATA_TYPE_UINT8, 1),\n  NUMBER_OF_RETURNS: new PointAttribute(\n    'NUMBER_OF_RETURNS',\n    PointAttributeTypes.DATA_TYPE_UINT8,\n    1,\n  ),\n  SOURCE_ID: new PointAttribute('SOURCE_ID', PointAttributeTypes.DATA_TYPE_UINT16, 1),\n  INDICES: new PointAttribute('INDICES', PointAttributeTypes.DATA_TYPE_UINT32, 1),\n  SPACING: new PointAttribute('SPACING', PointAttributeTypes.DATA_TYPE_FLOAT, 1),\n  GPS_TIME: new PointAttribute('GPS_TIME', PointAttributeTypes.DATA_TYPE_DOUBLE, 1),\n};\n\ntype PAVectorType = {\n  name: string;\n  attributes: string[];\n};\n\nexport class PointAttributes {\n  constructor(\n    pointAttributes?: string[],\n    public attributes: PointAttribute[] = [],\n    public byteSize: number = 0,\n    public size: number = 0,\n    public vectors: PAVectorType[] = [],\n  ) {\n    if (pointAttributes != null) {\n      for (let i = 0; i < pointAttributes.length; i++) {\n        const pointAttributeName = pointAttributes[i];\n        const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\n        this.attributes.push(pointAttribute);\n        this.byteSize += pointAttribute.byteSize;\n        this.size++;\n      }\n    }\n  }\n\n  add(pointAttribute: PointAttribute) {\n    this.attributes.push(pointAttribute);\n    this.byteSize += pointAttribute.byteSize;\n    this.size++;\n  }\n\n  addVector(vector: PAVectorType) {\n    this.vectors.push(vector);\n  }\n\n  hasNormals() {\n    for (const name in this.attributes) {\n      const pointAttribute = this.attributes[name];\n      if (\n        pointAttribute === POINT_ATTRIBUTES.NORMAL_SPHEREMAPPED ||\n        pointAttribute === POINT_ATTRIBUTES.NORMAL_FLOATS ||\n        pointAttribute === POINT_ATTRIBUTES.NORMAL ||\n        pointAttribute === POINT_ATTRIBUTES.NORMAL_OCT16\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getAttribute(attributeName: string): PointAttribute | undefined {\n    return this.attributes.find((attr) => attr.name === attributeName);\n  }\n}\n","import { Box3, Sphere, Vector3 } from 'three';\nimport { GetUrlFn, XhrRequest } from '../loading/types';\nimport { Decoder } from './decoder';\nimport { GeometryDecoder } from './geometry-decoder';\nimport { GltfDecoder } from './gltf-decoder';\nimport { GltfSplatDecoder } from './gltf-splats-decoder';\nimport { OctreeGeometry } from './octree-geometry';\nimport { OctreeGeometryNode } from './octree-geometry-node';\nimport { PointAttribute, PointAttributes, PointAttributeTypes } from './point-attributes';\nimport { buildUrl, extractBasePath } from './utils';\nimport { WorkerPool, WorkerType } from './worker-pool';\n\n// Buffer files for DEFAULT encoding\nexport const HIERARCHY_FILE = 'hierarchy.bin';\nexport const OCTREE_FILE = 'octree.bin';\nexport const COMPRESSION_TYPE_FILE = 'pcl.gltf';\n//const COMPRESSION_VERSION = \"ext_pix4d_gltf_gs_version\";\n\n// Default buffer files for GLTF encoding\nexport const GLTF_COLORS_FILE = 'colors.glbin';\nexport const GLTF_POSITIONS_FILE = 'positions.glbin';\n\nexport class NodeLoader {\n  private readonly decoder: GeometryDecoder;\n  constructor(\n    public url: string,\n    public metadata: Metadata,\n    private loadingContext: LoadingContext,\n  ) {\n    if (this.metadata.encoding !== 'GLTF') {\n      this.decoder = new Decoder(metadata, loadingContext);\n    } else if (metadata.attributes.some((attr) => attr.name === 'sh_band_0')) {\n      this.decoder = new GltfSplatDecoder(metadata, loadingContext);\n    } else {\n      this.decoder = new GltfDecoder(metadata, loadingContext);\n    }\n  }\n\n  async load(node: OctreeGeometryNode) {\n    if (node.loaded || node.loading) {\n      return;\n    }\n\n    node.loading = true;\n    node.octreeGeometry.numNodesLoading++;\n\n    let worker: Worker | undefined;\n    try {\n      if (node.nodeType === 2) {\n        await this.loadHierarchy(node);\n      }\n\n      const { byteOffset, byteSize } = node;\n\n      if (byteOffset === undefined || byteSize === undefined) {\n        throw new Error('byteOffset and byteSize are required');\n      }\n\n      worker = this.workerPool.getWorker(this.workerType);\n      const loaded = await this.decoder.decode(node, worker);\n\n      if (!loaded) {\n        return;\n      }\n\n      const { geometry, data } = loaded;\n\n      node.density = data.density;\n      node.geometry = geometry;\n      node.loaded = true;\n      node.octreeGeometry.needsUpdate = true;\n      node.tightBoundingBox = this.getTightBoundingBox(data.tightBoundingBox);\n    } catch (e) {\n      node.loaded = false;\n    } finally {\n      node.loading = false;\n      node.octreeGeometry.numNodesLoading--;\n      if (worker) {\n        this.workerPool.returnWorker(this.workerType, worker);\n      }\n    }\n  }\n\n  private get workerPool() {\n    return this.loadingContext.workerPool;\n  }\n\n  private get getUrl() {\n    return this.loadingContext.getUrl;\n  }\n\n  private get xhrRequest() {\n    return this.loadingContext.xhrRequest;\n  }\n\n  private get hierarchyPath() {\n    return this.loadingContext.hierarchyPath;\n  }\n\n  private get workerType(): WorkerType {\n    return this.decoder.workerType;\n  }\n\n  private parseHierarchy(node: OctreeGeometryNode, buffer: ArrayBuffer) {\n    const view = new DataView(buffer);\n\n    const bytesPerNode = 22;\n    const numNodes = buffer.byteLength / bytesPerNode;\n\n    const octree = node.octreeGeometry;\n    const nodes: OctreeGeometryNode[] = new Array(numNodes);\n    nodes[0] = node;\n    let nodePos = 1;\n\n    for (let i = 0; i < numNodes; i++) {\n      const current = nodes[i];\n\n      const type = view.getUint8(i * bytesPerNode + 0);\n      const childMask = view.getUint8(i * bytesPerNode + 1);\n      const numPoints = view.getUint32(i * bytesPerNode + 2, true);\n      const byteOffset = view.getBigInt64(i * bytesPerNode + 6, true);\n      const byteSize = view.getBigInt64(i * bytesPerNode + 14, true);\n\n      if (current.nodeType === 2) {\n        // replace proxy with real node\n        current.byteOffset = byteOffset;\n        current.byteSize = byteSize;\n        current.numPoints = numPoints;\n      } else if (type === 2) {\n        // load proxy\n        current.hierarchyByteOffset = byteOffset;\n        current.hierarchyByteSize = byteSize;\n        current.numPoints = numPoints;\n      } else {\n        // load real node\n        current.byteOffset = byteOffset;\n        current.byteSize = byteSize;\n        current.numPoints = numPoints;\n      }\n\n      current.nodeType = type;\n\n      if (current.nodeType === 2) {\n        continue;\n      }\n\n      for (let childIndex = 0; childIndex < 8; childIndex++) {\n        const childExists = ((1 << childIndex) & childMask) !== 0;\n\n        if (!childExists) {\n          continue;\n        }\n\n        const childName = current.name + childIndex;\n\n        const childAABB = createChildAABB(current.boundingBox, childIndex);\n        const child = new OctreeGeometryNode(childName, octree, childAABB);\n        child.name = childName;\n        child.spacing = current.spacing / 2;\n        child.level = current.level + 1;\n\n        (current.children as any)[childIndex] = child;\n        child.parent = current;\n\n        nodes[nodePos] = child;\n        nodePos++;\n      }\n    }\n  }\n\n  private async loadHierarchy(node: OctreeGeometryNode) {\n    const { hierarchyByteOffset, hierarchyByteSize } = node;\n\n    if (hierarchyByteOffset === undefined || hierarchyByteSize === undefined) {\n      throw new Error(\n        `hierarchyByteOffset and hierarchyByteSize are undefined for node ${node.name}`,\n      );\n    }\n\n    const hierarchyUrl = await this.getUrl(this.hierarchyPath);\n\n    const first = hierarchyByteOffset;\n    const last = first + hierarchyByteSize - BigInt(1);\n\n    const headers = { Range: `bytes=${first}-${last}` };\n    const response = await this.xhrRequest(hierarchyUrl, { headers });\n\n    const buffer = await response.arrayBuffer();\n\n    this.parseHierarchy(node, buffer);\n  }\n\n  private getTightBoundingBox({ min, max }: { min: number[]; max: number[] }): Box3 {\n    const box = new Box3(new Vector3().fromArray(min), new Vector3().fromArray(max));\n    box.max.sub(box.min);\n    box.min.set(0, 0, 0);\n\n    return box;\n  }\n}\n\nconst tmpVec3 = new Vector3();\nfunction createChildAABB(aabb: Box3, index: number) {\n  const min = aabb.min.clone();\n  const max = aabb.max.clone();\n  const size = tmpVec3.subVectors(max, min);\n\n  if ((index & 0b0001) > 0) {\n    min.z += size.z / 2;\n  } else {\n    max.z -= size.z / 2;\n  }\n\n  if ((index & 0b0010) > 0) {\n    min.y += size.y / 2;\n  } else {\n    max.y -= size.y / 2;\n  }\n\n  if ((index & 0b0100) > 0) {\n    min.x += size.x / 2;\n  } else {\n    max.x -= size.x / 2;\n  }\n\n  return new Box3(min, max);\n}\n\nconst typenameTypeattributeMap = {\n  double: PointAttributeTypes.DATA_TYPE_DOUBLE,\n  float: PointAttributeTypes.DATA_TYPE_FLOAT,\n  int8: PointAttributeTypes.DATA_TYPE_INT8,\n  uint8: PointAttributeTypes.DATA_TYPE_UINT8,\n  int16: PointAttributeTypes.DATA_TYPE_INT16,\n  uint16: PointAttributeTypes.DATA_TYPE_UINT16,\n  int32: PointAttributeTypes.DATA_TYPE_INT32,\n  uint32: PointAttributeTypes.DATA_TYPE_UINT32,\n  int64: PointAttributeTypes.DATA_TYPE_INT64,\n  uint64: PointAttributeTypes.DATA_TYPE_UINT64,\n};\n\ntype AttributeType = keyof typeof typenameTypeattributeMap;\n\n// A buffer view carries information on how to extract attribute data from a binary buffer.\n// For the majority of cases byteLength and byteOffset will not be needed because matic will\n// always upload single attribute buffer files. However, to be prepared for potential future\n// support of combined buffers byteLength and byteOffset are present to understand where to\n// find the data inside the buffer.\ntype BufferView = {\n  byteLength: number;\n  byteOffset: number;\n  // The uri points to the particular source file and allows for arbitrary buffernames\n  // when using metadata with gltf encoding. When using PotreeConverter 2 to generate the metadata\n  // the uri can be ignored. It will default to the naming convention of the potree v2 format.\n  uri: string;\n};\n\nexport interface Attribute {\n  name: string;\n  description: string;\n  size: number;\n  numElements: number;\n  type: AttributeType;\n  min: number[];\n  max: number[];\n  bufferView: BufferView;\n}\n\nexport interface Metadata {\n  version: string;\n  name: string;\n  description: string;\n  points: number;\n  projection: string;\n  hierarchy: {\n    firstChunkSize: number;\n    stepSize: number;\n    depth: number;\n  };\n  offset: [number, number, number];\n  scale: [number, number, number];\n  spacing: number;\n  boundingBox: {\n    min: [number, number, number];\n    max: [number, number, number];\n  };\n  encoding: string;\n  attributes: Attribute[];\n  compressed: boolean;\n}\n\nexport interface PCL {\n  asset: {\n    extensions: {\n      ext_pix4d_gltf_gs_version: { version: string };\n      OPF_asset_version: { version: string };\n    };\n  };\n}\n\nexport interface LoadingContext {\n  workerPool: WorkerPool;\n  basePath: string;\n  hierarchyPath: string;\n  octreePath: string;\n  gltfColorsPath: string;\n  gltfPositionsPath: string;\n\n  harmonicsEnabled: boolean;\n\n  getUrl: GetUrlFn;\n  xhrRequest: XhrRequest;\n}\n\nexport class OctreeLoader implements LoadingContext {\n  workerPool: WorkerPool = new WorkerPool();\n\n  basePath = '';\n  hierarchyPath = '';\n  octreePath = '';\n  gltfColorsPath = '';\n  gltfPositionsPath = '';\n  harmonicsEnabled: boolean = false;\n\n  getUrl: GetUrlFn;\n  xhrRequest: XhrRequest;\n\n  constructor(\n    getUrl: GetUrlFn,\n    url: string,\n    xhrRequest: XhrRequest,\n    loadHarmonics: boolean = false,\n  ) {\n    this.getUrl = getUrl;\n    this.xhrRequest = xhrRequest;\n    this.basePath = extractBasePath(url);\n    this.hierarchyPath = buildUrl(this.basePath, HIERARCHY_FILE);\n\n    this.octreePath = buildUrl(this.basePath, OCTREE_FILE);\n    this.harmonicsEnabled = loadHarmonics;\n\n    // We default to the known naming convention for glTF datasets\n    this.gltfColorsPath = buildUrl(this.basePath, GLTF_COLORS_FILE);\n    this.gltfPositionsPath = buildUrl(this.basePath, GLTF_POSITIONS_FILE);\n  }\n\n  static parseAttributes(jsonAttributes: Attribute[]) {\n    const attributes = new PointAttributes();\n\n    const replacements: { [key: string]: string } = { rgb: 'rgba' };\n\n    for (const jsonAttribute of jsonAttributes) {\n      const { name, numElements, min, max, bufferView } = jsonAttribute;\n\n      const type = typenameTypeattributeMap[jsonAttribute.type];\n\n      const potreeAttributeName = replacements[name] ? replacements[name] : name;\n\n      const attribute = new PointAttribute(potreeAttributeName, type, numElements);\n\n      if (bufferView) {\n        attribute.uri = bufferView.uri;\n      }\n\n      if (numElements === 1 && min && max) {\n        attribute.range = [min[0], max[0]];\n      } else {\n        attribute.range = [min, max];\n      }\n\n      if (name === 'gps-time') {\n        // HACK: Guard against bad gpsTime range in metadata, see potree/potree#909\n        if (typeof attribute.range[0] === 'number' && attribute.range[0] === attribute.range[1]) {\n          attribute.range[1] += 1;\n        }\n      }\n\n      attribute.initialRange = attribute.range;\n\n      attributes.add(attribute);\n    }\n\n    {\n      const hasNormals =\n        attributes.attributes.find((a) => a.name === 'NormalX') !== undefined &&\n        attributes.attributes.find((a) => a.name === 'NormalY') !== undefined &&\n        attributes.attributes.find((a) => a.name === 'NormalZ') !== undefined;\n\n      if (hasNormals) {\n        const vector = {\n          name: 'NORMAL',\n          attributes: ['NormalX', 'NormalY', 'NormalZ'],\n        };\n        attributes.addVector(vector);\n      }\n    }\n\n    return attributes;\n  }\n\n  async load(url: string) {\n    const metadata = await this.fetchMetadata(url);\n\n    //Used to know the compression definition in the pcl.gltf file, this is used to know if the\n    //splats are compressed by the PNext compression standard.\n    try {\n      const compressionTypeFile = await this.fetchPCL(\n        buildUrl(extractBasePath(url), COMPRESSION_TYPE_FILE),\n      );\n      metadata.compressed =\n        Number(compressionTypeFile.asset.extensions.ext_pix4d_gltf_gs_version.version) >= 2;\n    } catch (e) {\n      console.warn('there is no pcl.gltf file to define the compression of the splats');\n    }\n\n    const attributes = OctreeLoader.parseAttributes(metadata.attributes);\n\n    this.applyCustomBufferURI(metadata.encoding, attributes);\n\n    const loader = this.createLoader(url, metadata);\n\n    const boundingBox = this.createBoundingBox(metadata);\n    const offset = this.getOffset(boundingBox);\n    const octree = this.initializeOctree(loader, url, metadata, boundingBox, offset, attributes);\n    const root = this.initializeRootNode(octree, boundingBox, metadata);\n    octree.root = root;\n\n    loader.load(root);\n\n    return { geometry: octree };\n  }\n\n  private async fetchMetadata(url: string): Promise<Metadata> {\n    const response = await this.xhrRequest(url);\n    return response.json();\n  }\n\n  private async fetchPCL(url: string): Promise<PCL> {\n    const response = await this.xhrRequest(url);\n    return response.json();\n  }\n\n  private applyCustomBufferURI(encoding: string, attributes: any) {\n    // Only datasets with GLTF encoding support custom buffer URIs -\n    // as opposed to datasets with DEFAULT encoding coming from PotreeConverter\n    if (encoding === 'GLTF') {\n      this.gltfPositionsPath = attributes.getAttribute('position')?.uri ?? this.gltfPositionsPath;\n      this.gltfColorsPath = attributes.getAttribute('rgba')?.uri ?? this.gltfColorsPath;\n    }\n  }\n\n  private createLoader(url: string, metadata: Metadata): NodeLoader {\n    return new NodeLoader(url, metadata, this);\n  }\n\n  private createBoundingBox(metadata: Metadata): Box3 {\n    const min = new Vector3(...metadata.boundingBox.min);\n    const max = new Vector3(...metadata.boundingBox.max);\n    const boundingBox = new Box3(min, max);\n    return boundingBox;\n  }\n\n  private getOffset(boundingBox: Box3): Vector3 {\n    const offset = boundingBox.min.clone();\n    boundingBox.min.sub(offset);\n    boundingBox.max.sub(offset);\n    return offset;\n  }\n\n  private initializeOctree(\n    loader: NodeLoader,\n    url: string,\n    metadata: Metadata,\n    boundingBox: Box3,\n    offset: Vector3,\n    attributes: any,\n  ): OctreeGeometry {\n    const octree = new OctreeGeometry(loader, boundingBox);\n    octree.url = url;\n    octree.spacing = metadata.spacing;\n    octree.scale = metadata.scale;\n    octree.projection = metadata.projection;\n    octree.boundingBox = boundingBox;\n    octree.boundingSphere = boundingBox.getBoundingSphere(new Sphere());\n    octree.tightBoundingSphere = boundingBox.getBoundingSphere(new Sphere());\n    octree.tightBoundingBox = this.getTightBoundingBox(metadata);\n    octree.offset = offset;\n    octree.pointAttributes = attributes;\n    return octree;\n  }\n\n  private initializeRootNode(\n    octree: OctreeGeometry,\n    boundingBox: Box3,\n    metadata: Metadata,\n  ): OctreeGeometryNode {\n    const root = new OctreeGeometryNode('r', octree, boundingBox);\n    root.level = 0;\n    root.nodeType = 2;\n    root.hierarchyByteOffset = BigInt(0);\n    root.hierarchyByteSize = BigInt(metadata.hierarchy.firstChunkSize);\n    root.spacing = octree.spacing;\n    root.byteOffset = BigInt(0);\n    return root;\n  }\n\n  getTightBoundingBox(metadata: Metadata): Box3 {\n    const positionAttribute = metadata.attributes.find((attr) => attr.name === 'position');\n\n    if (!positionAttribute || !positionAttribute.min || !positionAttribute.max) {\n      console.warn(\n        'Position attribute (min, max) not found. Falling back to boundingBox for tightBoundingBox',\n      );\n      return new Box3(\n        new Vector3(...metadata.boundingBox.min),\n        new Vector3(...metadata.boundingBox.max),\n      );\n    }\n\n    const offset = metadata.boundingBox.min;\n    const tightBoundingBox = new Box3(\n      new Vector3(\n        positionAttribute.min[0] - offset[0],\n        positionAttribute.min[1] - offset[1],\n        positionAttribute.min[2] - offset[2],\n      ),\n      new Vector3(\n        positionAttribute.max[0] - offset[0],\n        positionAttribute.max[1] - offset[1],\n        positionAttribute.max[2] - offset[2],\n      ),\n    );\n\n    return tightBoundingBox;\n  }\n}\n","import { GetUrlFn, XhrRequest } from '../loading/types';\nimport { OctreeLoader } from './octree-loader';\n\nexport async function loadOctree(\n  url: string,\n  getUrl: GetUrlFn,\n  xhrRequest: XhrRequest,\n  loadHarmonics: boolean = false,\n) {\n  const trueUrl = await getUrl(url);\n  const loader = new OctreeLoader(getUrl, url, xhrRequest, loadHarmonics);\n  const { geometry } = await loader.load(trueUrl);\n\n  return geometry;\n}\n","import { IPointCloudGeometryNode } from './types';\nimport { PointCloudOctreeNode } from './point-cloud-octree-node';\n\nexport function isGeometryNode(node?: any): node is IPointCloudGeometryNode {\n  return node !== undefined && node !== null && node.isGeometryNode;\n}\n\nexport function isTreeNode(node?: any): node is PointCloudOctreeNode {\n  return node !== undefined && node !== null && node.isTreeNode;\n}\n","/**\n * from: http://eloquentjavascript.net/1st_edition/appendix2.html\n *\n */\n\nexport function BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1);\n  },\n\n  pop: function () {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  },\n\n  remove: function (node) {\n    var length = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (var i = 0; i < length; i++) {\n      if (this.content[i] != node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      var end = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i == length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  },\n\n  size: function () {\n    return this.content.length;\n  },\n\n  bubbleUp: function (n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n],\n      score = this.scoreFunction(element);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(parent)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  },\n\n  sinkDown: function (n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  },\n};\n","import {\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  LineBasicMaterial,\n  LineSegments,\n} from 'three';\n\n/**\n *\n * code adapted from three.js BoxHelper.js\n * https://github.com/mrdoob/three.js/blob/dev/src/helpers/BoxHelper.js\n *\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / http://github.com/Mugen87\n * @author mschuetz / http://potree.org\n */\n\nexport class Box3Helper extends LineSegments {\n  constructor(box: Box3, color: Color = new Color(0xffff00)) {\n    // prettier-ignore\n    const indices = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]);\n    // prettier-ignore\n    const positions = new Float32Array([\n      box.min.x, box.min.y, box.min.z,\n      box.max.x, box.min.y, box.min.z,\n      box.max.x, box.min.y, box.max.z,\n      box.min.x, box.min.y, box.max.z,\n      box.min.x, box.max.y, box.min.z,\n      box.max.x, box.max.y, box.min.z,\n      box.max.x, box.max.y, box.max.z,\n      box.min.x, box.max.y, box.max.z\n    ]);\n\n    const geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(indices, 1));\n    geometry.setAttribute('position', new BufferAttribute(positions, 3));\n\n    const material = new LineBasicMaterial({ color: color });\n\n    super(geometry, material);\n  }\n}\n","import { IPointCloudTreeNode } from '../types';\n\nexport type Node = IPointCloudTreeNode;\n\nexport class LRUItem {\n  next: LRUItem | null = null;\n  previous: LRUItem | null = null;\n  constructor(public node: Node) {}\n}\n\n/**\n * A doubly-linked-list of the least recently used elements.\n */\nexport class LRU {\n  // the least recently used item\n  first: LRUItem | null = null;\n  // the most recently used item\n  last: LRUItem | null = null;\n  numPoints: number = 0;\n\n  private items = new Map<number, LRUItem>();\n\n  constructor(public pointBudget: number = 1_000_000) {}\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  has(node: Node): boolean {\n    return this.items.has(node.id);\n  }\n\n  /**\n   * Makes the specified the most recently used item. if the list does not contain node, it will\n   * be added.\n   */\n  touch(node: Node) {\n    if (!node.loaded) {\n      return;\n    }\n\n    const item = this.items.get(node.id);\n    if (item) {\n      this.touchExisting(item);\n    } else {\n      this.addNew(node);\n    }\n  }\n\n  private addNew(node: Node): void {\n    const item = new LRUItem(node);\n    item.previous = this.last;\n    this.last = item;\n    if (item.previous) {\n      item.previous.next = item;\n    }\n\n    if (!this.first) {\n      this.first = item;\n    }\n\n    this.items.set(node.id, item);\n    this.numPoints += node.numPoints;\n  }\n\n  private touchExisting(item: LRUItem): void {\n    if (!item.previous) {\n      // handle touch on first element\n      if (item.next) {\n        this.first = item.next;\n        this.first.previous = null;\n        item.previous = this.last;\n        item.next = null;\n        this.last = item;\n\n        if (item.previous) {\n          item.previous.next = item;\n        }\n      }\n    } else if (!item.next) {\n      // handle touch on last element\n    } else {\n      // handle touch on any other element\n      item.previous.next = item.next;\n      item.next.previous = item.previous;\n      item.previous = this.last;\n      item.next = null;\n      this.last = item;\n\n      if (item.previous) {\n        item.previous.next = item;\n      }\n    }\n  }\n\n  remove(node: Node) {\n    const item = this.items.get(node.id);\n    if (!item) {\n      return;\n    }\n\n    if (this.items.size === 1) {\n      this.first = null;\n      this.last = null;\n    } else {\n      if (!item.previous) {\n        this.first = item.next;\n        this.first!.previous = null;\n      }\n\n      if (!item.next) {\n        this.last = item.previous;\n        this.last!.next = null;\n      }\n\n      if (item.previous && item.next) {\n        item.previous.next = item.next;\n        item.next.previous = item.previous;\n      }\n    }\n\n    this.items.delete(node.id);\n    this.numPoints -= node.numPoints;\n  }\n\n  getLRUItem(): Node | undefined {\n    return this.first ? this.first.node : undefined;\n  }\n\n  freeMemory(memoryMultiplier: number = 2): void {\n    if (this.items.size <= 1) {\n      return;\n    }\n\n    while (this.numPoints > this.pointBudget * memoryMultiplier) {\n      const node = this.getLRUItem();\n      if (node) {\n        this.disposeSubtree(node);\n      }\n    }\n  }\n\n  disposeSubtree(node: Node): void {\n    // Collect all the nodes which are to be disposed and removed.\n    const nodesToDispose: Node[] = [node];\n    node.traverse((n) => {\n      if (n.loaded) {\n        nodesToDispose.push(n);\n      }\n    });\n\n    // Dispose of all the nodes in one go.\n    for (const n of nodesToDispose) {\n      n.dispose();\n      this.remove(n);\n    }\n  }\n}\n","import {\n  Box3,\n  Camera,\n  Frustum,\n  Matrix4,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Ray,\n  Vector2,\n  Vector3,\n  WebGLRenderer,\n} from 'three';\nimport {\n  DEFAULT_POINT_BUDGET,\n  MAX_LOADS_TO_GPU,\n  MAX_NUM_NODES_LOADING,\n  MAX_AMOUNT_OF_SPLATS,\n  PERSPECTIVE_CAMERA,\n  MEMORY_SCALE,\n} from './constants';\nimport { FEATURES } from './features';\nimport { BinaryLoader, GetUrlFn, loadPOC } from './loading';\nimport { loadOctree } from './loading2/load-octree';\nimport { ClipMode } from './materials';\nimport { PointCloudOctree } from './point-cloud-octree';\nimport { PointCloudOctreeNode } from './point-cloud-octree-node';\nimport { PickParams, PointCloudOctreePicker } from './point-cloud-octree-picker';\nimport { isGeometryNode, isTreeNode } from './type-predicates';\nimport {\n  IPointCloudGeometryNode,\n  IPointCloudTreeNode,\n  IPotree,\n  IVisibilityUpdateResult,\n  PCOGeometry,\n  PickPoint,\n} from './types';\nimport { BinaryHeap } from './utils/binary-heap';\nimport { Box3Helper } from './utils/box3-helper';\nimport { LRU } from './utils/lru';\n\nexport class QueueItem {\n  constructor(\n    public pointCloudIndex: number,\n    public weight: number,\n    public node: IPointCloudTreeNode,\n    public parent?: IPointCloudTreeNode | null,\n  ) {}\n}\n\ntype GeometryLoader = (\n  url: string,\n  getUrl: GetUrlFn,\n  xhrRequest: (input: RequestInfo, init?: RequestInit) => Promise<Response>,\n  loadHarmonics: boolean,\n) => Promise<PCOGeometry>;\n\nconst GEOMETRY_LOADERS = {\n  v1: loadPOC,\n  v2: loadOctree,\n} satisfies Record<string, GeometryLoader>;\n\nexport type PotreeVersion = keyof typeof GEOMETRY_LOADERS;\n\nexport class Potree implements IPotree {\n  private static picker: PointCloudOctreePicker | undefined;\n  private _pointBudget: number = DEFAULT_POINT_BUDGET;\n  private _rendererSize: Vector2 = new Vector2();\n\n  maxNumNodesLoading: number = MAX_NUM_NODES_LOADING;\n  memoryScale: number = MEMORY_SCALE;\n  features = FEATURES;\n  lru = new LRU(this._pointBudget);\n\n  private readonly loadGeometry: GeometryLoader;\n\n  constructor(version: PotreeVersion = 'v1') {\n    this.loadGeometry = GEOMETRY_LOADERS[version];\n  }\n\n  loadPointCloud(\n    url: string,\n    getUrl: GetUrlFn,\n    xhrRequest = (input: RequestInfo, init?: RequestInit) => fetch(input, init),\n    loadHarmonics: boolean = false,\n    maxAmountOfSplats: number = MAX_AMOUNT_OF_SPLATS,\n  ): Promise<PointCloudOctree> {\n    return this.loadGeometry(url, getUrl, xhrRequest, loadHarmonics).then(\n      (geometry) =>\n        new PointCloudOctree(this, geometry, undefined, loadHarmonics, maxAmountOfSplats),\n    );\n  }\n\n  updatePointClouds(\n    pointClouds: PointCloudOctree[],\n    camera: Camera,\n    renderer: WebGLRenderer,\n    callback = () => {},\n  ): IVisibilityUpdateResult {\n    const result = this.updateVisibility(pointClouds, camera, renderer);\n\n    for (let i = 0; i < pointClouds.length; i++) {\n      const pointCloud = pointClouds[i];\n      if (pointCloud.disposed) {\n        continue;\n      }\n\n      pointCloud.material.updateMaterial(pointCloud, pointCloud.visibleNodes, camera, renderer);\n      pointCloud.updateVisibleBounds();\n      pointCloud.updateBoundingBoxes();\n\n      //For the splats\n      renderer.getSize(this._rendererSize);\n      pointCloud.updateSplats(camera, this._rendererSize, callback);\n    }\n\n    this.lru.freeMemory(this.memoryScale);\n\n    return result;\n  }\n\n  static pick(\n    pointClouds: PointCloudOctree[],\n    renderer: WebGLRenderer,\n    camera: Camera,\n    ray: Ray,\n    params: Partial<PickParams> = {},\n  ): PickPoint | null {\n    Potree.picker = Potree.picker || new PointCloudOctreePicker();\n    return Potree.picker.pick(renderer, camera, ray, pointClouds, params);\n  }\n\n  get pointBudget(): number {\n    return this._pointBudget;\n  }\n\n  set pointBudget(value: number) {\n    if (value !== this._pointBudget) {\n      this._pointBudget = value;\n      this.lru.pointBudget = value;\n      this.lru.freeMemory(this.memoryScale);\n    }\n  }\n\n  static set maxLoaderWorkers(value: number) {\n    BinaryLoader.WORKER_POOL.maxWorkers = value;\n  }\n\n  static get maxLoaderWorkers(): number {\n    return BinaryLoader.WORKER_POOL.maxWorkers;\n  }\n\n  private updateVisibility(\n    pointClouds: PointCloudOctree[],\n    camera: Camera,\n    renderer: WebGLRenderer,\n  ): IVisibilityUpdateResult {\n    let numVisiblePoints = 0;\n\n    const visibleNodes: PointCloudOctreeNode[] = [];\n    const unloadedGeometry: IPointCloudGeometryNode[] = [];\n\n    // calculate object space frustum and cam pos and setup priority queue\n    const { frustums, cameraPositions, priorityQueue } = this.updateVisibilityStructures(\n      pointClouds,\n      camera,\n    );\n\n    let loadedToGPUThisFrame = 0;\n    let exceededMaxLoadsToGPU = false;\n    let nodeLoadFailed = false;\n    let queueItem: QueueItem | undefined;\n\n    while ((queueItem = priorityQueue.pop()) !== undefined) {\n      let node = queueItem.node;\n\n      // If we will end up with too many points, we stop right away.\n      if (numVisiblePoints + node.numPoints > this.pointBudget) {\n        break;\n      }\n\n      const pointCloudIndex = queueItem.pointCloudIndex;\n      const pointCloud = pointClouds[pointCloudIndex];\n\n      const maxLevel = pointCloud.maxLevel !== undefined ? pointCloud.maxLevel : Infinity;\n\n      if (\n        node.level > maxLevel ||\n        !frustums[pointCloudIndex].intersectsBox(node.boundingBox) ||\n        this.shouldClip(pointCloud, node.boundingBox)\n      ) {\n        continue;\n      }\n\n      numVisiblePoints += node.numPoints;\n      pointCloud.numVisiblePoints += node.numPoints;\n\n      const parentNode = queueItem.parent;\n\n      if (isGeometryNode(node) && (!parentNode || isTreeNode(parentNode))) {\n        if (node.loaded && loadedToGPUThisFrame < MAX_LOADS_TO_GPU) {\n          node = pointCloud.toTreeNode(node, parentNode);\n          loadedToGPUThisFrame++;\n        } else if (!node.failed) {\n          if (node.loaded && loadedToGPUThisFrame >= MAX_LOADS_TO_GPU) {\n            exceededMaxLoadsToGPU = true;\n          }\n          unloadedGeometry.push(node);\n          pointCloud.visibleGeometry.push(node);\n        } else {\n          nodeLoadFailed = true;\n          continue;\n        }\n      }\n\n      if (isTreeNode(node)) {\n        this.updateTreeNodeVisibility(pointCloud, node, visibleNodes);\n        pointCloud.visibleGeometry.push(node.geometryNode);\n      }\n\n      const halfHeight =\n        0.5 * renderer.getSize(this._rendererSize).height * renderer.getPixelRatio();\n\n      this.updateChildVisibility(\n        queueItem,\n        priorityQueue,\n        pointCloud,\n        node,\n        cameraPositions[pointCloudIndex],\n        camera,\n        halfHeight,\n      );\n    } // end priority queue loop\n\n    const numNodesToLoad = Math.min(this.maxNumNodesLoading, unloadedGeometry.length);\n    const nodeLoadPromises: Promise<void>[] = [];\n    for (let i = 0; i < numNodesToLoad; i++) {\n      nodeLoadPromises.push(unloadedGeometry[i].load());\n    }\n\n    return {\n      visibleNodes: visibleNodes,\n      numVisiblePoints: numVisiblePoints,\n      exceededMaxLoadsToGPU: exceededMaxLoadsToGPU,\n      nodeLoadFailed: nodeLoadFailed,\n      nodeLoadPromises: nodeLoadPromises,\n    };\n  }\n\n  private updateTreeNodeVisibility(\n    pointCloud: PointCloudOctree,\n    node: PointCloudOctreeNode,\n    visibleNodes: IPointCloudTreeNode[],\n  ): void {\n    this.lru.touch(node.geometryNode);\n\n    const sceneNode = node.sceneNode;\n    sceneNode.visible = true;\n    sceneNode.material = pointCloud.material;\n    sceneNode.updateMatrix();\n    sceneNode.matrixWorld.multiplyMatrices(pointCloud.matrixWorld, sceneNode.matrix);\n\n    visibleNodes.push(node);\n    pointCloud.visibleNodes.push(node);\n\n    this.updateBoundingBoxVisibility(pointCloud, node);\n  }\n\n  private updateChildVisibility(\n    queueItem: QueueItem,\n    priorityQueue: BinaryHeap<QueueItem>,\n    pointCloud: PointCloudOctree,\n    node: IPointCloudTreeNode,\n    cameraPosition: Vector3,\n    camera: Camera,\n    halfHeight: number,\n  ): void {\n    const children = node.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child === null) {\n        continue;\n      }\n\n      const sphere = child.boundingSphere;\n      const distance = sphere.center.distanceTo(cameraPosition);\n      const radius = sphere.radius;\n\n      let projectionFactor = 0.0;\n\n      if (camera.type === PERSPECTIVE_CAMERA) {\n        const perspective = camera as PerspectiveCamera;\n        const fov = (perspective.fov * Math.PI) / 180.0;\n        const slope = Math.tan(fov / 2.0);\n        projectionFactor = halfHeight / (slope * distance);\n      } else {\n        const orthographic = camera as OrthographicCamera;\n        projectionFactor = (2 * halfHeight) / (orthographic.top - orthographic.bottom);\n      }\n\n      const screenPixelRadius = radius * projectionFactor;\n\n      // Don't add the node if it'll be too small on the screen.\n      if (screenPixelRadius < pointCloud.minNodePixelSize) {\n        continue;\n      }\n\n      // Nodes which are larger will have priority in loading/displaying.\n      const weight = distance < radius ? Number.MAX_VALUE : 1 + screenPixelRadius + 1 / distance;\n      //const weight = Number.MAX_VALUE;\n      priorityQueue.push(new QueueItem(queueItem.pointCloudIndex, weight, child, node));\n    }\n  }\n\n  private updateBoundingBoxVisibility(\n    pointCloud: PointCloudOctree,\n    node: PointCloudOctreeNode,\n  ): void {\n    if (pointCloud.showBoundingBox && !node.boundingBoxNode) {\n      const boxHelper = new Box3Helper(node.boundingBox);\n      boxHelper.matrixAutoUpdate = false;\n      pointCloud.boundingBoxNodes.push(boxHelper);\n      node.boundingBoxNode = boxHelper;\n      node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\n    } else if (pointCloud.showBoundingBox && node.boundingBoxNode) {\n      node.boundingBoxNode.visible = true;\n      node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\n    } else if (!pointCloud.showBoundingBox && node.boundingBoxNode) {\n      node.boundingBoxNode.visible = false;\n    }\n  }\n\n  private shouldClip(pointCloud: PointCloudOctree, boundingBox: Box3): boolean {\n    const material = pointCloud.material;\n\n    if (material.numClipBoxes === 0 || material.clipMode !== ClipMode.CLIP_OUTSIDE) {\n      return false;\n    }\n\n    const box2 = boundingBox.clone();\n    pointCloud.updateMatrixWorld(true);\n    box2.applyMatrix4(pointCloud.matrixWorld);\n\n    const clipBoxes = material.clipBoxes;\n    for (let i = 0; i < clipBoxes.length; i++) {\n      const clipMatrixWorld = clipBoxes[i].matrix;\n      const clipBoxWorld = new Box3(\n        new Vector3(-0.5, -0.5, -0.5),\n        new Vector3(0.5, 0.5, 0.5),\n      ).applyMatrix4(clipMatrixWorld);\n      if (box2.intersectsBox(clipBoxWorld)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private updateVisibilityStructures = (() => {\n    const frustumMatrix = new Matrix4();\n    const inverseWorldMatrix = new Matrix4();\n    const cameraMatrix = new Matrix4();\n\n    return (\n      pointClouds: PointCloudOctree[],\n      camera: Camera,\n    ): {\n      frustums: Frustum[];\n      cameraPositions: Vector3[];\n      priorityQueue: BinaryHeap<QueueItem>;\n    } => {\n      const frustums: Frustum[] = [];\n      const cameraPositions: Vector3[] = [];\n      const priorityQueue = new BinaryHeap<QueueItem>((x) => 1 / x.weight);\n\n      for (let i = 0; i < pointClouds.length; i++) {\n        const pointCloud = pointClouds[i];\n\n        if (!pointCloud.initialized()) {\n          continue;\n        }\n\n        pointCloud.numVisiblePoints = 0;\n        pointCloud.visibleNodes = [];\n        pointCloud.visibleGeometry = [];\n\n        camera.updateMatrixWorld(false);\n\n        // Furstum in object space.\n        const inverseViewMatrix = camera.matrixWorldInverse;\n        const worldMatrix = pointCloud.matrixWorld;\n        frustumMatrix\n          .identity()\n          .multiply(camera.projectionMatrix)\n          .multiply(inverseViewMatrix)\n          .multiply(worldMatrix);\n        frustums.push(new Frustum().setFromProjectionMatrix(frustumMatrix));\n\n        // Camera position in object space\n        inverseWorldMatrix.copy(worldMatrix).invert();\n        cameraMatrix.identity().multiply(inverseWorldMatrix).multiply(camera.matrixWorld);\n        cameraPositions.push(new Vector3().setFromMatrixPosition(cameraMatrix));\n\n        if (pointCloud.visible && pointCloud.root !== null) {\n          const weight = Number.MAX_VALUE;\n          priorityQueue.push(new QueueItem(i, weight, pointCloud.root));\n        }\n\n        // Hide any previously visible nodes. We will later show only the needed ones.\n        if (isTreeNode(pointCloud.root)) {\n          pointCloud.hideDescendants(pointCloud.root.sceneNode);\n        }\n\n        for (const boundingBoxNode of pointCloud.boundingBoxNodes) {\n          boundingBoxNode.visible = false;\n        }\n      }\n\n      return { frustums, cameraPositions, priorityQueue };\n    };\n  })();\n}\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__604__","Worker_fn","undefined","content","workerConstructor","workerOptions","url","globalScope","window","blob","Blob","e","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","append","getBlob","URL","webkitURL","objectURL","createObjectURL","worker","revokeObjectURL","concat","encodeURIComponent","Error","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ClipMode","PointSizeType","PointShape","TreeType","PointOpacityType","PointColorType","NormalFilteringMode","PointCloudMixingMode","BlurMaterial","ShaderMaterial","vertexShader","fragmentShader","uniforms","screenWidth","type","screenHeight","map","PERSPECTIVE_CAMERA","COLOR_BLACK","Color","DEFAULT_HIGHLIGHT_COLOR","Vector4","getIndexFromName","name","parseInt","charAt","length","byLevelAndIndex","b","na","nb","handleFailedRequest","response","status","handleEmptyBuffer","buffer","byteLength","DEFAULT_CLASSIFICATION","DEFAULT","GRAYSCALE","INFERNO","PLASMA","RAINBOW","SPECTRAL","VIRIDIS","YELLOW_GREEN","generateDataTexture","width","height","color","size","data","Uint8Array","Math","floor","g","i","texture","DataTexture","RGBAFormat","needsUpdate","magFilter","NearestFilter","generateGradientTexture","gradient","canvas","document","createElement","context","getContext","rect","ctxGradient","createLinearGradient","step","addColorStop","getHexString","fillStyle","fill","CanvasTexture","minFilter","LinearFilter","generateClassificationTexture","classification","x","y","z","w","TREE_TYPE_DEFS","OCTREE","KDTREE","SIZE_TYPE_DEFS","FIXED","ATTENUATED","ADAPTIVE","OPACITY_DEFS","SHAPE_DEFS","SQUARE","CIRCLE","PARABOLOID","COLOR_DEFS","RGB","COLOR","DEPTH","HEIGHT","INTENSITY","INTENSITY_GRADIENT","LOD","POINT_INDEX","CLASSIFICATION","RETURN_NUMBER","SOURCE","NORMAL","PHONG","RGB_HEIGHT","COMPOSITE","CLIP_MODE_DEFS","DISABLED","CLIP_OUTSIDE","HIGHLIGHT_INSIDE","CLIP_HORIZONTALLY","CLIP_VERTICALLY","CLIP_INSIDE","PointCloudMaterial","RawShaderMaterial","constructor","parameters","super","useDrawingBufferSize","lights","fog","colorRgba","numClipBoxes","clipBoxes","visibleNodeTextureOffsets","Map","_gradient","gradientTexture","this","_classification","classificationTexture","bbSize","makeUniform","blendDepthSupplement","blendHardness","classificationLUT","Texture","clipBoxCount","clipExtent","depthMap","diffuse","fov","heightMax","heightMin","intensityBrightness","intensityContrast","intensityGamma","intensityRange","isLeafNode","level","maxSize","minSize","octreeSize","opacity","pcIndex","rgbBrightness","rgbContrast","rgbGamma","spacing","toModel","transition","uColor","visibleNodes","visibleNodesTexture","vnStart","wClassification","wElevation","wIntensity","wReturnNumber","wRGB","wSourceID","opacityAttenuation","filterByNormalThreshold","highlightedPointCoordinate","Vector3","highlightedPointColor","clone","enablePointHighlighting","highlightedPointScale","backgroundMap","normalFilteringMode","ABSOLUTE_NORMAL_FILTERING_MODE","pointCloudID","pointCloudMixingMode","CHECKBOARD","stripeDistanceX","stripeDistanceY","stripeDivisorX","stripeDivisorY","pointCloudMixAngle","renderDepth","useClipBox","weighted","pointColorType","pointSizeType","clipMode","useEDL","shape","treeType","pointOpacityType","useFilterByNormal","useTextureBlending","usePointCloudMixing","highlightPoint","attributes","position","normal","intensity","returnNumber","numberOfReturns","pointSourceID","indices","glslVersion","GLSL3","tex","setUniform","getValid","Boolean","defaultAttributeValues","vertexColors","updateShaderSource","dispose","clearVisibleNodeTextureOffsets","clear","applyDefines","blending","NoBlending","transparent","depthTest","depthWrite","depthFunc","LessEqualDepth","AdditiveBlending","shaderSrc","parts","push","join","setPointCloudMixingMode","mode","getPointCloudMixingMode","STRIPES","setClipBoxes","doUpdate","clipBoxesLength","clipBoxesArray","Float32Array","set","inverse","elements","isNaN","Infinity","copy","keys","isEqual","equals","recomputeClassification","elevationRange","getUniform","uObj","updateMaterial","octree","camera","renderer","pixelRatio","getPixelRatio","PI","renderTarget","getRenderTarget","domElement","clientWidth","clientHeight","getDrawingBufferSize","helperVec2","maxScale","max","scale","pcoGeometry","boundingBox","getSize","helperVec3","updateVisibilityTextureData","nodes","sort","offsetsToChild","Array","node","parentName","slice","parentOffset","parentOffsetToChild","min","offset","index","image","makeOnBeforeRender","_renderer","_scene","_camera","_geometry","material","pointCloudMaterial","materialUniforms","indexOf","uniformsNeedUpdate","uniform","uniformName","requireSrcUpdate","target","propertyKey","requiresShaderUpdate","fieldName","toString","PointAttributeName","Vector2","POINT_ATTRIBUTE_TYPES","DATA_TYPE_DOUBLE","ordinal","DATA_TYPE_FLOAT","DATA_TYPE_INT8","DATA_TYPE_UINT8","DATA_TYPE_INT16","DATA_TYPE_UINT16","DATA_TYPE_INT32","DATA_TYPE_UINT32","DATA_TYPE_INT64","DATA_TYPE_UINT64","makePointAttribute","numElements","byteSize","RGBA_PACKED","COLOR_PACKED","POINT_ATTRIBUTES","POSITION_CARTESIAN","RGB_PACKED","NORMAL_FLOATS","FILLER_1B","FILLER","NORMAL_SPHEREMAPPED","NORMAL_OCT16","PointAttributes","pointAttributeNames","pointAttributeName","pointAttribute","add","hasColors","find","isColorAttribute","hasNormals","isNormalAttribute","computeTransformedBoundingBox","box","transform","Box3","setFromPoints","applyMatrix4","createChildAABB","aabb","subVectors","PointCloudOctreeGeometryNode","EventDispatcher","id","idCount","hasChildren","children","mean","numPoints","loaded","loading","failed","parent","oneTimeDisposeHandlers","isTreeNode","isGeometryNode","tightBoundingBox","boundingSphere","getBoundingSphere","Sphere","geometry","forEach","handler","getUrl","version","loader","pathParts","octreeDir","equalOrHigher","getHierarchyBaseUrl","upTo","getHierarchyUrl","addChild","child","traverse","cb","includeSelf","stack","current","pop","load","canLoad","Promise","resolve","promise","numNodesLoading","hierarchyStepSize","loadHierachyThenPoints","loadPoints","catch","reason","disposed","maxNumNodesLoading","then","xhrRequest","res","okRes","arrayBuffer","okBuffer","loadHierarchy","substr","numParts","path","view","DataView","firstNodeData","getNodeData","decoded","stackNodeData","shift","mask","nodeData","addNode","getUint8","getUint32","pco","substring","parentNode","pow","PointCloudOctreeGeometry","pointAttributes","projection","addNodeLoadedCallback","callback","callbacks","clearNodeLoadedCallbacks","PointCloudOctreeNode","geometryNode","sceneNode","boundingBoxNode","disposeSceneNode","BufferGeometry","array","clamp","PointCloudOctreePicker","pickState","pick","ray","octrees","params","getPickState","pickMaterial","ceil","updatePickRenderTarget","pixelPosition","addVectors","origin","direction","project","pickWndSize","pickWindowSize","halfPickWndSize","prepareRender","renderedNodes","render","pixels","readPixels","hit","findHit","getPickPoint","setScissor","setScissorTest","state","buffers","depth","setTest","setMask","setBlending","setRenderTarget","getClearColor","clearColor","oldClearAlpha","getClearAlpha","setClearColor","nodesOnRay","updatePickMaterial","onBeforePickRender","scene","createTempNodes","rayClone","sphere","helperSphere","matrixWorld","intersectsSphere","readRenderTargetPixels","nodeIndexOffset","tempNodes","tempNode","Points","matrix","matrixAutoUpdate","frustumCulled","nodeIndex","console","error","onBeforeRender","nodeMaterial","pickOutsideClipRegion","makePickRenderTarget","setSize","WebGLRenderTarget","format","ibuffer","Uint32Array","Number","MAX_VALUE","u","v","distance","pIndex","point","points","pointCloud","property","values","addPositionToPickPoint","addNormalToPickPoint","itemSize","j","fromBufferAttribute","normal4","Scene","OctreeGeometry","tightBoundingSphere","PointCloudTree","Object3D","initialized","sortWorker","charCodeAt","c","wasmInstance","wasmMemory","splatCount","indexesToSortOffset","sortedIndexesOffset","mappedDistancesOffset","frequenciesOffset","centersOffset","modelViewProjOffset","countsZero","distanceMapRange","onmessage","init","_splatCount","memoryRequiredForIndexesToSort","memoryRequiredForCenters","BytesPerFloat","memoryRequiredForMappedDistances","memoryRequiredForIntermediateSortBuffers","totalRequiredMemory","MemoryPageSize","totalPagesRequired","sorterWasmImport","env","memory","WebAssembly","Memory","initial","maximum","atob","split","instantiate","result","instance","Int32Array","postMessage","sorterReady","startWasmModule","centers","splats","totalSplats","modelViewProj","sortIndexes","sortedIndexesC","dataSorted","SplatsMesh","debug","maxPointBudget","renderHamonics","forceSorting","continuousSorting","textures","nodesAsString","lastSortViewDir","sortViewDir","lastSortViewPos","sortViewOffset","enableSorting","enabled","instanceCount","debugMode","rendererSize","harmonicsEnabled","indexesBuffer","indexesToSort","sqrt","degree1Size","degree2Size","degree3Size","bufferCenters","bufferPositions","bufferScale","bufferOrientation","bufferSorted","bufferPosColor","bufferCovariance0","bufferCovariance1","bufferNodes","bufferNodes2","bufferNodesIndices","bufferVisibilityNodes","bufferHarmonics1","bufferHarmonics2","bufferHarmonics3","textureNode","FloatType","textureNode2","textureSorted","RedIntegerFormat","UnsignedIntType","internalFormat","textureNodeIndices","textureCovariance0","textureCovariance1","RGFormat","texturePosColor","RGBAIntegerFormat","textureHarmonics1","textureHarmonics2","textureHarmonics3","textureVisibilityNodes","text","initialize","Worker","sorter","quadVertices","quadIndices","Uint16Array","shader","side","FrontSide","focal","inverseFocalAdjustment","splatScale","initialSplatScale","basisViewport","globalOffset","sortedTexture","covarianceTexture0","covarianceTexture1","posColorTexture","nodeTexture","nodeTexture2","nodeIndicesTexture","indicesTexture","harmonicsTexture1","harmonicsTexture2","harmonicsTexture3","cameraPosition","harmonicsDegree","renderIds","renderOnlyHarmonics","renderLoD","adaptiveSize","harmonicsScale","maxSplatScale","useClipping","maxDepth","geom","InstancedBufferGeometry","setAttribute","BufferAttribute","setIndex","mesh","Mesh","renderSplatsIDs","update","mat","visible","focalLengthX","projectionMatrix","focalLengthY","nodesCount","totalMemoryUsed","totalMemoryInDisplay","el","drawRange","count","traverseVisible","m","userData","nodeInfo","nodeInfo2","getAttribute","log","sortSplats","defer","counter","frameCounter","anim","requestAnimationFrame","cancelAnimationFrame","mvpMatrix","Matrix4","updateMatrixWorld","invert","premultiply","multiply","angleDiff","positionDiff","applyQuaternion","quaternion","dot","sub","sortMessage","async","_","getSplatData","globalID","nodeID","center","orientation","Quaternion","localToWorld","terminate","splatsEnabled","PointCloudOctree","potree","loadHarmonics","maxAmountOfSplats","MAX_AMOUNT_OF_SPLATS","maxLevel","splatsMesh","minNodePixelSize","boundingBoxNodes","visibleGeometry","numVisiblePoints","showBoundingBox","visibleBounds","renderAsSplats","updateMatrix","initMaterial","getBoundingBoxWorld","bWidth","lru","remove","picker","toTreeNode","updateSplats","hasAttribute","runSort","progress","updateVisibleBounds","bounds","expandByPoint","updateBoundingBoxes","bbRoot","getObjectByName","visibleBoxes","force","matrixWorldNeedsUpdate","multiplyMatrices","hideDescendants","object","toHide","addVisibleChildren","objToHide","moveToOrigin","getCenter","moveToGroundPlane","getVisibleExtent","maxAmountOfSplatsToRender","gl","FEATURES","SHADER_INTERPOLATION","hasExtension","hasMinVaryingVectors","SHADER_SPLATS","SHADER_EDL","precision","vsHighpFloat","getShaderPrecisionFormat","VERTEX_SHADER","HIGH_FLOAT","vsMediumpFloat","MEDIUM_FLOAT","fsHighpFloat","FRAGMENT_SHADER","fsMediumpFloat","highpAvailable","mediumpAvailable","getPrecision","ext","getExtension","getParameter","MAX_VARYING_VECTORS","AsyncBlockingQueue","resolvers","promises","enqueue","t","dequeue","AutoTerminatingWorker","wrappedWorker","maxIdle","timeoutId","terminated","isTerminated","markIdle","setTimeout","markInUse","clearTimeout","WorkerPool","maxWorkers","workerType","pool","poolSize","getWorker","POOL_MAX_IDLE","releaseWorker","Version","versionMinor","vmLength","versionMajor","newerThan","BinaryLoader","s","getNodeUrl","parse","WORKER_POOL","autoTerminatingWorker","addBufferAttributes","attributeBuffers","addIndices","addNormalAttribute","fromArray","getTightBoundingBox","message","toArray","isAttribute","indicesAttribute","Uint8BufferAttribute","normalized","loadPOC","transformedUrl","json","lx","ly","lz","ux","uy","uz","getBoundingBoxes","hierarchy","loadRoot","parseName","loadRemainingHierarchy","WorkerType","workers","DECODER_WORKER","DECODER_WORKER_GLTF","DECODER_WORKER_SPLATS","DECODER_WORKER_SPLATS_COMPRESSED","DecoderWorker","DecoderWorker_GLTF","createWorker","returnWorker","Decoder","metadata","_metadata","decode","byteOffset","urlOctree","octreePath","first","last","BigInt","ArrayBuffer","warn","headers","Range","octreeGeometry","doneEvent","readSuccessMessage","bufferAttribute","batchAttribute","attribute","preciseBuffer","range","extractBasePath","lastIndexOf","buildUrl","basePath","fileName","appendBuffer","buffer1","buffer2","tmp","GltfDecoder","urlColors","gltfColorsPath","urlPositions","gltfPositionsPath","headersPositions","responsePositions","headersColors","responseColors","GltfSplatDecoder","compressed","urls","dataUri","retrieveURL","filter","att","bufferView","uri","positions","colors","opacities","scales","rotations","shBand1_0","shBand1_1","shBand1_2","shBand2_0","shBand2_1","shBand2_2","shBand2_3","shBand2_4","shBand3_0","shBand3_1","shBand3_2","shBand3_3","shBand3_4","shBand3_5","shBand3_6","offsets","intOrFloat","sizes","fetchBuffer","offsetMultiplier","firstByte","fetchPromises","entries","all","OctreeGeometryNode","IDCount","getLevel","isLoaded","getBoundingBox","reject","getNumPoints","PointAttributeTypes","PointAttribute","description","NUMBER_OF_RETURNS","SOURCE_ID","INDICES","SPACING","GPS_TIME","vectors","addVector","vector","attributeName","attr","NodeLoader","loadingContext","encoding","decoder","some","nodeType","workerPool","density","hierarchyPath","parseHierarchy","bytesPerNode","numNodes","nodePos","childMask","getBigInt64","hierarchyByteOffset","hierarchyByteSize","childIndex","childName","childAABB","hierarchyUrl","tmpVec3","typenameTypeattributeMap","double","float","int8","uint8","int16","uint16","int32","uint32","int64","uint64","OctreeLoader","parseAttributes","jsonAttributes","replacements","rgb","jsonAttribute","initialRange","fetchMetadata","compressionTypeFile","fetchPCL","asset","extensions","ext_pix4d_gltf_gs_version","applyCustomBufferURI","createLoader","createBoundingBox","getOffset","initializeOctree","initializeRootNode","firstChunkSize","positionAttribute","loadOctree","trueUrl","BinaryHeap","scoreFunction","element","bubbleUp","end","sinkDown","score","parentN","elemScore","child2N","child1N","swap","child1","child1Score","child2","Box3Helper","LineSegments","LineBasicMaterial","LRUItem","next","previous","LRU","pointBudget","items","has","touch","item","touchExisting","addNew","delete","getLRUItem","freeMemory","memoryMultiplier","disposeSubtree","nodesToDispose","QueueItem","pointCloudIndex","weight","GEOMETRY_LOADERS","v1","v2","Potree","_pointBudget","_rendererSize","memoryScale","features","updateVisibilityStructures","frustumMatrix","inverseWorldMatrix","cameraMatrix","pointClouds","frustums","cameraPositions","priorityQueue","inverseViewMatrix","matrixWorldInverse","worldMatrix","identity","Frustum","setFromProjectionMatrix","setFromMatrixPosition","loadGeometry","loadPointCloud","input","fetch","updatePointClouds","updateVisibility","maxLoaderWorkers","unloadedGeometry","queueItem","loadedToGPUThisFrame","exceededMaxLoadsToGPU","nodeLoadFailed","intersectsBox","shouldClip","updateTreeNodeVisibility","halfHeight","updateChildVisibility","numNodesToLoad","nodeLoadPromises","updateBoundingBoxVisibility","distanceTo","radius","projectionFactor","tan","orthographic","top","bottom","screenPixelRadius","boxHelper","box2","clipMatrixWorld","clipBoxWorld"],"sourceRoot":""}